// --- template _header.gotpl ---
// Code generated by Prisma Client Go. DO NOT EDIT.
//nolint
//go:build !codeanalysis
// +build !codeanalysis

package db

import (
	"context"
	"fmt"
	"os"
	"slices"
	"testing"

	// no-op import for go modules
	_ "github.com/joho/godotenv"
	_ "github.com/shopspring/decimal"

	"github.com/steebchen/prisma-client-go/engine"
	"github.com/steebchen/prisma-client-go/engine/mock"
	"github.com/steebchen/prisma-client-go/runtime/builder"
	"github.com/steebchen/prisma-client-go/runtime/lifecycle"
	"github.com/steebchen/prisma-client-go/runtime/raw"
	"github.com/steebchen/prisma-client-go/runtime/transaction"
	"github.com/steebchen/prisma-client-go/runtime/types"
	rawmodels "github.com/steebchen/prisma-client-go/runtime/types/raw"
)

// ignore unused os import as it may not be needed depending on engine type
var _ = os.DevNull

// re-declare variables which are needed in Prisma Client Go but also should be exported
// in the generated client

type PrismaTransaction = transaction.Transaction

const RFC3339Milli = types.RFC3339Milli

type BatchResult = types.BatchResult

type Boolean = bool
type String = string
type Int = int
type Float = float64

type DateTime = types.DateTime
type JSON = types.JSON
type Bytes = types.Bytes
type BigInt = types.BigInt
type Decimal = types.Decimal

type RawString = rawmodels.String
type RawInt = rawmodels.Int
type RawFloat = rawmodels.Float
type RawBoolean = rawmodels.Boolean
type RawDateTime = rawmodels.DateTime
type RawJSON = rawmodels.JSON
type RawBytes = rawmodels.Bytes
type RawBigInt = rawmodels.BigInt
type RawDecimal = rawmodels.Decimal

// deprecated: use SortOrder
type Direction = SortOrder

const (
	// deprecated: use SortOrderAsc
	ASC Direction = "asc"
	// deprecated: use SortOrderDesc
	DESC Direction = "desc"
)

// --- template client.gotpl ---
const datasources = `[{"name":"db","provider":"postgresql","activeProvider":"postgresql","url":{"fromEnvVar":"DATABASE_URL","value":""},"config":null}]`

const schema = `generator client {
  provider = "go run github.com/steebchen/prisma-client-go"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model activitylog {
  auditid    BigInt @id @default(autoincrement())
  msgtype    String
  msgpayload Json
  updatedat  BigInt @default(dbgenerated("((EXTRACT(epoch FROM now()) * (1000)::numeric))::bigint"))
}

model devices {
  deviceid     String         @id
  devicemeta   Json
  createdat    BigInt         @default(dbgenerated("((EXTRACT(epoch FROM now()) * (1000)::numeric))::bigint"))
  createdby    String
  updatedat    BigInt         @default(dbgenerated("((EXTRACT(epoch FROM now()) * (1000)::numeric))::bigint"))
  updatedby    String
  groupdevices groupdevices[]
  orgdevices   orgdevices[]
}

model groupdevices {
  orgid     String
  groupid   String
  deviceid  String
  isexist   Boolean
  updatedat BigInt  @default(dbgenerated("((EXTRACT(epoch FROM now()) * (1000)::numeric))::bigint"))
  updatedby String
  devices   devices @relation(fields: [deviceid], references: [deviceid], onDelete: NoAction, onUpdate: NoAction)
  groups    groups  @relation(fields: [groupid], references: [groupid], onDelete: NoAction, onUpdate: NoAction)
  orgs      orgs    @relation(fields: [orgid], references: [orgid], onDelete: NoAction, onUpdate: NoAction)

  @@id([orgid, groupid, deviceid, isexist])
  @@unique([orgid, groupid, deviceid])
}

model groups {
  orgid                                String
  groupid                              String           @id
  groupname                            String
  isdeleted                            Boolean
  groupmeta                            Json?
  createdat                            BigInt           @default(dbgenerated("((EXTRACT(epoch FROM now()) * (1000)::numeric))::bigint"))
  createdby                            String
  updatedat                            BigInt           @default(dbgenerated("((EXTRACT(epoch FROM now()) * (1000)::numeric))::bigint"))
  updatedby                            String
  groupdevices                         groupdevices[]
  orgs                                 orgs             @relation(fields: [orgid], references: [orgid], onDelete: NoAction, onUpdate: NoAction)
  grouptree_grouptree_groupidTogroups  grouptree[]      @relation("grouptree_groupidTogroups")
  grouptree_grouptree_pgroupidTogroups grouptree[]      @relation("grouptree_pgroupidTogroups")
  groupuserperms                       groupuserperms[]
  orgrgroup                            orgrgroup[]
  usergroup                            usergroup[]
}

model grouptree {
  orgid                             String
  pgroupid                          String
  groupid                           String
  name                              String
  groups_grouptree_groupidTogroups  groups @relation("grouptree_groupidTogroups", fields: [groupid], references: [groupid], onDelete: NoAction, onUpdate: NoAction)
  orgs                              orgs   @relation(fields: [orgid], references: [orgid], onDelete: NoAction, onUpdate: NoAction)
  groups_grouptree_pgroupidTogroups groups @relation("grouptree_pgroupidTogroups", fields: [pgroupid], references: [groupid], onDelete: NoAction, onUpdate: NoAction)

  @@id([orgid, pgroupid, groupid])
  @@unique([orgid, pgroupid, name])
}

model groupuserperms {
  orgid   String
  groupid String
  userid  String
  permid  String
  groups  groups @relation(fields: [groupid], references: [groupid], onDelete: NoAction, onUpdate: NoAction)
  orgs    orgs   @relation(fields: [orgid], references: [orgid], onDelete: NoAction, onUpdate: NoAction)
  users   users  @relation(fields: [userid], references: [userid], onDelete: NoAction, onUpdate: NoAction)

  @@id([orgid, groupid, userid, permid])
}

model orgdevices {
  orgid         String
  deviceid      String
  orgdevicemeta Json
  updatedat     BigInt  @default(dbgenerated("((EXTRACT(epoch FROM now()) * (1000)::numeric))::bigint"))
  updatedby     String
  devices       devices @relation(fields: [deviceid], references: [deviceid], onDelete: NoAction, onUpdate: NoAction)
  orgs          orgs    @relation(fields: [orgid], references: [orgid], onDelete: NoAction, onUpdate: NoAction)

  @@id([orgid, deviceid])
}

model orgrgroup {
  orgid       String @id
  rootgroupid String
  orgs        orgs   @relation(fields: [orgid], references: [orgid], onDelete: NoAction, onUpdate: NoAction)
  groups      groups @relation(fields: [rootgroupid], references: [groupid], onDelete: NoAction, onUpdate: NoAction)
}

model orgs {
  orgid          String           @id
  orgname        String           @unique
  orgmeta        Json
  isenabled      Boolean          @default(true)
  createdby      String
  updatedby      String
  createdat      BigInt           @default(dbgenerated("((EXTRACT(epoch FROM now()) * (1000)::numeric))::bigint"))
  updatedat      BigInt           @default(dbgenerated("((EXTRACT(epoch FROM now()) * (1000)::numeric))::bigint"))
  groupdevices   groupdevices[]
  groups         groups[]
  grouptree      grouptree[]
  groupuserperms groupuserperms[]
  orgdevices     orgdevices[]
  orgrgroup      orgrgroup?
  usergroup      usergroup[]
}

model usergroup {
  userid  String
  orgid   String
  groupid String
  groups  groups @relation(fields: [groupid], references: [groupid], onDelete: NoAction, onUpdate: NoAction)
  orgs    orgs   @relation(fields: [orgid], references: [orgid], onDelete: NoAction, onUpdate: NoAction)
  users   users  @relation(fields: [userid], references: [userid], onDelete: NoAction, onUpdate: NoAction)

  @@id([userid, orgid, groupid])
}

model users {
  userid          String           @id
  name            String
  email           String
  isemailverified Boolean
  usermeta        Json?
  isenabled       Boolean
  secretprv       String
  secretpub       String
  createdat       BigInt
  updatedat       BigInt
  groupuserperms  groupuserperms[]
  usergroup       usergroup[]
}
`
const schemaDatasourceURL = ""
const schemaEnvVarName = "DATABASE_URL"

// hasBinaryTargets is true when binaryTargets are provided on generation time
var hasBinaryTargets = true

// NewClient creates a new Prisma Client Go client.
// The client is not connected to the Prisma engine yet.
//
// Example:
//
//	client := db.NewClient()
//	if err := client.Prisma.Connect(); err != nil {
//	  handle(err)
//	}
//
//	defer func() {
//	  if err := client.Prisma.Disconnect(); err != nil {
//	    panic(fmt.Errorf("could not disconnect: %w", err))
//	  }
//	}()
func NewClient(options ...func(config *PrismaConfig)) *PrismaClient {
	var config PrismaConfig
	for _, option := range options {
		option(&config)
	}

	c := newClient()

	// use the schema connection url if set
	url := config.datasourceURL
	if url == "" {
		url = schemaDatasourceURL
		if url == "" {
			// if not, use the schema env var name
			url = os.Getenv(schemaEnvVarName)
			if url == "" {
				//panic("no connection string found")
				println("WARNING: env var which was defined in the Prisma schema is not set " + schemaEnvVarName)
			}
		}
	}

	c.Engine = engine.NewQueryEngine(schema, hasBinaryTargets, datasources, url)

	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

type PrismaConfig struct {
	datasourceURL string
}

func WithDatasourceURL(url string) func(*PrismaConfig) {
	return func(config *PrismaConfig) {
		config.datasourceURL = url
	}
}

func newMockClient(expectations *[]mock.Expectation) *PrismaClient {
	c := newClient()
	c.Engine = mock.New(expectations)
	c.Prisma.Lifecycle = &lifecycle.Lifecycle{Engine: c.Engine}

	return c
}

func newClient() *PrismaClient {
	c := &PrismaClient{}
	c.Activitylog = activitylogActions{client: c}
	c.Devices = devicesActions{client: c}
	c.Groupdevices = groupdevicesActions{client: c}
	c.Groups = groupsActions{client: c}
	c.Grouptree = grouptreeActions{client: c}
	c.Groupuserperms = groupuserpermsActions{client: c}
	c.Orgdevices = orgdevicesActions{client: c}
	c.Orgrgroup = orgrgroupActions{client: c}
	c.Orgs = orgsActions{client: c}
	c.Usergroup = usergroupActions{client: c}
	c.Users = usersActions{client: c}

	c.Prisma = &PrismaActions{
		Raw: &raw.Raw{Engine: c},
		TX:  &transaction.TX{Engine: c},
	}
	return c
}

type PrismaActions struct {
	*lifecycle.Lifecycle
	*raw.Raw
	*transaction.TX
}

// PrismaClient is the instance of the Prisma Client Go client.
type PrismaClient struct {
	// engine is an abstractions of what happens under the hood
	// the query engine can spawn and manage the binary and send requests to it,
	// while a mock engine would collect mocks to verify them later
	engine.Engine

	// prisma provides prisma-related methods as opposed to model methods, such as Connect, Disconnect or raw queries
	Prisma *PrismaActions

	// Activitylog provides access to CRUD methods.
	Activitylog activitylogActions
	// Devices provides access to CRUD methods.
	Devices devicesActions
	// Groupdevices provides access to CRUD methods.
	Groupdevices groupdevicesActions
	// Groups provides access to CRUD methods.
	Groups groupsActions
	// Grouptree provides access to CRUD methods.
	Grouptree grouptreeActions
	// Groupuserperms provides access to CRUD methods.
	Groupuserperms groupuserpermsActions
	// Orgdevices provides access to CRUD methods.
	Orgdevices orgdevicesActions
	// Orgrgroup provides access to CRUD methods.
	Orgrgroup orgrgroupActions
	// Orgs provides access to CRUD methods.
	Orgs orgsActions
	// Usergroup provides access to CRUD methods.
	Usergroup usergroupActions
	// Users provides access to CRUD methods.
	Users usersActions
}

// --- template enums.gotpl ---

type TransactionIsolationLevel string

const (
	TransactionIsolationLevelReadUncommitted TransactionIsolationLevel = "ReadUncommitted"
	TransactionIsolationLevelReadCommitted   TransactionIsolationLevel = "ReadCommitted"
	TransactionIsolationLevelRepeatableRead  TransactionIsolationLevel = "RepeatableRead"
	TransactionIsolationLevelSerializable    TransactionIsolationLevel = "Serializable"
)

type ActivitylogScalarFieldEnum string

const (
	ActivitylogScalarFieldEnumAuditid    ActivitylogScalarFieldEnum = "auditid"
	ActivitylogScalarFieldEnumMsgtype    ActivitylogScalarFieldEnum = "msgtype"
	ActivitylogScalarFieldEnumMsgpayload ActivitylogScalarFieldEnum = "msgpayload"
	ActivitylogScalarFieldEnumUpdatedat  ActivitylogScalarFieldEnum = "updatedat"
)

type DevicesScalarFieldEnum string

const (
	DevicesScalarFieldEnumDeviceid   DevicesScalarFieldEnum = "deviceid"
	DevicesScalarFieldEnumDevicemeta DevicesScalarFieldEnum = "devicemeta"
	DevicesScalarFieldEnumCreatedat  DevicesScalarFieldEnum = "createdat"
	DevicesScalarFieldEnumCreatedby  DevicesScalarFieldEnum = "createdby"
	DevicesScalarFieldEnumUpdatedat  DevicesScalarFieldEnum = "updatedat"
	DevicesScalarFieldEnumUpdatedby  DevicesScalarFieldEnum = "updatedby"
)

type GroupdevicesScalarFieldEnum string

const (
	GroupdevicesScalarFieldEnumOrgid     GroupdevicesScalarFieldEnum = "orgid"
	GroupdevicesScalarFieldEnumGroupid   GroupdevicesScalarFieldEnum = "groupid"
	GroupdevicesScalarFieldEnumDeviceid  GroupdevicesScalarFieldEnum = "deviceid"
	GroupdevicesScalarFieldEnumIsexist   GroupdevicesScalarFieldEnum = "isexist"
	GroupdevicesScalarFieldEnumUpdatedat GroupdevicesScalarFieldEnum = "updatedat"
	GroupdevicesScalarFieldEnumUpdatedby GroupdevicesScalarFieldEnum = "updatedby"
)

type GroupsScalarFieldEnum string

const (
	GroupsScalarFieldEnumOrgid     GroupsScalarFieldEnum = "orgid"
	GroupsScalarFieldEnumGroupid   GroupsScalarFieldEnum = "groupid"
	GroupsScalarFieldEnumGroupname GroupsScalarFieldEnum = "groupname"
	GroupsScalarFieldEnumIsdeleted GroupsScalarFieldEnum = "isdeleted"
	GroupsScalarFieldEnumGroupmeta GroupsScalarFieldEnum = "groupmeta"
	GroupsScalarFieldEnumCreatedat GroupsScalarFieldEnum = "createdat"
	GroupsScalarFieldEnumCreatedby GroupsScalarFieldEnum = "createdby"
	GroupsScalarFieldEnumUpdatedat GroupsScalarFieldEnum = "updatedat"
	GroupsScalarFieldEnumUpdatedby GroupsScalarFieldEnum = "updatedby"
)

type GrouptreeScalarFieldEnum string

const (
	GrouptreeScalarFieldEnumOrgid    GrouptreeScalarFieldEnum = "orgid"
	GrouptreeScalarFieldEnumPgroupid GrouptreeScalarFieldEnum = "pgroupid"
	GrouptreeScalarFieldEnumGroupid  GrouptreeScalarFieldEnum = "groupid"
	GrouptreeScalarFieldEnumName     GrouptreeScalarFieldEnum = "name"
)

type GroupuserpermsScalarFieldEnum string

const (
	GroupuserpermsScalarFieldEnumOrgid   GroupuserpermsScalarFieldEnum = "orgid"
	GroupuserpermsScalarFieldEnumGroupid GroupuserpermsScalarFieldEnum = "groupid"
	GroupuserpermsScalarFieldEnumUserid  GroupuserpermsScalarFieldEnum = "userid"
	GroupuserpermsScalarFieldEnumPermid  GroupuserpermsScalarFieldEnum = "permid"
)

type OrgdevicesScalarFieldEnum string

const (
	OrgdevicesScalarFieldEnumOrgid         OrgdevicesScalarFieldEnum = "orgid"
	OrgdevicesScalarFieldEnumDeviceid      OrgdevicesScalarFieldEnum = "deviceid"
	OrgdevicesScalarFieldEnumOrgdevicemeta OrgdevicesScalarFieldEnum = "orgdevicemeta"
	OrgdevicesScalarFieldEnumUpdatedat     OrgdevicesScalarFieldEnum = "updatedat"
	OrgdevicesScalarFieldEnumUpdatedby     OrgdevicesScalarFieldEnum = "updatedby"
)

type OrgrgroupScalarFieldEnum string

const (
	OrgrgroupScalarFieldEnumOrgid       OrgrgroupScalarFieldEnum = "orgid"
	OrgrgroupScalarFieldEnumRootgroupid OrgrgroupScalarFieldEnum = "rootgroupid"
)

type OrgsScalarFieldEnum string

const (
	OrgsScalarFieldEnumOrgid     OrgsScalarFieldEnum = "orgid"
	OrgsScalarFieldEnumOrgname   OrgsScalarFieldEnum = "orgname"
	OrgsScalarFieldEnumOrgmeta   OrgsScalarFieldEnum = "orgmeta"
	OrgsScalarFieldEnumIsenabled OrgsScalarFieldEnum = "isenabled"
	OrgsScalarFieldEnumCreatedby OrgsScalarFieldEnum = "createdby"
	OrgsScalarFieldEnumUpdatedby OrgsScalarFieldEnum = "updatedby"
	OrgsScalarFieldEnumCreatedat OrgsScalarFieldEnum = "createdat"
	OrgsScalarFieldEnumUpdatedat OrgsScalarFieldEnum = "updatedat"
)

type UsergroupScalarFieldEnum string

const (
	UsergroupScalarFieldEnumUserid  UsergroupScalarFieldEnum = "userid"
	UsergroupScalarFieldEnumOrgid   UsergroupScalarFieldEnum = "orgid"
	UsergroupScalarFieldEnumGroupid UsergroupScalarFieldEnum = "groupid"
)

type UsersScalarFieldEnum string

const (
	UsersScalarFieldEnumUserid          UsersScalarFieldEnum = "userid"
	UsersScalarFieldEnumName            UsersScalarFieldEnum = "name"
	UsersScalarFieldEnumEmail           UsersScalarFieldEnum = "email"
	UsersScalarFieldEnumIsemailverified UsersScalarFieldEnum = "isemailverified"
	UsersScalarFieldEnumUsermeta        UsersScalarFieldEnum = "usermeta"
	UsersScalarFieldEnumIsenabled       UsersScalarFieldEnum = "isenabled"
	UsersScalarFieldEnumSecretprv       UsersScalarFieldEnum = "secretprv"
	UsersScalarFieldEnumSecretpub       UsersScalarFieldEnum = "secretpub"
	UsersScalarFieldEnumCreatedat       UsersScalarFieldEnum = "createdat"
	UsersScalarFieldEnumUpdatedat       UsersScalarFieldEnum = "updatedat"
)

type SortOrder string

const (
	SortOrderAsc  SortOrder = "asc"
	SortOrderDesc SortOrder = "desc"
)

type JSONNullValueInput string

const (
	JSONNullValueInputJSONNull JSONNullValueInput = "JsonNull"
)

type NullableJSONNullValueInput string

const (
	NullableJSONNullValueInputDBNull   NullableJSONNullValueInput = "DbNull"
	NullableJSONNullValueInputJSONNull NullableJSONNullValueInput = "JsonNull"
)

type QueryMode string

const (
	QueryModeDefault     QueryMode = "default"
	QueryModeInsensitive QueryMode = "insensitive"
)

type JSONNullValueFilter string

const (
	JSONNullValueFilterDBNull   JSONNullValueFilter = "DbNull"
	JSONNullValueFilterJSONNull JSONNullValueFilter = "JsonNull"
	JSONNullValueFilterAnyNull  JSONNullValueFilter = "AnyNull"
)

type NullsOrder string

const (
	NullsOrderFirst NullsOrder = "first"
	NullsOrderLast  NullsOrder = "last"
)

// --- template errors.gotpl ---
var ErrNotFound = types.ErrNotFound
var IsErrNotFound = types.IsErrNotFound

type ErrUniqueConstraint = types.ErrUniqueConstraint[prismaFields]

// IsErrUniqueConstraint returns on a unique constraint error or violation with error info
// Use as follows:
//
//	user, err := db.User.CreateOne(...).Exec(cxt)
//	if err != nil {
//		if info, err := db.IsErrUniqueConstraint(err); err != nil {
//			// Fields exists for Postgres and SQLite
//			log.Printf("unique constraint on the fields: %s", info.Fields)
//
//			// you can also compare it with generated field names:
//			if info.Fields[0] == db.User.Name.Field() {
//				// do something
//			}
//
//			// For MySQL, use the constraint key
//			log.Printf("unique constraint on the key: %s", info.Key)
//		}
//	}
func IsErrUniqueConstraint(err error) (*types.ErrUniqueConstraint[prismaFields], bool) {
	return types.CheckUniqueConstraint[prismaFields](err)
}

// --- template fields.gotpl ---
type prismaFields string

type activitylogPrismaFields = prismaFields

const activitylogFieldAuditid activitylogPrismaFields = "auditid"

const activitylogFieldMsgtype activitylogPrismaFields = "msgtype"

const activitylogFieldMsgpayload activitylogPrismaFields = "msgpayload"

const activitylogFieldUpdatedat activitylogPrismaFields = "updatedat"

type devicesPrismaFields = prismaFields

const devicesFieldDeviceid devicesPrismaFields = "deviceid"

const devicesFieldDevicemeta devicesPrismaFields = "devicemeta"

const devicesFieldCreatedat devicesPrismaFields = "createdat"

const devicesFieldCreatedby devicesPrismaFields = "createdby"

const devicesFieldUpdatedat devicesPrismaFields = "updatedat"

const devicesFieldUpdatedby devicesPrismaFields = "updatedby"

const devicesFieldGroupdevices devicesPrismaFields = "groupdevices"

const devicesFieldOrgdevices devicesPrismaFields = "orgdevices"

type groupdevicesPrismaFields = prismaFields

const groupdevicesFieldOrgid groupdevicesPrismaFields = "orgid"

const groupdevicesFieldGroupid groupdevicesPrismaFields = "groupid"

const groupdevicesFieldDeviceid groupdevicesPrismaFields = "deviceid"

const groupdevicesFieldIsexist groupdevicesPrismaFields = "isexist"

const groupdevicesFieldUpdatedat groupdevicesPrismaFields = "updatedat"

const groupdevicesFieldUpdatedby groupdevicesPrismaFields = "updatedby"

const groupdevicesFieldDevices groupdevicesPrismaFields = "devices"

const groupdevicesFieldGroups groupdevicesPrismaFields = "groups"

const groupdevicesFieldOrgs groupdevicesPrismaFields = "orgs"

type groupsPrismaFields = prismaFields

const groupsFieldOrgid groupsPrismaFields = "orgid"

const groupsFieldGroupid groupsPrismaFields = "groupid"

const groupsFieldGroupname groupsPrismaFields = "groupname"

const groupsFieldIsdeleted groupsPrismaFields = "isdeleted"

const groupsFieldGroupmeta groupsPrismaFields = "groupmeta"

const groupsFieldCreatedat groupsPrismaFields = "createdat"

const groupsFieldCreatedby groupsPrismaFields = "createdby"

const groupsFieldUpdatedat groupsPrismaFields = "updatedat"

const groupsFieldUpdatedby groupsPrismaFields = "updatedby"

const groupsFieldGroupdevices groupsPrismaFields = "groupdevices"

const groupsFieldOrgs groupsPrismaFields = "orgs"

const groupsFieldGrouptreeGrouptreeGroupidTogroups groupsPrismaFields = "grouptree_grouptree_groupidTogroups"

const groupsFieldGrouptreeGrouptreePgroupidTogroups groupsPrismaFields = "grouptree_grouptree_pgroupidTogroups"

const groupsFieldGroupuserperms groupsPrismaFields = "groupuserperms"

const groupsFieldOrgrgroup groupsPrismaFields = "orgrgroup"

const groupsFieldUsergroup groupsPrismaFields = "usergroup"

type grouptreePrismaFields = prismaFields

const grouptreeFieldOrgid grouptreePrismaFields = "orgid"

const grouptreeFieldPgroupid grouptreePrismaFields = "pgroupid"

const grouptreeFieldGroupid grouptreePrismaFields = "groupid"

const grouptreeFieldName grouptreePrismaFields = "name"

const grouptreeFieldGroupsGrouptreeGroupidTogroups grouptreePrismaFields = "groups_grouptree_groupidTogroups"

const grouptreeFieldOrgs grouptreePrismaFields = "orgs"

const grouptreeFieldGroupsGrouptreePgroupidTogroups grouptreePrismaFields = "groups_grouptree_pgroupidTogroups"

type groupuserpermsPrismaFields = prismaFields

const groupuserpermsFieldOrgid groupuserpermsPrismaFields = "orgid"

const groupuserpermsFieldGroupid groupuserpermsPrismaFields = "groupid"

const groupuserpermsFieldUserid groupuserpermsPrismaFields = "userid"

const groupuserpermsFieldPermid groupuserpermsPrismaFields = "permid"

const groupuserpermsFieldGroups groupuserpermsPrismaFields = "groups"

const groupuserpermsFieldOrgs groupuserpermsPrismaFields = "orgs"

const groupuserpermsFieldUsers groupuserpermsPrismaFields = "users"

type orgdevicesPrismaFields = prismaFields

const orgdevicesFieldOrgid orgdevicesPrismaFields = "orgid"

const orgdevicesFieldDeviceid orgdevicesPrismaFields = "deviceid"

const orgdevicesFieldOrgdevicemeta orgdevicesPrismaFields = "orgdevicemeta"

const orgdevicesFieldUpdatedat orgdevicesPrismaFields = "updatedat"

const orgdevicesFieldUpdatedby orgdevicesPrismaFields = "updatedby"

const orgdevicesFieldDevices orgdevicesPrismaFields = "devices"

const orgdevicesFieldOrgs orgdevicesPrismaFields = "orgs"

type orgrgroupPrismaFields = prismaFields

const orgrgroupFieldOrgid orgrgroupPrismaFields = "orgid"

const orgrgroupFieldRootgroupid orgrgroupPrismaFields = "rootgroupid"

const orgrgroupFieldOrgs orgrgroupPrismaFields = "orgs"

const orgrgroupFieldGroups orgrgroupPrismaFields = "groups"

type orgsPrismaFields = prismaFields

const orgsFieldOrgid orgsPrismaFields = "orgid"

const orgsFieldOrgname orgsPrismaFields = "orgname"

const orgsFieldOrgmeta orgsPrismaFields = "orgmeta"

const orgsFieldIsenabled orgsPrismaFields = "isenabled"

const orgsFieldCreatedby orgsPrismaFields = "createdby"

const orgsFieldUpdatedby orgsPrismaFields = "updatedby"

const orgsFieldCreatedat orgsPrismaFields = "createdat"

const orgsFieldUpdatedat orgsPrismaFields = "updatedat"

const orgsFieldGroupdevices orgsPrismaFields = "groupdevices"

const orgsFieldGroups orgsPrismaFields = "groups"

const orgsFieldGrouptree orgsPrismaFields = "grouptree"

const orgsFieldGroupuserperms orgsPrismaFields = "groupuserperms"

const orgsFieldOrgdevices orgsPrismaFields = "orgdevices"

const orgsFieldOrgrgroup orgsPrismaFields = "orgrgroup"

const orgsFieldUsergroup orgsPrismaFields = "usergroup"

type usergroupPrismaFields = prismaFields

const usergroupFieldUserid usergroupPrismaFields = "userid"

const usergroupFieldOrgid usergroupPrismaFields = "orgid"

const usergroupFieldGroupid usergroupPrismaFields = "groupid"

const usergroupFieldGroups usergroupPrismaFields = "groups"

const usergroupFieldOrgs usergroupPrismaFields = "orgs"

const usergroupFieldUsers usergroupPrismaFields = "users"

type usersPrismaFields = prismaFields

const usersFieldUserid usersPrismaFields = "userid"

const usersFieldName usersPrismaFields = "name"

const usersFieldEmail usersPrismaFields = "email"

const usersFieldIsemailverified usersPrismaFields = "isemailverified"

const usersFieldUsermeta usersPrismaFields = "usermeta"

const usersFieldIsenabled usersPrismaFields = "isenabled"

const usersFieldSecretprv usersPrismaFields = "secretprv"

const usersFieldSecretpub usersPrismaFields = "secretpub"

const usersFieldCreatedat usersPrismaFields = "createdat"

const usersFieldUpdatedat usersPrismaFields = "updatedat"

const usersFieldGroupuserperms usersPrismaFields = "groupuserperms"

const usersFieldUsergroup usersPrismaFields = "usergroup"

// --- template mock.gotpl ---
func NewMock() (*PrismaClient, *Mock, func(t *testing.T)) {
	expectations := new([]mock.Expectation)
	pc := newMockClient(expectations)
	m := &Mock{
		Mock: &mock.Mock{
			Expectations: expectations,
		},
	}

	m.Activitylog = activitylogMock{
		mock: m,
	}

	m.Devices = devicesMock{
		mock: m,
	}

	m.Groupdevices = groupdevicesMock{
		mock: m,
	}

	m.Groups = groupsMock{
		mock: m,
	}

	m.Grouptree = grouptreeMock{
		mock: m,
	}

	m.Groupuserperms = groupuserpermsMock{
		mock: m,
	}

	m.Orgdevices = orgdevicesMock{
		mock: m,
	}

	m.Orgrgroup = orgrgroupMock{
		mock: m,
	}

	m.Orgs = orgsMock{
		mock: m,
	}

	m.Usergroup = usergroupMock{
		mock: m,
	}

	m.Users = usersMock{
		mock: m,
	}

	return pc, m, m.Ensure
}

type Mock struct {
	*mock.Mock

	Activitylog activitylogMock

	Devices devicesMock

	Groupdevices groupdevicesMock

	Groups groupsMock

	Grouptree grouptreeMock

	Groupuserperms groupuserpermsMock

	Orgdevices orgdevicesMock

	Orgrgroup orgrgroupMock

	Orgs orgsMock

	Usergroup usergroupMock

	Users usersMock
}

type activitylogMock struct {
	mock *Mock
}

type ActivitylogMockExpectParam interface {
	ExtractQuery() builder.Query
	activitylogModel()
}

func (m *activitylogMock) Expect(query ActivitylogMockExpectParam) *activitylogMockExec {
	return &activitylogMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type activitylogMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *activitylogMockExec) Returns(v ActivitylogModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *activitylogMockExec) ReturnsMany(v []ActivitylogModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *activitylogMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type devicesMock struct {
	mock *Mock
}

type DevicesMockExpectParam interface {
	ExtractQuery() builder.Query
	devicesModel()
}

func (m *devicesMock) Expect(query DevicesMockExpectParam) *devicesMockExec {
	return &devicesMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type devicesMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *devicesMockExec) Returns(v DevicesModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *devicesMockExec) ReturnsMany(v []DevicesModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *devicesMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type groupdevicesMock struct {
	mock *Mock
}

type GroupdevicesMockExpectParam interface {
	ExtractQuery() builder.Query
	groupdevicesModel()
}

func (m *groupdevicesMock) Expect(query GroupdevicesMockExpectParam) *groupdevicesMockExec {
	return &groupdevicesMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type groupdevicesMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *groupdevicesMockExec) Returns(v GroupdevicesModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *groupdevicesMockExec) ReturnsMany(v []GroupdevicesModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *groupdevicesMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type groupsMock struct {
	mock *Mock
}

type GroupsMockExpectParam interface {
	ExtractQuery() builder.Query
	groupsModel()
}

func (m *groupsMock) Expect(query GroupsMockExpectParam) *groupsMockExec {
	return &groupsMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type groupsMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *groupsMockExec) Returns(v GroupsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *groupsMockExec) ReturnsMany(v []GroupsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *groupsMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type grouptreeMock struct {
	mock *Mock
}

type GrouptreeMockExpectParam interface {
	ExtractQuery() builder.Query
	grouptreeModel()
}

func (m *grouptreeMock) Expect(query GrouptreeMockExpectParam) *grouptreeMockExec {
	return &grouptreeMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type grouptreeMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *grouptreeMockExec) Returns(v GrouptreeModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *grouptreeMockExec) ReturnsMany(v []GrouptreeModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *grouptreeMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type groupuserpermsMock struct {
	mock *Mock
}

type GroupuserpermsMockExpectParam interface {
	ExtractQuery() builder.Query
	groupuserpermsModel()
}

func (m *groupuserpermsMock) Expect(query GroupuserpermsMockExpectParam) *groupuserpermsMockExec {
	return &groupuserpermsMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type groupuserpermsMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *groupuserpermsMockExec) Returns(v GroupuserpermsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *groupuserpermsMockExec) ReturnsMany(v []GroupuserpermsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *groupuserpermsMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type orgdevicesMock struct {
	mock *Mock
}

type OrgdevicesMockExpectParam interface {
	ExtractQuery() builder.Query
	orgdevicesModel()
}

func (m *orgdevicesMock) Expect(query OrgdevicesMockExpectParam) *orgdevicesMockExec {
	return &orgdevicesMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type orgdevicesMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *orgdevicesMockExec) Returns(v OrgdevicesModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *orgdevicesMockExec) ReturnsMany(v []OrgdevicesModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *orgdevicesMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type orgrgroupMock struct {
	mock *Mock
}

type OrgrgroupMockExpectParam interface {
	ExtractQuery() builder.Query
	orgrgroupModel()
}

func (m *orgrgroupMock) Expect(query OrgrgroupMockExpectParam) *orgrgroupMockExec {
	return &orgrgroupMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type orgrgroupMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *orgrgroupMockExec) Returns(v OrgrgroupModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *orgrgroupMockExec) ReturnsMany(v []OrgrgroupModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *orgrgroupMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type orgsMock struct {
	mock *Mock
}

type OrgsMockExpectParam interface {
	ExtractQuery() builder.Query
	orgsModel()
}

func (m *orgsMock) Expect(query OrgsMockExpectParam) *orgsMockExec {
	return &orgsMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type orgsMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *orgsMockExec) Returns(v OrgsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *orgsMockExec) ReturnsMany(v []OrgsModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *orgsMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type usergroupMock struct {
	mock *Mock
}

type UsergroupMockExpectParam interface {
	ExtractQuery() builder.Query
	usergroupModel()
}

func (m *usergroupMock) Expect(query UsergroupMockExpectParam) *usergroupMockExec {
	return &usergroupMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type usergroupMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *usergroupMockExec) Returns(v UsergroupModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *usergroupMockExec) ReturnsMany(v []UsergroupModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *usergroupMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

type usersMock struct {
	mock *Mock
}

type UsersMockExpectParam interface {
	ExtractQuery() builder.Query
	usersModel()
}

func (m *usersMock) Expect(query UsersMockExpectParam) *usersMockExec {
	return &usersMockExec{
		mock:  m.mock,
		query: query.ExtractQuery(),
	}
}

type usersMockExec struct {
	mock  *Mock
	query builder.Query
}

func (m *usersMockExec) Returns(v UsersModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *usersMockExec) ReturnsMany(v []UsersModel) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query: m.query,
		Want:  &v,
	})
}

func (m *usersMockExec) Errors(err error) {
	*m.mock.Expectations = append(*m.mock.Expectations, mock.Expectation{
		Query:   m.query,
		WantErr: err,
	})
}

// --- template models.gotpl ---

// ActivitylogModel represents the activitylog model and is a wrapper for accessing fields and methods
type ActivitylogModel struct {
	InnerActivitylog
	RelationsActivitylog
}

// InnerActivitylog holds the actual data
type InnerActivitylog struct {
	Auditid    BigInt `json:"auditid"`
	Msgtype    string `json:"msgtype"`
	Msgpayload JSON   `json:"msgpayload"`
	Updatedat  BigInt `json:"updatedat"`
}

// RawActivitylogModel is a struct for activitylog when used in raw queries
type RawActivitylogModel struct {
	Auditid    RawBigInt `json:"auditid"`
	Msgtype    RawString `json:"msgtype"`
	Msgpayload RawJSON   `json:"msgpayload"`
	Updatedat  RawBigInt `json:"updatedat"`
}

// RelationsActivitylog holds the relation data separately
type RelationsActivitylog struct {
}

// DevicesModel represents the devices model and is a wrapper for accessing fields and methods
type DevicesModel struct {
	InnerDevices
	RelationsDevices
}

// InnerDevices holds the actual data
type InnerDevices struct {
	Deviceid   string `json:"deviceid"`
	Devicemeta JSON   `json:"devicemeta"`
	Createdat  BigInt `json:"createdat"`
	Createdby  string `json:"createdby"`
	Updatedat  BigInt `json:"updatedat"`
	Updatedby  string `json:"updatedby"`
}

// RawDevicesModel is a struct for devices when used in raw queries
type RawDevicesModel struct {
	Deviceid   RawString `json:"deviceid"`
	Devicemeta RawJSON   `json:"devicemeta"`
	Createdat  RawBigInt `json:"createdat"`
	Createdby  RawString `json:"createdby"`
	Updatedat  RawBigInt `json:"updatedat"`
	Updatedby  RawString `json:"updatedby"`
}

// RelationsDevices holds the relation data separately
type RelationsDevices struct {
	Groupdevices []GroupdevicesModel `json:"groupdevices,omitempty"`
	Orgdevices   []OrgdevicesModel   `json:"orgdevices,omitempty"`
}

func (r DevicesModel) Groupdevices() (value []GroupdevicesModel) {
	if r.RelationsDevices.Groupdevices == nil {
		panic("attempted to access groupdevices but did not fetch it using the .With() syntax")
	}
	return r.RelationsDevices.Groupdevices
}

func (r DevicesModel) Orgdevices() (value []OrgdevicesModel) {
	if r.RelationsDevices.Orgdevices == nil {
		panic("attempted to access orgdevices but did not fetch it using the .With() syntax")
	}
	return r.RelationsDevices.Orgdevices
}

// GroupdevicesModel represents the groupdevices model and is a wrapper for accessing fields and methods
type GroupdevicesModel struct {
	InnerGroupdevices
	RelationsGroupdevices
}

// InnerGroupdevices holds the actual data
type InnerGroupdevices struct {
	Orgid     string `json:"orgid"`
	Groupid   string `json:"groupid"`
	Deviceid  string `json:"deviceid"`
	Isexist   bool   `json:"isexist"`
	Updatedat BigInt `json:"updatedat"`
	Updatedby string `json:"updatedby"`
}

// RawGroupdevicesModel is a struct for groupdevices when used in raw queries
type RawGroupdevicesModel struct {
	Orgid     RawString  `json:"orgid"`
	Groupid   RawString  `json:"groupid"`
	Deviceid  RawString  `json:"deviceid"`
	Isexist   RawBoolean `json:"isexist"`
	Updatedat RawBigInt  `json:"updatedat"`
	Updatedby RawString  `json:"updatedby"`
}

// RelationsGroupdevices holds the relation data separately
type RelationsGroupdevices struct {
	Devices *DevicesModel `json:"devices,omitempty"`
	Groups  *GroupsModel  `json:"groups,omitempty"`
	Orgs    *OrgsModel    `json:"orgs,omitempty"`
}

func (r GroupdevicesModel) Devices() (value *DevicesModel) {
	if r.RelationsGroupdevices.Devices == nil {
		panic("attempted to access devices but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroupdevices.Devices
}

func (r GroupdevicesModel) Groups() (value *GroupsModel) {
	if r.RelationsGroupdevices.Groups == nil {
		panic("attempted to access groups but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroupdevices.Groups
}

func (r GroupdevicesModel) Orgs() (value *OrgsModel) {
	if r.RelationsGroupdevices.Orgs == nil {
		panic("attempted to access orgs but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroupdevices.Orgs
}

// GroupsModel represents the groups model and is a wrapper for accessing fields and methods
type GroupsModel struct {
	InnerGroups
	RelationsGroups
}

// InnerGroups holds the actual data
type InnerGroups struct {
	Orgid     string `json:"orgid"`
	Groupid   string `json:"groupid"`
	Groupname string `json:"groupname"`
	Isdeleted bool   `json:"isdeleted"`
	Groupmeta *JSON  `json:"groupmeta,omitempty"`
	Createdat BigInt `json:"createdat"`
	Createdby string `json:"createdby"`
	Updatedat BigInt `json:"updatedat"`
	Updatedby string `json:"updatedby"`
}

// RawGroupsModel is a struct for groups when used in raw queries
type RawGroupsModel struct {
	Orgid     RawString  `json:"orgid"`
	Groupid   RawString  `json:"groupid"`
	Groupname RawString  `json:"groupname"`
	Isdeleted RawBoolean `json:"isdeleted"`
	Groupmeta *RawJSON   `json:"groupmeta,omitempty"`
	Createdat RawBigInt  `json:"createdat"`
	Createdby RawString  `json:"createdby"`
	Updatedat RawBigInt  `json:"updatedat"`
	Updatedby RawString  `json:"updatedby"`
}

// RelationsGroups holds the relation data separately
type RelationsGroups struct {
	Groupdevices                       []GroupdevicesModel   `json:"groupdevices,omitempty"`
	Orgs                               *OrgsModel            `json:"orgs,omitempty"`
	GrouptreeGrouptreeGroupidTogroups  []GrouptreeModel      `json:"grouptree_grouptree_groupidTogroups,omitempty"`
	GrouptreeGrouptreePgroupidTogroups []GrouptreeModel      `json:"grouptree_grouptree_pgroupidTogroups,omitempty"`
	Groupuserperms                     []GroupuserpermsModel `json:"groupuserperms,omitempty"`
	Orgrgroup                          []OrgrgroupModel      `json:"orgrgroup,omitempty"`
	Usergroup                          []UsergroupModel      `json:"usergroup,omitempty"`
}

func (r GroupsModel) Groupmeta() (value JSON, ok bool) {
	if r.InnerGroups.Groupmeta == nil {
		return value, false
	}
	return *r.InnerGroups.Groupmeta, true
}

func (r GroupsModel) Groupdevices() (value []GroupdevicesModel) {
	if r.RelationsGroups.Groupdevices == nil {
		panic("attempted to access groupdevices but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroups.Groupdevices
}

func (r GroupsModel) Orgs() (value *OrgsModel) {
	if r.RelationsGroups.Orgs == nil {
		panic("attempted to access orgs but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroups.Orgs
}

func (r GroupsModel) GrouptreeGrouptreeGroupidTogroups() (value []GrouptreeModel) {
	if r.RelationsGroups.GrouptreeGrouptreeGroupidTogroups == nil {
		panic("attempted to access grouptreeGrouptreeGroupidTogroups but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroups.GrouptreeGrouptreeGroupidTogroups
}

func (r GroupsModel) GrouptreeGrouptreePgroupidTogroups() (value []GrouptreeModel) {
	if r.RelationsGroups.GrouptreeGrouptreePgroupidTogroups == nil {
		panic("attempted to access grouptreeGrouptreePgroupidTogroups but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroups.GrouptreeGrouptreePgroupidTogroups
}

func (r GroupsModel) Groupuserperms() (value []GroupuserpermsModel) {
	if r.RelationsGroups.Groupuserperms == nil {
		panic("attempted to access groupuserperms but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroups.Groupuserperms
}

func (r GroupsModel) Orgrgroup() (value []OrgrgroupModel) {
	if r.RelationsGroups.Orgrgroup == nil {
		panic("attempted to access orgrgroup but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroups.Orgrgroup
}

func (r GroupsModel) Usergroup() (value []UsergroupModel) {
	if r.RelationsGroups.Usergroup == nil {
		panic("attempted to access usergroup but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroups.Usergroup
}

// GrouptreeModel represents the grouptree model and is a wrapper for accessing fields and methods
type GrouptreeModel struct {
	InnerGrouptree
	RelationsGrouptree
}

// InnerGrouptree holds the actual data
type InnerGrouptree struct {
	Orgid    string `json:"orgid"`
	Pgroupid string `json:"pgroupid"`
	Groupid  string `json:"groupid"`
	Name     string `json:"name"`
}

// RawGrouptreeModel is a struct for grouptree when used in raw queries
type RawGrouptreeModel struct {
	Orgid    RawString `json:"orgid"`
	Pgroupid RawString `json:"pgroupid"`
	Groupid  RawString `json:"groupid"`
	Name     RawString `json:"name"`
}

// RelationsGrouptree holds the relation data separately
type RelationsGrouptree struct {
	GroupsGrouptreeGroupidTogroups  *GroupsModel `json:"groups_grouptree_groupidTogroups,omitempty"`
	Orgs                            *OrgsModel   `json:"orgs,omitempty"`
	GroupsGrouptreePgroupidTogroups *GroupsModel `json:"groups_grouptree_pgroupidTogroups,omitempty"`
}

func (r GrouptreeModel) GroupsGrouptreeGroupidTogroups() (value *GroupsModel) {
	if r.RelationsGrouptree.GroupsGrouptreeGroupidTogroups == nil {
		panic("attempted to access groupsGrouptreeGroupidTogroups but did not fetch it using the .With() syntax")
	}
	return r.RelationsGrouptree.GroupsGrouptreeGroupidTogroups
}

func (r GrouptreeModel) Orgs() (value *OrgsModel) {
	if r.RelationsGrouptree.Orgs == nil {
		panic("attempted to access orgs but did not fetch it using the .With() syntax")
	}
	return r.RelationsGrouptree.Orgs
}

func (r GrouptreeModel) GroupsGrouptreePgroupidTogroups() (value *GroupsModel) {
	if r.RelationsGrouptree.GroupsGrouptreePgroupidTogroups == nil {
		panic("attempted to access groupsGrouptreePgroupidTogroups but did not fetch it using the .With() syntax")
	}
	return r.RelationsGrouptree.GroupsGrouptreePgroupidTogroups
}

// GroupuserpermsModel represents the groupuserperms model and is a wrapper for accessing fields and methods
type GroupuserpermsModel struct {
	InnerGroupuserperms
	RelationsGroupuserperms
}

// InnerGroupuserperms holds the actual data
type InnerGroupuserperms struct {
	Orgid   string `json:"orgid"`
	Groupid string `json:"groupid"`
	Userid  string `json:"userid"`
	Permid  string `json:"permid"`
}

// RawGroupuserpermsModel is a struct for groupuserperms when used in raw queries
type RawGroupuserpermsModel struct {
	Orgid   RawString `json:"orgid"`
	Groupid RawString `json:"groupid"`
	Userid  RawString `json:"userid"`
	Permid  RawString `json:"permid"`
}

// RelationsGroupuserperms holds the relation data separately
type RelationsGroupuserperms struct {
	Groups *GroupsModel `json:"groups,omitempty"`
	Orgs   *OrgsModel   `json:"orgs,omitempty"`
	Users  *UsersModel  `json:"users,omitempty"`
}

func (r GroupuserpermsModel) Groups() (value *GroupsModel) {
	if r.RelationsGroupuserperms.Groups == nil {
		panic("attempted to access groups but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroupuserperms.Groups
}

func (r GroupuserpermsModel) Orgs() (value *OrgsModel) {
	if r.RelationsGroupuserperms.Orgs == nil {
		panic("attempted to access orgs but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroupuserperms.Orgs
}

func (r GroupuserpermsModel) Users() (value *UsersModel) {
	if r.RelationsGroupuserperms.Users == nil {
		panic("attempted to access users but did not fetch it using the .With() syntax")
	}
	return r.RelationsGroupuserperms.Users
}

// OrgdevicesModel represents the orgdevices model and is a wrapper for accessing fields and methods
type OrgdevicesModel struct {
	InnerOrgdevices
	RelationsOrgdevices
}

// InnerOrgdevices holds the actual data
type InnerOrgdevices struct {
	Orgid         string `json:"orgid"`
	Deviceid      string `json:"deviceid"`
	Orgdevicemeta JSON   `json:"orgdevicemeta"`
	Updatedat     BigInt `json:"updatedat"`
	Updatedby     string `json:"updatedby"`
}

// RawOrgdevicesModel is a struct for orgdevices when used in raw queries
type RawOrgdevicesModel struct {
	Orgid         RawString `json:"orgid"`
	Deviceid      RawString `json:"deviceid"`
	Orgdevicemeta RawJSON   `json:"orgdevicemeta"`
	Updatedat     RawBigInt `json:"updatedat"`
	Updatedby     RawString `json:"updatedby"`
}

// RelationsOrgdevices holds the relation data separately
type RelationsOrgdevices struct {
	Devices *DevicesModel `json:"devices,omitempty"`
	Orgs    *OrgsModel    `json:"orgs,omitempty"`
}

func (r OrgdevicesModel) Devices() (value *DevicesModel) {
	if r.RelationsOrgdevices.Devices == nil {
		panic("attempted to access devices but did not fetch it using the .With() syntax")
	}
	return r.RelationsOrgdevices.Devices
}

func (r OrgdevicesModel) Orgs() (value *OrgsModel) {
	if r.RelationsOrgdevices.Orgs == nil {
		panic("attempted to access orgs but did not fetch it using the .With() syntax")
	}
	return r.RelationsOrgdevices.Orgs
}

// OrgrgroupModel represents the orgrgroup model and is a wrapper for accessing fields and methods
type OrgrgroupModel struct {
	InnerOrgrgroup
	RelationsOrgrgroup
}

// InnerOrgrgroup holds the actual data
type InnerOrgrgroup struct {
	Orgid       string `json:"orgid"`
	Rootgroupid string `json:"rootgroupid"`
}

// RawOrgrgroupModel is a struct for orgrgroup when used in raw queries
type RawOrgrgroupModel struct {
	Orgid       RawString `json:"orgid"`
	Rootgroupid RawString `json:"rootgroupid"`
}

// RelationsOrgrgroup holds the relation data separately
type RelationsOrgrgroup struct {
	Orgs   *OrgsModel   `json:"orgs,omitempty"`
	Groups *GroupsModel `json:"groups,omitempty"`
}

func (r OrgrgroupModel) Orgs() (value *OrgsModel) {
	if r.RelationsOrgrgroup.Orgs == nil {
		panic("attempted to access orgs but did not fetch it using the .With() syntax")
	}
	return r.RelationsOrgrgroup.Orgs
}

func (r OrgrgroupModel) Groups() (value *GroupsModel) {
	if r.RelationsOrgrgroup.Groups == nil {
		panic("attempted to access groups but did not fetch it using the .With() syntax")
	}
	return r.RelationsOrgrgroup.Groups
}

// OrgsModel represents the orgs model and is a wrapper for accessing fields and methods
type OrgsModel struct {
	InnerOrgs
	RelationsOrgs
}

// InnerOrgs holds the actual data
type InnerOrgs struct {
	Orgid     string `json:"orgid"`
	Orgname   string `json:"orgname"`
	Orgmeta   JSON   `json:"orgmeta"`
	Isenabled bool   `json:"isenabled"`
	Createdby string `json:"createdby"`
	Updatedby string `json:"updatedby"`
	Createdat BigInt `json:"createdat"`
	Updatedat BigInt `json:"updatedat"`
}

// RawOrgsModel is a struct for orgs when used in raw queries
type RawOrgsModel struct {
	Orgid     RawString  `json:"orgid"`
	Orgname   RawString  `json:"orgname"`
	Orgmeta   RawJSON    `json:"orgmeta"`
	Isenabled RawBoolean `json:"isenabled"`
	Createdby RawString  `json:"createdby"`
	Updatedby RawString  `json:"updatedby"`
	Createdat RawBigInt  `json:"createdat"`
	Updatedat RawBigInt  `json:"updatedat"`
}

// RelationsOrgs holds the relation data separately
type RelationsOrgs struct {
	Groupdevices   []GroupdevicesModel   `json:"groupdevices,omitempty"`
	Groups         []GroupsModel         `json:"groups,omitempty"`
	Grouptree      []GrouptreeModel      `json:"grouptree,omitempty"`
	Groupuserperms []GroupuserpermsModel `json:"groupuserperms,omitempty"`
	Orgdevices     []OrgdevicesModel     `json:"orgdevices,omitempty"`
	Orgrgroup      *OrgrgroupModel       `json:"orgrgroup,omitempty"`
	Usergroup      []UsergroupModel      `json:"usergroup,omitempty"`
}

func (r OrgsModel) Groupdevices() (value []GroupdevicesModel) {
	if r.RelationsOrgs.Groupdevices == nil {
		panic("attempted to access groupdevices but did not fetch it using the .With() syntax")
	}
	return r.RelationsOrgs.Groupdevices
}

func (r OrgsModel) Groups() (value []GroupsModel) {
	if r.RelationsOrgs.Groups == nil {
		panic("attempted to access groups but did not fetch it using the .With() syntax")
	}
	return r.RelationsOrgs.Groups
}

func (r OrgsModel) Grouptree() (value []GrouptreeModel) {
	if r.RelationsOrgs.Grouptree == nil {
		panic("attempted to access grouptree but did not fetch it using the .With() syntax")
	}
	return r.RelationsOrgs.Grouptree
}

func (r OrgsModel) Groupuserperms() (value []GroupuserpermsModel) {
	if r.RelationsOrgs.Groupuserperms == nil {
		panic("attempted to access groupuserperms but did not fetch it using the .With() syntax")
	}
	return r.RelationsOrgs.Groupuserperms
}

func (r OrgsModel) Orgdevices() (value []OrgdevicesModel) {
	if r.RelationsOrgs.Orgdevices == nil {
		panic("attempted to access orgdevices but did not fetch it using the .With() syntax")
	}
	return r.RelationsOrgs.Orgdevices
}

func (r OrgsModel) Orgrgroup() (value *OrgrgroupModel, ok bool) {
	if r.RelationsOrgs.Orgrgroup == nil {
		return value, false
	}
	return r.RelationsOrgs.Orgrgroup, true
}

func (r OrgsModel) Usergroup() (value []UsergroupModel) {
	if r.RelationsOrgs.Usergroup == nil {
		panic("attempted to access usergroup but did not fetch it using the .With() syntax")
	}
	return r.RelationsOrgs.Usergroup
}

// UsergroupModel represents the usergroup model and is a wrapper for accessing fields and methods
type UsergroupModel struct {
	InnerUsergroup
	RelationsUsergroup
}

// InnerUsergroup holds the actual data
type InnerUsergroup struct {
	Userid  string `json:"userid"`
	Orgid   string `json:"orgid"`
	Groupid string `json:"groupid"`
}

// RawUsergroupModel is a struct for usergroup when used in raw queries
type RawUsergroupModel struct {
	Userid  RawString `json:"userid"`
	Orgid   RawString `json:"orgid"`
	Groupid RawString `json:"groupid"`
}

// RelationsUsergroup holds the relation data separately
type RelationsUsergroup struct {
	Groups *GroupsModel `json:"groups,omitempty"`
	Orgs   *OrgsModel   `json:"orgs,omitempty"`
	Users  *UsersModel  `json:"users,omitempty"`
}

func (r UsergroupModel) Groups() (value *GroupsModel) {
	if r.RelationsUsergroup.Groups == nil {
		panic("attempted to access groups but did not fetch it using the .With() syntax")
	}
	return r.RelationsUsergroup.Groups
}

func (r UsergroupModel) Orgs() (value *OrgsModel) {
	if r.RelationsUsergroup.Orgs == nil {
		panic("attempted to access orgs but did not fetch it using the .With() syntax")
	}
	return r.RelationsUsergroup.Orgs
}

func (r UsergroupModel) Users() (value *UsersModel) {
	if r.RelationsUsergroup.Users == nil {
		panic("attempted to access users but did not fetch it using the .With() syntax")
	}
	return r.RelationsUsergroup.Users
}

// UsersModel represents the users model and is a wrapper for accessing fields and methods
type UsersModel struct {
	InnerUsers
	RelationsUsers
}

// InnerUsers holds the actual data
type InnerUsers struct {
	Userid          string `json:"userid"`
	Name            string `json:"name"`
	Email           string `json:"email"`
	Isemailverified bool   `json:"isemailverified"`
	Usermeta        *JSON  `json:"usermeta,omitempty"`
	Isenabled       bool   `json:"isenabled"`
	Secretprv       string `json:"secretprv"`
	Secretpub       string `json:"secretpub"`
	Createdat       BigInt `json:"createdat"`
	Updatedat       BigInt `json:"updatedat"`
}

// RawUsersModel is a struct for users when used in raw queries
type RawUsersModel struct {
	Userid          RawString  `json:"userid"`
	Name            RawString  `json:"name"`
	Email           RawString  `json:"email"`
	Isemailverified RawBoolean `json:"isemailverified"`
	Usermeta        *RawJSON   `json:"usermeta,omitempty"`
	Isenabled       RawBoolean `json:"isenabled"`
	Secretprv       RawString  `json:"secretprv"`
	Secretpub       RawString  `json:"secretpub"`
	Createdat       RawBigInt  `json:"createdat"`
	Updatedat       RawBigInt  `json:"updatedat"`
}

// RelationsUsers holds the relation data separately
type RelationsUsers struct {
	Groupuserperms []GroupuserpermsModel `json:"groupuserperms,omitempty"`
	Usergroup      []UsergroupModel      `json:"usergroup,omitempty"`
}

func (r UsersModel) Usermeta() (value JSON, ok bool) {
	if r.InnerUsers.Usermeta == nil {
		return value, false
	}
	return *r.InnerUsers.Usermeta, true
}

func (r UsersModel) Groupuserperms() (value []GroupuserpermsModel) {
	if r.RelationsUsers.Groupuserperms == nil {
		panic("attempted to access groupuserperms but did not fetch it using the .With() syntax")
	}
	return r.RelationsUsers.Groupuserperms
}

func (r UsersModel) Usergroup() (value []UsergroupModel) {
	if r.RelationsUsers.Usergroup == nil {
		panic("attempted to access usergroup but did not fetch it using the .With() syntax")
	}
	return r.RelationsUsers.Usergroup
}

// --- template query.gotpl ---

// Activitylog acts as a namespaces to access query methods for the Activitylog model
var Activitylog = activitylogQuery{}

// activitylogQuery exposes query functions for the activitylog model
type activitylogQuery struct {

	// Auditid
	//
	// @required
	Auditid activitylogQueryAuditidBigInt

	// Msgtype
	//
	// @required
	Msgtype activitylogQueryMsgtypeString

	// Msgpayload
	//
	// @required
	Msgpayload activitylogQueryMsgpayloadJson

	// Updatedat
	//
	// @required
	Updatedat activitylogQueryUpdatedatBigInt
}

func (activitylogQuery) Not(params ...ActivitylogWhereParam) activitylogDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return activitylogDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (activitylogQuery) Or(params ...ActivitylogWhereParam) activitylogDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return activitylogDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (activitylogQuery) And(params ...ActivitylogWhereParam) activitylogDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return activitylogDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type activitylogQueryAuditidBigInt struct{}

// Set the required value of Auditid
func (r activitylogQueryAuditidBigInt) Set(value BigInt) activitylogSetParam {

	return activitylogSetParam{
		data: builder.Field{
			Name:  "auditid",
			Value: value,
		},
	}

}

// Set the optional value of Auditid dynamically
func (r activitylogQueryAuditidBigInt) SetIfPresent(value *BigInt) activitylogSetParam {
	if value == nil {
		return activitylogSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Auditid
func (r activitylogQueryAuditidBigInt) Increment(value BigInt) activitylogSetParam {
	return activitylogSetParam{
		data: builder.Field{
			Name: "auditid",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryAuditidBigInt) IncrementIfPresent(value *BigInt) activitylogSetParam {
	if value == nil {
		return activitylogSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Auditid
func (r activitylogQueryAuditidBigInt) Decrement(value BigInt) activitylogSetParam {
	return activitylogSetParam{
		data: builder.Field{
			Name: "auditid",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryAuditidBigInt) DecrementIfPresent(value *BigInt) activitylogSetParam {
	if value == nil {
		return activitylogSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Auditid
func (r activitylogQueryAuditidBigInt) Multiply(value BigInt) activitylogSetParam {
	return activitylogSetParam{
		data: builder.Field{
			Name: "auditid",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryAuditidBigInt) MultiplyIfPresent(value *BigInt) activitylogSetParam {
	if value == nil {
		return activitylogSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Auditid
func (r activitylogQueryAuditidBigInt) Divide(value BigInt) activitylogSetParam {
	return activitylogSetParam{
		data: builder.Field{
			Name: "auditid",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryAuditidBigInt) DivideIfPresent(value *BigInt) activitylogSetParam {
	if value == nil {
		return activitylogSetParam{}
	}
	return r.Divide(*value)
}

func (r activitylogQueryAuditidBigInt) Equals(value BigInt) activitylogWithPrismaAuditidEqualsUniqueParam {

	return activitylogWithPrismaAuditidEqualsUniqueParam{
		data: builder.Field{
			Name: "auditid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryAuditidBigInt) EqualsIfPresent(value *BigInt) activitylogWithPrismaAuditidEqualsUniqueParam {
	if value == nil {
		return activitylogWithPrismaAuditidEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r activitylogQueryAuditidBigInt) Order(direction SortOrder) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name:  "auditid",
			Value: direction,
		},
	}
}

func (r activitylogQueryAuditidBigInt) Cursor(cursor BigInt) activitylogCursorParam {
	return activitylogCursorParam{
		data: builder.Field{
			Name:  "auditid",
			Value: cursor,
		},
	}
}

func (r activitylogQueryAuditidBigInt) In(value []BigInt) activitylogParamUnique {
	return activitylogParamUnique{
		data: builder.Field{
			Name: "auditid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryAuditidBigInt) InIfPresent(value []BigInt) activitylogParamUnique {
	if value == nil {
		return activitylogParamUnique{}
	}
	return r.In(value)
}

func (r activitylogQueryAuditidBigInt) NotIn(value []BigInt) activitylogParamUnique {
	return activitylogParamUnique{
		data: builder.Field{
			Name: "auditid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryAuditidBigInt) NotInIfPresent(value []BigInt) activitylogParamUnique {
	if value == nil {
		return activitylogParamUnique{}
	}
	return r.NotIn(value)
}

func (r activitylogQueryAuditidBigInt) Lt(value BigInt) activitylogParamUnique {
	return activitylogParamUnique{
		data: builder.Field{
			Name: "auditid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryAuditidBigInt) LtIfPresent(value *BigInt) activitylogParamUnique {
	if value == nil {
		return activitylogParamUnique{}
	}
	return r.Lt(*value)
}

func (r activitylogQueryAuditidBigInt) Lte(value BigInt) activitylogParamUnique {
	return activitylogParamUnique{
		data: builder.Field{
			Name: "auditid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryAuditidBigInt) LteIfPresent(value *BigInt) activitylogParamUnique {
	if value == nil {
		return activitylogParamUnique{}
	}
	return r.Lte(*value)
}

func (r activitylogQueryAuditidBigInt) Gt(value BigInt) activitylogParamUnique {
	return activitylogParamUnique{
		data: builder.Field{
			Name: "auditid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryAuditidBigInt) GtIfPresent(value *BigInt) activitylogParamUnique {
	if value == nil {
		return activitylogParamUnique{}
	}
	return r.Gt(*value)
}

func (r activitylogQueryAuditidBigInt) Gte(value BigInt) activitylogParamUnique {
	return activitylogParamUnique{
		data: builder.Field{
			Name: "auditid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryAuditidBigInt) GteIfPresent(value *BigInt) activitylogParamUnique {
	if value == nil {
		return activitylogParamUnique{}
	}
	return r.Gte(*value)
}

func (r activitylogQueryAuditidBigInt) Not(value BigInt) activitylogParamUnique {
	return activitylogParamUnique{
		data: builder.Field{
			Name: "auditid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryAuditidBigInt) NotIfPresent(value *BigInt) activitylogParamUnique {
	if value == nil {
		return activitylogParamUnique{}
	}
	return r.Not(*value)
}

func (r activitylogQueryAuditidBigInt) Field() activitylogPrismaFields {
	return activitylogFieldAuditid
}

// base struct
type activitylogQueryMsgtypeString struct{}

// Set the required value of Msgtype
func (r activitylogQueryMsgtypeString) Set(value string) activitylogWithPrismaMsgtypeSetParam {

	return activitylogWithPrismaMsgtypeSetParam{
		data: builder.Field{
			Name:  "msgtype",
			Value: value,
		},
	}

}

// Set the optional value of Msgtype dynamically
func (r activitylogQueryMsgtypeString) SetIfPresent(value *String) activitylogWithPrismaMsgtypeSetParam {
	if value == nil {
		return activitylogWithPrismaMsgtypeSetParam{}
	}

	return r.Set(*value)
}

func (r activitylogQueryMsgtypeString) Equals(value string) activitylogWithPrismaMsgtypeEqualsParam {

	return activitylogWithPrismaMsgtypeEqualsParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgtypeString) EqualsIfPresent(value *string) activitylogWithPrismaMsgtypeEqualsParam {
	if value == nil {
		return activitylogWithPrismaMsgtypeEqualsParam{}
	}
	return r.Equals(*value)
}

func (r activitylogQueryMsgtypeString) Order(direction SortOrder) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name:  "msgtype",
			Value: direction,
		},
	}
}

func (r activitylogQueryMsgtypeString) Cursor(cursor string) activitylogCursorParam {
	return activitylogCursorParam{
		data: builder.Field{
			Name:  "msgtype",
			Value: cursor,
		},
	}
}

func (r activitylogQueryMsgtypeString) In(value []string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgtypeString) InIfPresent(value []string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.In(value)
}

func (r activitylogQueryMsgtypeString) NotIn(value []string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgtypeString) NotInIfPresent(value []string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.NotIn(value)
}

func (r activitylogQueryMsgtypeString) Lt(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgtypeString) LtIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Lt(*value)
}

func (r activitylogQueryMsgtypeString) Lte(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgtypeString) LteIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Lte(*value)
}

func (r activitylogQueryMsgtypeString) Gt(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgtypeString) GtIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Gt(*value)
}

func (r activitylogQueryMsgtypeString) Gte(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgtypeString) GteIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Gte(*value)
}

func (r activitylogQueryMsgtypeString) Contains(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgtypeString) ContainsIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Contains(*value)
}

func (r activitylogQueryMsgtypeString) StartsWith(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgtypeString) StartsWithIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r activitylogQueryMsgtypeString) EndsWith(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgtypeString) EndsWithIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r activitylogQueryMsgtypeString) Mode(value QueryMode) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgtypeString) ModeIfPresent(value *QueryMode) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Mode(*value)
}

func (r activitylogQueryMsgtypeString) Not(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgtypeString) NotIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r activitylogQueryMsgtypeString) HasPrefix(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r activitylogQueryMsgtypeString) HasPrefixIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r activitylogQueryMsgtypeString) HasSuffix(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgtype",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r activitylogQueryMsgtypeString) HasSuffixIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r activitylogQueryMsgtypeString) Field() activitylogPrismaFields {
	return activitylogFieldMsgtype
}

// base struct
type activitylogQueryMsgpayloadJson struct{}

// Set the required value of Msgpayload
func (r activitylogQueryMsgpayloadJson) Set(value JSON) activitylogWithPrismaMsgpayloadSetParam {

	return activitylogWithPrismaMsgpayloadSetParam{
		data: builder.Field{
			Name:  "msgpayload",
			Value: value,
		},
	}

}

// Set the optional value of Msgpayload dynamically
func (r activitylogQueryMsgpayloadJson) SetIfPresent(value *JSON) activitylogWithPrismaMsgpayloadSetParam {
	if value == nil {
		return activitylogWithPrismaMsgpayloadSetParam{}
	}

	return r.Set(*value)
}

func (r activitylogQueryMsgpayloadJson) Equals(value JSON) activitylogWithPrismaMsgpayloadEqualsParam {

	return activitylogWithPrismaMsgpayloadEqualsParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) EqualsIfPresent(value *JSON) activitylogWithPrismaMsgpayloadEqualsParam {
	if value == nil {
		return activitylogWithPrismaMsgpayloadEqualsParam{}
	}
	return r.Equals(*value)
}

func (r activitylogQueryMsgpayloadJson) Order(direction SortOrder) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name:  "msgpayload",
			Value: direction,
		},
	}
}

func (r activitylogQueryMsgpayloadJson) Cursor(cursor JSON) activitylogCursorParam {
	return activitylogCursorParam{
		data: builder.Field{
			Name:  "msgpayload",
			Value: cursor,
		},
	}
}

func (r activitylogQueryMsgpayloadJson) Path(value []string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "path",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) PathIfPresent(value []string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Path(value)
}

func (r activitylogQueryMsgpayloadJson) StringContains(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "string_contains",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) StringContainsIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.StringContains(*value)
}

func (r activitylogQueryMsgpayloadJson) StringStartsWith(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "string_starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) StringStartsWithIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.StringStartsWith(*value)
}

func (r activitylogQueryMsgpayloadJson) StringEndsWith(value string) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "string_ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) StringEndsWithIfPresent(value *string) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.StringEndsWith(*value)
}

func (r activitylogQueryMsgpayloadJson) ArrayStartsWith(value JSON) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "array_starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) ArrayStartsWithIfPresent(value *JSON) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.ArrayStartsWith(*value)
}

func (r activitylogQueryMsgpayloadJson) ArrayEndsWith(value JSON) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "array_ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) ArrayEndsWithIfPresent(value *JSON) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.ArrayEndsWith(*value)
}

func (r activitylogQueryMsgpayloadJson) ArrayContains(value JSON) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "array_contains",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) ArrayContainsIfPresent(value *JSON) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.ArrayContains(*value)
}

func (r activitylogQueryMsgpayloadJson) Lt(value JSON) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) LtIfPresent(value *JSON) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Lt(*value)
}

func (r activitylogQueryMsgpayloadJson) Lte(value JSON) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) LteIfPresent(value *JSON) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Lte(*value)
}

func (r activitylogQueryMsgpayloadJson) Gt(value JSON) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) GtIfPresent(value *JSON) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Gt(*value)
}

func (r activitylogQueryMsgpayloadJson) Gte(value JSON) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) GteIfPresent(value *JSON) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Gte(*value)
}

func (r activitylogQueryMsgpayloadJson) Not(value JSONNullValueFilter) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "msgpayload",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryMsgpayloadJson) NotIfPresent(value *JSONNullValueFilter) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Not(*value)
}

func (r activitylogQueryMsgpayloadJson) Field() activitylogPrismaFields {
	return activitylogFieldMsgpayload
}

// base struct
type activitylogQueryUpdatedatBigInt struct{}

// Set the required value of Updatedat
func (r activitylogQueryUpdatedatBigInt) Set(value BigInt) activitylogSetParam {

	return activitylogSetParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: value,
		},
	}

}

// Set the optional value of Updatedat dynamically
func (r activitylogQueryUpdatedatBigInt) SetIfPresent(value *BigInt) activitylogSetParam {
	if value == nil {
		return activitylogSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Updatedat
func (r activitylogQueryUpdatedatBigInt) Increment(value BigInt) activitylogSetParam {
	return activitylogSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) IncrementIfPresent(value *BigInt) activitylogSetParam {
	if value == nil {
		return activitylogSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Updatedat
func (r activitylogQueryUpdatedatBigInt) Decrement(value BigInt) activitylogSetParam {
	return activitylogSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) DecrementIfPresent(value *BigInt) activitylogSetParam {
	if value == nil {
		return activitylogSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Updatedat
func (r activitylogQueryUpdatedatBigInt) Multiply(value BigInt) activitylogSetParam {
	return activitylogSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) MultiplyIfPresent(value *BigInt) activitylogSetParam {
	if value == nil {
		return activitylogSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Updatedat
func (r activitylogQueryUpdatedatBigInt) Divide(value BigInt) activitylogSetParam {
	return activitylogSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) DivideIfPresent(value *BigInt) activitylogSetParam {
	if value == nil {
		return activitylogSetParam{}
	}
	return r.Divide(*value)
}

func (r activitylogQueryUpdatedatBigInt) Equals(value BigInt) activitylogWithPrismaUpdatedatEqualsParam {

	return activitylogWithPrismaUpdatedatEqualsParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) EqualsIfPresent(value *BigInt) activitylogWithPrismaUpdatedatEqualsParam {
	if value == nil {
		return activitylogWithPrismaUpdatedatEqualsParam{}
	}
	return r.Equals(*value)
}

func (r activitylogQueryUpdatedatBigInt) Order(direction SortOrder) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: direction,
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) Cursor(cursor BigInt) activitylogCursorParam {
	return activitylogCursorParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: cursor,
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) In(value []BigInt) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) InIfPresent(value []BigInt) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.In(value)
}

func (r activitylogQueryUpdatedatBigInt) NotIn(value []BigInt) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) NotInIfPresent(value []BigInt) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.NotIn(value)
}

func (r activitylogQueryUpdatedatBigInt) Lt(value BigInt) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) LtIfPresent(value *BigInt) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Lt(*value)
}

func (r activitylogQueryUpdatedatBigInt) Lte(value BigInt) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) LteIfPresent(value *BigInt) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Lte(*value)
}

func (r activitylogQueryUpdatedatBigInt) Gt(value BigInt) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) GtIfPresent(value *BigInt) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Gt(*value)
}

func (r activitylogQueryUpdatedatBigInt) Gte(value BigInt) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) GteIfPresent(value *BigInt) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Gte(*value)
}

func (r activitylogQueryUpdatedatBigInt) Not(value BigInt) activitylogDefaultParam {
	return activitylogDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r activitylogQueryUpdatedatBigInt) NotIfPresent(value *BigInt) activitylogDefaultParam {
	if value == nil {
		return activitylogDefaultParam{}
	}
	return r.Not(*value)
}

func (r activitylogQueryUpdatedatBigInt) Field() activitylogPrismaFields {
	return activitylogFieldUpdatedat
}

// Devices acts as a namespaces to access query methods for the Devices model
var Devices = devicesQuery{}

// devicesQuery exposes query functions for the devices model
type devicesQuery struct {

	// Deviceid
	//
	// @required
	Deviceid devicesQueryDeviceidString

	// Devicemeta
	//
	// @required
	Devicemeta devicesQueryDevicemetaJson

	// Createdat
	//
	// @required
	Createdat devicesQueryCreatedatBigInt

	// Createdby
	//
	// @required
	Createdby devicesQueryCreatedbyString

	// Updatedat
	//
	// @required
	Updatedat devicesQueryUpdatedatBigInt

	// Updatedby
	//
	// @required
	Updatedby devicesQueryUpdatedbyString

	Groupdevices devicesQueryGroupdevicesRelations

	Orgdevices devicesQueryOrgdevicesRelations
}

func (devicesQuery) Not(params ...DevicesWhereParam) devicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (devicesQuery) Or(params ...DevicesWhereParam) devicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (devicesQuery) And(params ...DevicesWhereParam) devicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type devicesQueryDeviceidString struct{}

// Set the required value of Deviceid
func (r devicesQueryDeviceidString) Set(value string) devicesWithPrismaDeviceidSetParam {

	return devicesWithPrismaDeviceidSetParam{
		data: builder.Field{
			Name:  "deviceid",
			Value: value,
		},
	}

}

// Set the optional value of Deviceid dynamically
func (r devicesQueryDeviceidString) SetIfPresent(value *String) devicesWithPrismaDeviceidSetParam {
	if value == nil {
		return devicesWithPrismaDeviceidSetParam{}
	}

	return r.Set(*value)
}

func (r devicesQueryDeviceidString) Equals(value string) devicesWithPrismaDeviceidEqualsUniqueParam {

	return devicesWithPrismaDeviceidEqualsUniqueParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDeviceidString) EqualsIfPresent(value *string) devicesWithPrismaDeviceidEqualsUniqueParam {
	if value == nil {
		return devicesWithPrismaDeviceidEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r devicesQueryDeviceidString) Order(direction SortOrder) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name:  "deviceid",
			Value: direction,
		},
	}
}

func (r devicesQueryDeviceidString) Cursor(cursor string) devicesCursorParam {
	return devicesCursorParam{
		data: builder.Field{
			Name:  "deviceid",
			Value: cursor,
		},
	}
}

func (r devicesQueryDeviceidString) In(value []string) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDeviceidString) InIfPresent(value []string) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.In(value)
}

func (r devicesQueryDeviceidString) NotIn(value []string) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDeviceidString) NotInIfPresent(value []string) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.NotIn(value)
}

func (r devicesQueryDeviceidString) Lt(value string) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDeviceidString) LtIfPresent(value *string) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.Lt(*value)
}

func (r devicesQueryDeviceidString) Lte(value string) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDeviceidString) LteIfPresent(value *string) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.Lte(*value)
}

func (r devicesQueryDeviceidString) Gt(value string) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDeviceidString) GtIfPresent(value *string) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.Gt(*value)
}

func (r devicesQueryDeviceidString) Gte(value string) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDeviceidString) GteIfPresent(value *string) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.Gte(*value)
}

func (r devicesQueryDeviceidString) Contains(value string) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDeviceidString) ContainsIfPresent(value *string) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.Contains(*value)
}

func (r devicesQueryDeviceidString) StartsWith(value string) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDeviceidString) StartsWithIfPresent(value *string) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r devicesQueryDeviceidString) EndsWith(value string) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDeviceidString) EndsWithIfPresent(value *string) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r devicesQueryDeviceidString) Mode(value QueryMode) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDeviceidString) ModeIfPresent(value *QueryMode) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.Mode(*value)
}

func (r devicesQueryDeviceidString) Not(value string) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDeviceidString) NotIfPresent(value *string) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r devicesQueryDeviceidString) HasPrefix(value string) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r devicesQueryDeviceidString) HasPrefixIfPresent(value *string) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r devicesQueryDeviceidString) HasSuffix(value string) devicesParamUnique {
	return devicesParamUnique{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r devicesQueryDeviceidString) HasSuffixIfPresent(value *string) devicesParamUnique {
	if value == nil {
		return devicesParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r devicesQueryDeviceidString) Field() devicesPrismaFields {
	return devicesFieldDeviceid
}

// base struct
type devicesQueryDevicemetaJson struct{}

// Set the required value of Devicemeta
func (r devicesQueryDevicemetaJson) Set(value JSON) devicesWithPrismaDevicemetaSetParam {

	return devicesWithPrismaDevicemetaSetParam{
		data: builder.Field{
			Name:  "devicemeta",
			Value: value,
		},
	}

}

// Set the optional value of Devicemeta dynamically
func (r devicesQueryDevicemetaJson) SetIfPresent(value *JSON) devicesWithPrismaDevicemetaSetParam {
	if value == nil {
		return devicesWithPrismaDevicemetaSetParam{}
	}

	return r.Set(*value)
}

func (r devicesQueryDevicemetaJson) Equals(value JSON) devicesWithPrismaDevicemetaEqualsParam {

	return devicesWithPrismaDevicemetaEqualsParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) EqualsIfPresent(value *JSON) devicesWithPrismaDevicemetaEqualsParam {
	if value == nil {
		return devicesWithPrismaDevicemetaEqualsParam{}
	}
	return r.Equals(*value)
}

func (r devicesQueryDevicemetaJson) Order(direction SortOrder) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name:  "devicemeta",
			Value: direction,
		},
	}
}

func (r devicesQueryDevicemetaJson) Cursor(cursor JSON) devicesCursorParam {
	return devicesCursorParam{
		data: builder.Field{
			Name:  "devicemeta",
			Value: cursor,
		},
	}
}

func (r devicesQueryDevicemetaJson) Path(value []string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "path",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) PathIfPresent(value []string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Path(value)
}

func (r devicesQueryDevicemetaJson) StringContains(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "string_contains",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) StringContainsIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.StringContains(*value)
}

func (r devicesQueryDevicemetaJson) StringStartsWith(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "string_starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) StringStartsWithIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.StringStartsWith(*value)
}

func (r devicesQueryDevicemetaJson) StringEndsWith(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "string_ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) StringEndsWithIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.StringEndsWith(*value)
}

func (r devicesQueryDevicemetaJson) ArrayStartsWith(value JSON) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "array_starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) ArrayStartsWithIfPresent(value *JSON) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.ArrayStartsWith(*value)
}

func (r devicesQueryDevicemetaJson) ArrayEndsWith(value JSON) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "array_ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) ArrayEndsWithIfPresent(value *JSON) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.ArrayEndsWith(*value)
}

func (r devicesQueryDevicemetaJson) ArrayContains(value JSON) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "array_contains",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) ArrayContainsIfPresent(value *JSON) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.ArrayContains(*value)
}

func (r devicesQueryDevicemetaJson) Lt(value JSON) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) LtIfPresent(value *JSON) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r devicesQueryDevicemetaJson) Lte(value JSON) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) LteIfPresent(value *JSON) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r devicesQueryDevicemetaJson) Gt(value JSON) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) GtIfPresent(value *JSON) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r devicesQueryDevicemetaJson) Gte(value JSON) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) GteIfPresent(value *JSON) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r devicesQueryDevicemetaJson) Not(value JSONNullValueFilter) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "devicemeta",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryDevicemetaJson) NotIfPresent(value *JSONNullValueFilter) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Not(*value)
}

func (r devicesQueryDevicemetaJson) Field() devicesPrismaFields {
	return devicesFieldDevicemeta
}

// base struct
type devicesQueryCreatedatBigInt struct{}

// Set the required value of Createdat
func (r devicesQueryCreatedatBigInt) Set(value BigInt) devicesSetParam {

	return devicesSetParam{
		data: builder.Field{
			Name:  "createdat",
			Value: value,
		},
	}

}

// Set the optional value of Createdat dynamically
func (r devicesQueryCreatedatBigInt) SetIfPresent(value *BigInt) devicesSetParam {
	if value == nil {
		return devicesSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Createdat
func (r devicesQueryCreatedatBigInt) Increment(value BigInt) devicesSetParam {
	return devicesSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedatBigInt) IncrementIfPresent(value *BigInt) devicesSetParam {
	if value == nil {
		return devicesSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Createdat
func (r devicesQueryCreatedatBigInt) Decrement(value BigInt) devicesSetParam {
	return devicesSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedatBigInt) DecrementIfPresent(value *BigInt) devicesSetParam {
	if value == nil {
		return devicesSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Createdat
func (r devicesQueryCreatedatBigInt) Multiply(value BigInt) devicesSetParam {
	return devicesSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedatBigInt) MultiplyIfPresent(value *BigInt) devicesSetParam {
	if value == nil {
		return devicesSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Createdat
func (r devicesQueryCreatedatBigInt) Divide(value BigInt) devicesSetParam {
	return devicesSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedatBigInt) DivideIfPresent(value *BigInt) devicesSetParam {
	if value == nil {
		return devicesSetParam{}
	}
	return r.Divide(*value)
}

func (r devicesQueryCreatedatBigInt) Equals(value BigInt) devicesWithPrismaCreatedatEqualsParam {

	return devicesWithPrismaCreatedatEqualsParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedatBigInt) EqualsIfPresent(value *BigInt) devicesWithPrismaCreatedatEqualsParam {
	if value == nil {
		return devicesWithPrismaCreatedatEqualsParam{}
	}
	return r.Equals(*value)
}

func (r devicesQueryCreatedatBigInt) Order(direction SortOrder) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name:  "createdat",
			Value: direction,
		},
	}
}

func (r devicesQueryCreatedatBigInt) Cursor(cursor BigInt) devicesCursorParam {
	return devicesCursorParam{
		data: builder.Field{
			Name:  "createdat",
			Value: cursor,
		},
	}
}

func (r devicesQueryCreatedatBigInt) In(value []BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedatBigInt) InIfPresent(value []BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.In(value)
}

func (r devicesQueryCreatedatBigInt) NotIn(value []BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedatBigInt) NotInIfPresent(value []BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r devicesQueryCreatedatBigInt) Lt(value BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedatBigInt) LtIfPresent(value *BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r devicesQueryCreatedatBigInt) Lte(value BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedatBigInt) LteIfPresent(value *BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r devicesQueryCreatedatBigInt) Gt(value BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedatBigInt) GtIfPresent(value *BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r devicesQueryCreatedatBigInt) Gte(value BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedatBigInt) GteIfPresent(value *BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r devicesQueryCreatedatBigInt) Not(value BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedatBigInt) NotIfPresent(value *BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Not(*value)
}

func (r devicesQueryCreatedatBigInt) Field() devicesPrismaFields {
	return devicesFieldCreatedat
}

// base struct
type devicesQueryCreatedbyString struct{}

// Set the required value of Createdby
func (r devicesQueryCreatedbyString) Set(value string) devicesWithPrismaCreatedbySetParam {

	return devicesWithPrismaCreatedbySetParam{
		data: builder.Field{
			Name:  "createdby",
			Value: value,
		},
	}

}

// Set the optional value of Createdby dynamically
func (r devicesQueryCreatedbyString) SetIfPresent(value *String) devicesWithPrismaCreatedbySetParam {
	if value == nil {
		return devicesWithPrismaCreatedbySetParam{}
	}

	return r.Set(*value)
}

func (r devicesQueryCreatedbyString) Equals(value string) devicesWithPrismaCreatedbyEqualsParam {

	return devicesWithPrismaCreatedbyEqualsParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedbyString) EqualsIfPresent(value *string) devicesWithPrismaCreatedbyEqualsParam {
	if value == nil {
		return devicesWithPrismaCreatedbyEqualsParam{}
	}
	return r.Equals(*value)
}

func (r devicesQueryCreatedbyString) Order(direction SortOrder) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name:  "createdby",
			Value: direction,
		},
	}
}

func (r devicesQueryCreatedbyString) Cursor(cursor string) devicesCursorParam {
	return devicesCursorParam{
		data: builder.Field{
			Name:  "createdby",
			Value: cursor,
		},
	}
}

func (r devicesQueryCreatedbyString) In(value []string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedbyString) InIfPresent(value []string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.In(value)
}

func (r devicesQueryCreatedbyString) NotIn(value []string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedbyString) NotInIfPresent(value []string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r devicesQueryCreatedbyString) Lt(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedbyString) LtIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r devicesQueryCreatedbyString) Lte(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedbyString) LteIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r devicesQueryCreatedbyString) Gt(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedbyString) GtIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r devicesQueryCreatedbyString) Gte(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedbyString) GteIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r devicesQueryCreatedbyString) Contains(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedbyString) ContainsIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r devicesQueryCreatedbyString) StartsWith(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedbyString) StartsWithIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r devicesQueryCreatedbyString) EndsWith(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedbyString) EndsWithIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r devicesQueryCreatedbyString) Mode(value QueryMode) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedbyString) ModeIfPresent(value *QueryMode) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r devicesQueryCreatedbyString) Not(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryCreatedbyString) NotIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r devicesQueryCreatedbyString) HasPrefix(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r devicesQueryCreatedbyString) HasPrefixIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r devicesQueryCreatedbyString) HasSuffix(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r devicesQueryCreatedbyString) HasSuffixIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r devicesQueryCreatedbyString) Field() devicesPrismaFields {
	return devicesFieldCreatedby
}

// base struct
type devicesQueryUpdatedatBigInt struct{}

// Set the required value of Updatedat
func (r devicesQueryUpdatedatBigInt) Set(value BigInt) devicesSetParam {

	return devicesSetParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: value,
		},
	}

}

// Set the optional value of Updatedat dynamically
func (r devicesQueryUpdatedatBigInt) SetIfPresent(value *BigInt) devicesSetParam {
	if value == nil {
		return devicesSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Updatedat
func (r devicesQueryUpdatedatBigInt) Increment(value BigInt) devicesSetParam {
	return devicesSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedatBigInt) IncrementIfPresent(value *BigInt) devicesSetParam {
	if value == nil {
		return devicesSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Updatedat
func (r devicesQueryUpdatedatBigInt) Decrement(value BigInt) devicesSetParam {
	return devicesSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedatBigInt) DecrementIfPresent(value *BigInt) devicesSetParam {
	if value == nil {
		return devicesSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Updatedat
func (r devicesQueryUpdatedatBigInt) Multiply(value BigInt) devicesSetParam {
	return devicesSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedatBigInt) MultiplyIfPresent(value *BigInt) devicesSetParam {
	if value == nil {
		return devicesSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Updatedat
func (r devicesQueryUpdatedatBigInt) Divide(value BigInt) devicesSetParam {
	return devicesSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedatBigInt) DivideIfPresent(value *BigInt) devicesSetParam {
	if value == nil {
		return devicesSetParam{}
	}
	return r.Divide(*value)
}

func (r devicesQueryUpdatedatBigInt) Equals(value BigInt) devicesWithPrismaUpdatedatEqualsParam {

	return devicesWithPrismaUpdatedatEqualsParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedatBigInt) EqualsIfPresent(value *BigInt) devicesWithPrismaUpdatedatEqualsParam {
	if value == nil {
		return devicesWithPrismaUpdatedatEqualsParam{}
	}
	return r.Equals(*value)
}

func (r devicesQueryUpdatedatBigInt) Order(direction SortOrder) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: direction,
		},
	}
}

func (r devicesQueryUpdatedatBigInt) Cursor(cursor BigInt) devicesCursorParam {
	return devicesCursorParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: cursor,
		},
	}
}

func (r devicesQueryUpdatedatBigInt) In(value []BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedatBigInt) InIfPresent(value []BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.In(value)
}

func (r devicesQueryUpdatedatBigInt) NotIn(value []BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedatBigInt) NotInIfPresent(value []BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r devicesQueryUpdatedatBigInt) Lt(value BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedatBigInt) LtIfPresent(value *BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r devicesQueryUpdatedatBigInt) Lte(value BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedatBigInt) LteIfPresent(value *BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r devicesQueryUpdatedatBigInt) Gt(value BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedatBigInt) GtIfPresent(value *BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r devicesQueryUpdatedatBigInt) Gte(value BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedatBigInt) GteIfPresent(value *BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r devicesQueryUpdatedatBigInt) Not(value BigInt) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedatBigInt) NotIfPresent(value *BigInt) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Not(*value)
}

func (r devicesQueryUpdatedatBigInt) Field() devicesPrismaFields {
	return devicesFieldUpdatedat
}

// base struct
type devicesQueryUpdatedbyString struct{}

// Set the required value of Updatedby
func (r devicesQueryUpdatedbyString) Set(value string) devicesWithPrismaUpdatedbySetParam {

	return devicesWithPrismaUpdatedbySetParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: value,
		},
	}

}

// Set the optional value of Updatedby dynamically
func (r devicesQueryUpdatedbyString) SetIfPresent(value *String) devicesWithPrismaUpdatedbySetParam {
	if value == nil {
		return devicesWithPrismaUpdatedbySetParam{}
	}

	return r.Set(*value)
}

func (r devicesQueryUpdatedbyString) Equals(value string) devicesWithPrismaUpdatedbyEqualsParam {

	return devicesWithPrismaUpdatedbyEqualsParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedbyString) EqualsIfPresent(value *string) devicesWithPrismaUpdatedbyEqualsParam {
	if value == nil {
		return devicesWithPrismaUpdatedbyEqualsParam{}
	}
	return r.Equals(*value)
}

func (r devicesQueryUpdatedbyString) Order(direction SortOrder) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: direction,
		},
	}
}

func (r devicesQueryUpdatedbyString) Cursor(cursor string) devicesCursorParam {
	return devicesCursorParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: cursor,
		},
	}
}

func (r devicesQueryUpdatedbyString) In(value []string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedbyString) InIfPresent(value []string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.In(value)
}

func (r devicesQueryUpdatedbyString) NotIn(value []string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedbyString) NotInIfPresent(value []string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r devicesQueryUpdatedbyString) Lt(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedbyString) LtIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r devicesQueryUpdatedbyString) Lte(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedbyString) LteIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r devicesQueryUpdatedbyString) Gt(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedbyString) GtIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r devicesQueryUpdatedbyString) Gte(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedbyString) GteIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r devicesQueryUpdatedbyString) Contains(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedbyString) ContainsIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r devicesQueryUpdatedbyString) StartsWith(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedbyString) StartsWithIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r devicesQueryUpdatedbyString) EndsWith(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedbyString) EndsWithIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r devicesQueryUpdatedbyString) Mode(value QueryMode) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedbyString) ModeIfPresent(value *QueryMode) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r devicesQueryUpdatedbyString) Not(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r devicesQueryUpdatedbyString) NotIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r devicesQueryUpdatedbyString) HasPrefix(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r devicesQueryUpdatedbyString) HasPrefixIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r devicesQueryUpdatedbyString) HasSuffix(value string) devicesDefaultParam {
	return devicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r devicesQueryUpdatedbyString) HasSuffixIfPresent(value *string) devicesDefaultParam {
	if value == nil {
		return devicesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r devicesQueryUpdatedbyString) Field() devicesPrismaFields {
	return devicesFieldUpdatedby
}

// base struct
type devicesQueryGroupdevicesgroupdevices struct{}

type devicesQueryGroupdevicesRelations struct{}

// Devices -> Groupdevices
//
// @relation
// @required
func (devicesQueryGroupdevicesRelations) Some(
	params ...GroupdevicesWhereParam,
) devicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesDefaultParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Devices -> Groupdevices
//
// @relation
// @required
func (devicesQueryGroupdevicesRelations) Every(
	params ...GroupdevicesWhereParam,
) devicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesDefaultParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Devices -> Groupdevices
//
// @relation
// @required
func (devicesQueryGroupdevicesRelations) None(
	params ...GroupdevicesWhereParam,
) devicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesDefaultParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (devicesQueryGroupdevicesRelations) Fetch(

	params ...GroupdevicesWhereParam,

) devicesToGroupdevicesFindMany {
	var v devicesToGroupdevicesFindMany

	v.query.Operation = "query"
	v.query.Method = "groupdevices"
	v.query.Outputs = groupdevicesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r devicesQueryGroupdevicesRelations) Link(
	params ...GroupdevicesWhereParam,
) devicesSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesSetParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r devicesQueryGroupdevicesRelations) Unlink(
	params ...GroupdevicesWhereParam,
) devicesSetParam {
	var v devicesSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = devicesSetParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r devicesQueryGroupdevicesgroupdevices) Field() devicesPrismaFields {
	return devicesFieldGroupdevices
}

// base struct
type devicesQueryOrgdevicesorgdevices struct{}

type devicesQueryOrgdevicesRelations struct{}

// Devices -> Orgdevices
//
// @relation
// @required
func (devicesQueryOrgdevicesRelations) Some(
	params ...OrgdevicesWhereParam,
) devicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesDefaultParam{
		data: builder.Field{
			Name: "orgdevices",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Devices -> Orgdevices
//
// @relation
// @required
func (devicesQueryOrgdevicesRelations) Every(
	params ...OrgdevicesWhereParam,
) devicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesDefaultParam{
		data: builder.Field{
			Name: "orgdevices",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Devices -> Orgdevices
//
// @relation
// @required
func (devicesQueryOrgdevicesRelations) None(
	params ...OrgdevicesWhereParam,
) devicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesDefaultParam{
		data: builder.Field{
			Name: "orgdevices",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (devicesQueryOrgdevicesRelations) Fetch(

	params ...OrgdevicesWhereParam,

) devicesToOrgdevicesFindMany {
	var v devicesToOrgdevicesFindMany

	v.query.Operation = "query"
	v.query.Method = "orgdevices"
	v.query.Outputs = orgdevicesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r devicesQueryOrgdevicesRelations) Link(
	params ...OrgdevicesWhereParam,
) devicesSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return devicesSetParam{
		data: builder.Field{
			Name: "orgdevices",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r devicesQueryOrgdevicesRelations) Unlink(
	params ...OrgdevicesWhereParam,
) devicesSetParam {
	var v devicesSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = devicesSetParam{
		data: builder.Field{
			Name: "orgdevices",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r devicesQueryOrgdevicesorgdevices) Field() devicesPrismaFields {
	return devicesFieldOrgdevices
}

// Groupdevices acts as a namespaces to access query methods for the Groupdevices model
var Groupdevices = groupdevicesQuery{}

// groupdevicesQuery exposes query functions for the groupdevices model
type groupdevicesQuery struct {

	// Orgid
	//
	// @required
	Orgid groupdevicesQueryOrgidString

	// Groupid
	//
	// @required
	Groupid groupdevicesQueryGroupidString

	// Deviceid
	//
	// @required
	Deviceid groupdevicesQueryDeviceidString

	// Isexist
	//
	// @required
	Isexist groupdevicesQueryIsexistBoolean

	// Updatedat
	//
	// @required
	Updatedat groupdevicesQueryUpdatedatBigInt

	// Updatedby
	//
	// @required
	Updatedby groupdevicesQueryUpdatedbyString

	Devices groupdevicesQueryDevicesRelations

	Groups groupdevicesQueryGroupsRelations

	Orgs groupdevicesQueryOrgsRelations
}

func (groupdevicesQuery) Not(params ...GroupdevicesWhereParam) groupdevicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupdevicesDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (groupdevicesQuery) Or(params ...GroupdevicesWhereParam) groupdevicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupdevicesDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (groupdevicesQuery) And(params ...GroupdevicesWhereParam) groupdevicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupdevicesDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (groupdevicesQuery) OrgidGroupidDeviceid(
	_orgid GroupdevicesWithPrismaOrgidWhereParam,

	_groupid GroupdevicesWithPrismaGroupidWhereParam,

	_deviceid GroupdevicesWithPrismaDeviceidWhereParam,
) GroupdevicesEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _orgid.field())
	fields = append(fields, _groupid.field())
	fields = append(fields, _deviceid.field())

	return groupdevicesEqualsUniqueParam{
		data: builder.Field{
			Name:   "orgid_groupid_deviceid",
			Fields: builder.TransformEquals(fields),
		},
	}
}

func (groupdevicesQuery) OrgidGroupidDeviceidIsexist(
	_orgid GroupdevicesWithPrismaOrgidWhereParam,

	_groupid GroupdevicesWithPrismaGroupidWhereParam,

	_deviceid GroupdevicesWithPrismaDeviceidWhereParam,

	_isexist GroupdevicesWithPrismaIsexistWhereParam,
) GroupdevicesEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _orgid.field())
	fields = append(fields, _groupid.field())
	fields = append(fields, _deviceid.field())
	fields = append(fields, _isexist.field())

	return groupdevicesEqualsUniqueParam{
		data: builder.Field{
			Name:   "orgid_groupid_deviceid_isexist",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type groupdevicesQueryOrgidString struct{}

// Set the required value of Orgid
func (r groupdevicesQueryOrgidString) Set(value string) groupdevicesSetParam {

	return groupdevicesSetParam{
		data: builder.Field{
			Name:  "orgid",
			Value: value,
		},
	}

}

// Set the optional value of Orgid dynamically
func (r groupdevicesQueryOrgidString) SetIfPresent(value *String) groupdevicesSetParam {
	if value == nil {
		return groupdevicesSetParam{}
	}

	return r.Set(*value)
}

func (r groupdevicesQueryOrgidString) Equals(value string) groupdevicesWithPrismaOrgidEqualsParam {

	return groupdevicesWithPrismaOrgidEqualsParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgidString) EqualsIfPresent(value *string) groupdevicesWithPrismaOrgidEqualsParam {
	if value == nil {
		return groupdevicesWithPrismaOrgidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupdevicesQueryOrgidString) Order(direction SortOrder) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name:  "orgid",
			Value: direction,
		},
	}
}

func (r groupdevicesQueryOrgidString) Cursor(cursor string) groupdevicesCursorParam {
	return groupdevicesCursorParam{
		data: builder.Field{
			Name:  "orgid",
			Value: cursor,
		},
	}
}

func (r groupdevicesQueryOrgidString) In(value []string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgidString) InIfPresent(value []string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.In(value)
}

func (r groupdevicesQueryOrgidString) NotIn(value []string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgidString) NotInIfPresent(value []string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupdevicesQueryOrgidString) Lt(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgidString) LtIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupdevicesQueryOrgidString) Lte(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgidString) LteIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupdevicesQueryOrgidString) Gt(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgidString) GtIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupdevicesQueryOrgidString) Gte(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgidString) GteIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupdevicesQueryOrgidString) Contains(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgidString) ContainsIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r groupdevicesQueryOrgidString) StartsWith(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgidString) StartsWithIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r groupdevicesQueryOrgidString) EndsWith(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgidString) EndsWithIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r groupdevicesQueryOrgidString) Mode(value QueryMode) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgidString) ModeIfPresent(value *QueryMode) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r groupdevicesQueryOrgidString) Not(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgidString) NotIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupdevicesQueryOrgidString) HasPrefix(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupdevicesQueryOrgidString) HasPrefixIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupdevicesQueryOrgidString) HasSuffix(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupdevicesQueryOrgidString) HasSuffixIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r groupdevicesQueryOrgidString) Field() groupdevicesPrismaFields {
	return groupdevicesFieldOrgid
}

// base struct
type groupdevicesQueryGroupidString struct{}

// Set the required value of Groupid
func (r groupdevicesQueryGroupidString) Set(value string) groupdevicesSetParam {

	return groupdevicesSetParam{
		data: builder.Field{
			Name:  "groupid",
			Value: value,
		},
	}

}

// Set the optional value of Groupid dynamically
func (r groupdevicesQueryGroupidString) SetIfPresent(value *String) groupdevicesSetParam {
	if value == nil {
		return groupdevicesSetParam{}
	}

	return r.Set(*value)
}

func (r groupdevicesQueryGroupidString) Equals(value string) groupdevicesWithPrismaGroupidEqualsParam {

	return groupdevicesWithPrismaGroupidEqualsParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupidString) EqualsIfPresent(value *string) groupdevicesWithPrismaGroupidEqualsParam {
	if value == nil {
		return groupdevicesWithPrismaGroupidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupdevicesQueryGroupidString) Order(direction SortOrder) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name:  "groupid",
			Value: direction,
		},
	}
}

func (r groupdevicesQueryGroupidString) Cursor(cursor string) groupdevicesCursorParam {
	return groupdevicesCursorParam{
		data: builder.Field{
			Name:  "groupid",
			Value: cursor,
		},
	}
}

func (r groupdevicesQueryGroupidString) In(value []string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupidString) InIfPresent(value []string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.In(value)
}

func (r groupdevicesQueryGroupidString) NotIn(value []string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupidString) NotInIfPresent(value []string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupdevicesQueryGroupidString) Lt(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupidString) LtIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupdevicesQueryGroupidString) Lte(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupidString) LteIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupdevicesQueryGroupidString) Gt(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupidString) GtIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupdevicesQueryGroupidString) Gte(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupidString) GteIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupdevicesQueryGroupidString) Contains(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupidString) ContainsIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r groupdevicesQueryGroupidString) StartsWith(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupidString) StartsWithIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r groupdevicesQueryGroupidString) EndsWith(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupidString) EndsWithIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r groupdevicesQueryGroupidString) Mode(value QueryMode) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupidString) ModeIfPresent(value *QueryMode) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r groupdevicesQueryGroupidString) Not(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupidString) NotIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupdevicesQueryGroupidString) HasPrefix(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupdevicesQueryGroupidString) HasPrefixIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupdevicesQueryGroupidString) HasSuffix(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupdevicesQueryGroupidString) HasSuffixIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r groupdevicesQueryGroupidString) Field() groupdevicesPrismaFields {
	return groupdevicesFieldGroupid
}

// base struct
type groupdevicesQueryDeviceidString struct{}

// Set the required value of Deviceid
func (r groupdevicesQueryDeviceidString) Set(value string) groupdevicesSetParam {

	return groupdevicesSetParam{
		data: builder.Field{
			Name:  "deviceid",
			Value: value,
		},
	}

}

// Set the optional value of Deviceid dynamically
func (r groupdevicesQueryDeviceidString) SetIfPresent(value *String) groupdevicesSetParam {
	if value == nil {
		return groupdevicesSetParam{}
	}

	return r.Set(*value)
}

func (r groupdevicesQueryDeviceidString) Equals(value string) groupdevicesWithPrismaDeviceidEqualsParam {

	return groupdevicesWithPrismaDeviceidEqualsParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryDeviceidString) EqualsIfPresent(value *string) groupdevicesWithPrismaDeviceidEqualsParam {
	if value == nil {
		return groupdevicesWithPrismaDeviceidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupdevicesQueryDeviceidString) Order(direction SortOrder) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name:  "deviceid",
			Value: direction,
		},
	}
}

func (r groupdevicesQueryDeviceidString) Cursor(cursor string) groupdevicesCursorParam {
	return groupdevicesCursorParam{
		data: builder.Field{
			Name:  "deviceid",
			Value: cursor,
		},
	}
}

func (r groupdevicesQueryDeviceidString) In(value []string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryDeviceidString) InIfPresent(value []string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.In(value)
}

func (r groupdevicesQueryDeviceidString) NotIn(value []string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryDeviceidString) NotInIfPresent(value []string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupdevicesQueryDeviceidString) Lt(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryDeviceidString) LtIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupdevicesQueryDeviceidString) Lte(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryDeviceidString) LteIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupdevicesQueryDeviceidString) Gt(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryDeviceidString) GtIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupdevicesQueryDeviceidString) Gte(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryDeviceidString) GteIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupdevicesQueryDeviceidString) Contains(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryDeviceidString) ContainsIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r groupdevicesQueryDeviceidString) StartsWith(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryDeviceidString) StartsWithIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r groupdevicesQueryDeviceidString) EndsWith(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryDeviceidString) EndsWithIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r groupdevicesQueryDeviceidString) Mode(value QueryMode) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryDeviceidString) ModeIfPresent(value *QueryMode) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r groupdevicesQueryDeviceidString) Not(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryDeviceidString) NotIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupdevicesQueryDeviceidString) HasPrefix(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupdevicesQueryDeviceidString) HasPrefixIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupdevicesQueryDeviceidString) HasSuffix(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupdevicesQueryDeviceidString) HasSuffixIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r groupdevicesQueryDeviceidString) Field() groupdevicesPrismaFields {
	return groupdevicesFieldDeviceid
}

// base struct
type groupdevicesQueryIsexistBoolean struct{}

// Set the required value of Isexist
func (r groupdevicesQueryIsexistBoolean) Set(value bool) groupdevicesWithPrismaIsexistSetParam {

	return groupdevicesWithPrismaIsexistSetParam{
		data: builder.Field{
			Name:  "isexist",
			Value: value,
		},
	}

}

// Set the optional value of Isexist dynamically
func (r groupdevicesQueryIsexistBoolean) SetIfPresent(value *Boolean) groupdevicesWithPrismaIsexistSetParam {
	if value == nil {
		return groupdevicesWithPrismaIsexistSetParam{}
	}

	return r.Set(*value)
}

func (r groupdevicesQueryIsexistBoolean) Equals(value bool) groupdevicesWithPrismaIsexistEqualsParam {

	return groupdevicesWithPrismaIsexistEqualsParam{
		data: builder.Field{
			Name: "isexist",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryIsexistBoolean) EqualsIfPresent(value *bool) groupdevicesWithPrismaIsexistEqualsParam {
	if value == nil {
		return groupdevicesWithPrismaIsexistEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupdevicesQueryIsexistBoolean) Order(direction SortOrder) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name:  "isexist",
			Value: direction,
		},
	}
}

func (r groupdevicesQueryIsexistBoolean) Cursor(cursor bool) groupdevicesCursorParam {
	return groupdevicesCursorParam{
		data: builder.Field{
			Name:  "isexist",
			Value: cursor,
		},
	}
}

func (r groupdevicesQueryIsexistBoolean) Field() groupdevicesPrismaFields {
	return groupdevicesFieldIsexist
}

// base struct
type groupdevicesQueryUpdatedatBigInt struct{}

// Set the required value of Updatedat
func (r groupdevicesQueryUpdatedatBigInt) Set(value BigInt) groupdevicesSetParam {

	return groupdevicesSetParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: value,
		},
	}

}

// Set the optional value of Updatedat dynamically
func (r groupdevicesQueryUpdatedatBigInt) SetIfPresent(value *BigInt) groupdevicesSetParam {
	if value == nil {
		return groupdevicesSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Updatedat
func (r groupdevicesQueryUpdatedatBigInt) Increment(value BigInt) groupdevicesSetParam {
	return groupdevicesSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) IncrementIfPresent(value *BigInt) groupdevicesSetParam {
	if value == nil {
		return groupdevicesSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Updatedat
func (r groupdevicesQueryUpdatedatBigInt) Decrement(value BigInt) groupdevicesSetParam {
	return groupdevicesSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) DecrementIfPresent(value *BigInt) groupdevicesSetParam {
	if value == nil {
		return groupdevicesSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Updatedat
func (r groupdevicesQueryUpdatedatBigInt) Multiply(value BigInt) groupdevicesSetParam {
	return groupdevicesSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) MultiplyIfPresent(value *BigInt) groupdevicesSetParam {
	if value == nil {
		return groupdevicesSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Updatedat
func (r groupdevicesQueryUpdatedatBigInt) Divide(value BigInt) groupdevicesSetParam {
	return groupdevicesSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) DivideIfPresent(value *BigInt) groupdevicesSetParam {
	if value == nil {
		return groupdevicesSetParam{}
	}
	return r.Divide(*value)
}

func (r groupdevicesQueryUpdatedatBigInt) Equals(value BigInt) groupdevicesWithPrismaUpdatedatEqualsParam {

	return groupdevicesWithPrismaUpdatedatEqualsParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) EqualsIfPresent(value *BigInt) groupdevicesWithPrismaUpdatedatEqualsParam {
	if value == nil {
		return groupdevicesWithPrismaUpdatedatEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupdevicesQueryUpdatedatBigInt) Order(direction SortOrder) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: direction,
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) Cursor(cursor BigInt) groupdevicesCursorParam {
	return groupdevicesCursorParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: cursor,
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) In(value []BigInt) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) InIfPresent(value []BigInt) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.In(value)
}

func (r groupdevicesQueryUpdatedatBigInt) NotIn(value []BigInt) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) NotInIfPresent(value []BigInt) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupdevicesQueryUpdatedatBigInt) Lt(value BigInt) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) LtIfPresent(value *BigInt) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupdevicesQueryUpdatedatBigInt) Lte(value BigInt) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) LteIfPresent(value *BigInt) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupdevicesQueryUpdatedatBigInt) Gt(value BigInt) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) GtIfPresent(value *BigInt) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupdevicesQueryUpdatedatBigInt) Gte(value BigInt) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) GteIfPresent(value *BigInt) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupdevicesQueryUpdatedatBigInt) Not(value BigInt) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedatBigInt) NotIfPresent(value *BigInt) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Not(*value)
}

func (r groupdevicesQueryUpdatedatBigInt) Field() groupdevicesPrismaFields {
	return groupdevicesFieldUpdatedat
}

// base struct
type groupdevicesQueryUpdatedbyString struct{}

// Set the required value of Updatedby
func (r groupdevicesQueryUpdatedbyString) Set(value string) groupdevicesWithPrismaUpdatedbySetParam {

	return groupdevicesWithPrismaUpdatedbySetParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: value,
		},
	}

}

// Set the optional value of Updatedby dynamically
func (r groupdevicesQueryUpdatedbyString) SetIfPresent(value *String) groupdevicesWithPrismaUpdatedbySetParam {
	if value == nil {
		return groupdevicesWithPrismaUpdatedbySetParam{}
	}

	return r.Set(*value)
}

func (r groupdevicesQueryUpdatedbyString) Equals(value string) groupdevicesWithPrismaUpdatedbyEqualsParam {

	return groupdevicesWithPrismaUpdatedbyEqualsParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) EqualsIfPresent(value *string) groupdevicesWithPrismaUpdatedbyEqualsParam {
	if value == nil {
		return groupdevicesWithPrismaUpdatedbyEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupdevicesQueryUpdatedbyString) Order(direction SortOrder) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: direction,
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) Cursor(cursor string) groupdevicesCursorParam {
	return groupdevicesCursorParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: cursor,
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) In(value []string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) InIfPresent(value []string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.In(value)
}

func (r groupdevicesQueryUpdatedbyString) NotIn(value []string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) NotInIfPresent(value []string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupdevicesQueryUpdatedbyString) Lt(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) LtIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupdevicesQueryUpdatedbyString) Lte(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) LteIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupdevicesQueryUpdatedbyString) Gt(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) GtIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupdevicesQueryUpdatedbyString) Gte(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) GteIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupdevicesQueryUpdatedbyString) Contains(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) ContainsIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r groupdevicesQueryUpdatedbyString) StartsWith(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) StartsWithIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r groupdevicesQueryUpdatedbyString) EndsWith(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) EndsWithIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r groupdevicesQueryUpdatedbyString) Mode(value QueryMode) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) ModeIfPresent(value *QueryMode) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r groupdevicesQueryUpdatedbyString) Not(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupdevicesQueryUpdatedbyString) NotIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupdevicesQueryUpdatedbyString) HasPrefix(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupdevicesQueryUpdatedbyString) HasPrefixIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupdevicesQueryUpdatedbyString) HasSuffix(value string) groupdevicesDefaultParam {
	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupdevicesQueryUpdatedbyString) HasSuffixIfPresent(value *string) groupdevicesDefaultParam {
	if value == nil {
		return groupdevicesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r groupdevicesQueryUpdatedbyString) Field() groupdevicesPrismaFields {
	return groupdevicesFieldUpdatedby
}

// base struct
type groupdevicesQueryDevicesdevices struct{}

type groupdevicesQueryDevicesRelations struct{}

// Groupdevices -> Devices
//
// @relation
// @required
func (groupdevicesQueryDevicesRelations) Where(
	params ...DevicesWhereParam,
) groupdevicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (groupdevicesQueryDevicesRelations) Fetch() groupdevicesToDevicesFindUnique {
	var v groupdevicesToDevicesFindUnique

	v.query.Operation = "query"
	v.query.Method = "devices"
	v.query.Outputs = devicesOutput

	return v
}

func (r groupdevicesQueryDevicesRelations) Link(
	params DevicesWhereParam,
) groupdevicesWithPrismaDevicesSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return groupdevicesWithPrismaDevicesSetParam{}
	}

	fields = append(fields, f)

	return groupdevicesWithPrismaDevicesSetParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r groupdevicesQueryDevicesRelations) Unlink() groupdevicesWithPrismaDevicesSetParam {
	var v groupdevicesWithPrismaDevicesSetParam

	v = groupdevicesWithPrismaDevicesSetParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r groupdevicesQueryDevicesdevices) Field() groupdevicesPrismaFields {
	return groupdevicesFieldDevices
}

// base struct
type groupdevicesQueryGroupsgroups struct{}

type groupdevicesQueryGroupsRelations struct{}

// Groupdevices -> Groups
//
// @relation
// @required
func (groupdevicesQueryGroupsRelations) Where(
	params ...GroupsWhereParam,
) groupdevicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (groupdevicesQueryGroupsRelations) Fetch() groupdevicesToGroupsFindUnique {
	var v groupdevicesToGroupsFindUnique

	v.query.Operation = "query"
	v.query.Method = "groups"
	v.query.Outputs = groupsOutput

	return v
}

func (r groupdevicesQueryGroupsRelations) Link(
	params GroupsWhereParam,
) groupdevicesWithPrismaGroupsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return groupdevicesWithPrismaGroupsSetParam{}
	}

	fields = append(fields, f)

	return groupdevicesWithPrismaGroupsSetParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r groupdevicesQueryGroupsRelations) Unlink() groupdevicesWithPrismaGroupsSetParam {
	var v groupdevicesWithPrismaGroupsSetParam

	v = groupdevicesWithPrismaGroupsSetParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r groupdevicesQueryGroupsgroups) Field() groupdevicesPrismaFields {
	return groupdevicesFieldGroups
}

// base struct
type groupdevicesQueryOrgsorgs struct{}

type groupdevicesQueryOrgsRelations struct{}

// Groupdevices -> Orgs
//
// @relation
// @required
func (groupdevicesQueryOrgsRelations) Where(
	params ...OrgsWhereParam,
) groupdevicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupdevicesDefaultParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (groupdevicesQueryOrgsRelations) Fetch() groupdevicesToOrgsFindUnique {
	var v groupdevicesToOrgsFindUnique

	v.query.Operation = "query"
	v.query.Method = "orgs"
	v.query.Outputs = orgsOutput

	return v
}

func (r groupdevicesQueryOrgsRelations) Link(
	params OrgsWhereParam,
) groupdevicesWithPrismaOrgsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return groupdevicesWithPrismaOrgsSetParam{}
	}

	fields = append(fields, f)

	return groupdevicesWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r groupdevicesQueryOrgsRelations) Unlink() groupdevicesWithPrismaOrgsSetParam {
	var v groupdevicesWithPrismaOrgsSetParam

	v = groupdevicesWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r groupdevicesQueryOrgsorgs) Field() groupdevicesPrismaFields {
	return groupdevicesFieldOrgs
}

// Groups acts as a namespaces to access query methods for the Groups model
var Groups = groupsQuery{}

// groupsQuery exposes query functions for the groups model
type groupsQuery struct {

	// Orgid
	//
	// @required
	Orgid groupsQueryOrgidString

	// Groupid
	//
	// @required
	Groupid groupsQueryGroupidString

	// Groupname
	//
	// @required
	Groupname groupsQueryGroupnameString

	// Isdeleted
	//
	// @required
	Isdeleted groupsQueryIsdeletedBoolean

	// Groupmeta
	//
	// @optional
	Groupmeta groupsQueryGroupmetaJson

	// Createdat
	//
	// @required
	Createdat groupsQueryCreatedatBigInt

	// Createdby
	//
	// @required
	Createdby groupsQueryCreatedbyString

	// Updatedat
	//
	// @required
	Updatedat groupsQueryUpdatedatBigInt

	// Updatedby
	//
	// @required
	Updatedby groupsQueryUpdatedbyString

	Groupdevices groupsQueryGroupdevicesRelations

	Orgs groupsQueryOrgsRelations

	GrouptreeGrouptreeGroupidTogroups groupsQueryGrouptreeGrouptreeGroupidTogroupsRelations

	GrouptreeGrouptreePgroupidTogroups groupsQueryGrouptreeGrouptreePgroupidTogroupsRelations

	Groupuserperms groupsQueryGroupuserpermsRelations

	Orgrgroup groupsQueryOrgrgroupRelations

	Usergroup groupsQueryUsergroupRelations
}

func (groupsQuery) Not(params ...GroupsWhereParam) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (groupsQuery) Or(params ...GroupsWhereParam) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (groupsQuery) And(params ...GroupsWhereParam) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type groupsQueryOrgidString struct{}

// Set the required value of Orgid
func (r groupsQueryOrgidString) Set(value string) groupsSetParam {

	return groupsSetParam{
		data: builder.Field{
			Name:  "orgid",
			Value: value,
		},
	}

}

// Set the optional value of Orgid dynamically
func (r groupsQueryOrgidString) SetIfPresent(value *String) groupsSetParam {
	if value == nil {
		return groupsSetParam{}
	}

	return r.Set(*value)
}

func (r groupsQueryOrgidString) Equals(value string) groupsWithPrismaOrgidEqualsParam {

	return groupsWithPrismaOrgidEqualsParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryOrgidString) EqualsIfPresent(value *string) groupsWithPrismaOrgidEqualsParam {
	if value == nil {
		return groupsWithPrismaOrgidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupsQueryOrgidString) Order(direction SortOrder) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name:  "orgid",
			Value: direction,
		},
	}
}

func (r groupsQueryOrgidString) Cursor(cursor string) groupsCursorParam {
	return groupsCursorParam{
		data: builder.Field{
			Name:  "orgid",
			Value: cursor,
		},
	}
}

func (r groupsQueryOrgidString) In(value []string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryOrgidString) InIfPresent(value []string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.In(value)
}

func (r groupsQueryOrgidString) NotIn(value []string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryOrgidString) NotInIfPresent(value []string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupsQueryOrgidString) Lt(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryOrgidString) LtIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupsQueryOrgidString) Lte(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryOrgidString) LteIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupsQueryOrgidString) Gt(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryOrgidString) GtIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupsQueryOrgidString) Gte(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryOrgidString) GteIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupsQueryOrgidString) Contains(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryOrgidString) ContainsIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r groupsQueryOrgidString) StartsWith(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryOrgidString) StartsWithIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r groupsQueryOrgidString) EndsWith(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryOrgidString) EndsWithIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r groupsQueryOrgidString) Mode(value QueryMode) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryOrgidString) ModeIfPresent(value *QueryMode) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r groupsQueryOrgidString) Not(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryOrgidString) NotIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupsQueryOrgidString) HasPrefix(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupsQueryOrgidString) HasPrefixIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupsQueryOrgidString) HasSuffix(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupsQueryOrgidString) HasSuffixIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r groupsQueryOrgidString) Field() groupsPrismaFields {
	return groupsFieldOrgid
}

// base struct
type groupsQueryGroupidString struct{}

// Set the required value of Groupid
func (r groupsQueryGroupidString) Set(value string) groupsWithPrismaGroupidSetParam {

	return groupsWithPrismaGroupidSetParam{
		data: builder.Field{
			Name:  "groupid",
			Value: value,
		},
	}

}

// Set the optional value of Groupid dynamically
func (r groupsQueryGroupidString) SetIfPresent(value *String) groupsWithPrismaGroupidSetParam {
	if value == nil {
		return groupsWithPrismaGroupidSetParam{}
	}

	return r.Set(*value)
}

func (r groupsQueryGroupidString) Equals(value string) groupsWithPrismaGroupidEqualsUniqueParam {

	return groupsWithPrismaGroupidEqualsUniqueParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupidString) EqualsIfPresent(value *string) groupsWithPrismaGroupidEqualsUniqueParam {
	if value == nil {
		return groupsWithPrismaGroupidEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r groupsQueryGroupidString) Order(direction SortOrder) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name:  "groupid",
			Value: direction,
		},
	}
}

func (r groupsQueryGroupidString) Cursor(cursor string) groupsCursorParam {
	return groupsCursorParam{
		data: builder.Field{
			Name:  "groupid",
			Value: cursor,
		},
	}
}

func (r groupsQueryGroupidString) In(value []string) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupidString) InIfPresent(value []string) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.In(value)
}

func (r groupsQueryGroupidString) NotIn(value []string) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupidString) NotInIfPresent(value []string) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.NotIn(value)
}

func (r groupsQueryGroupidString) Lt(value string) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupidString) LtIfPresent(value *string) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.Lt(*value)
}

func (r groupsQueryGroupidString) Lte(value string) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupidString) LteIfPresent(value *string) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.Lte(*value)
}

func (r groupsQueryGroupidString) Gt(value string) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupidString) GtIfPresent(value *string) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.Gt(*value)
}

func (r groupsQueryGroupidString) Gte(value string) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupidString) GteIfPresent(value *string) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.Gte(*value)
}

func (r groupsQueryGroupidString) Contains(value string) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupidString) ContainsIfPresent(value *string) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.Contains(*value)
}

func (r groupsQueryGroupidString) StartsWith(value string) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupidString) StartsWithIfPresent(value *string) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r groupsQueryGroupidString) EndsWith(value string) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupidString) EndsWithIfPresent(value *string) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r groupsQueryGroupidString) Mode(value QueryMode) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupidString) ModeIfPresent(value *QueryMode) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.Mode(*value)
}

func (r groupsQueryGroupidString) Not(value string) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupidString) NotIfPresent(value *string) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupsQueryGroupidString) HasPrefix(value string) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupsQueryGroupidString) HasPrefixIfPresent(value *string) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupsQueryGroupidString) HasSuffix(value string) groupsParamUnique {
	return groupsParamUnique{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupsQueryGroupidString) HasSuffixIfPresent(value *string) groupsParamUnique {
	if value == nil {
		return groupsParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r groupsQueryGroupidString) Field() groupsPrismaFields {
	return groupsFieldGroupid
}

// base struct
type groupsQueryGroupnameString struct{}

// Set the required value of Groupname
func (r groupsQueryGroupnameString) Set(value string) groupsWithPrismaGroupnameSetParam {

	return groupsWithPrismaGroupnameSetParam{
		data: builder.Field{
			Name:  "groupname",
			Value: value,
		},
	}

}

// Set the optional value of Groupname dynamically
func (r groupsQueryGroupnameString) SetIfPresent(value *String) groupsWithPrismaGroupnameSetParam {
	if value == nil {
		return groupsWithPrismaGroupnameSetParam{}
	}

	return r.Set(*value)
}

func (r groupsQueryGroupnameString) Equals(value string) groupsWithPrismaGroupnameEqualsParam {

	return groupsWithPrismaGroupnameEqualsParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupnameString) EqualsIfPresent(value *string) groupsWithPrismaGroupnameEqualsParam {
	if value == nil {
		return groupsWithPrismaGroupnameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupsQueryGroupnameString) Order(direction SortOrder) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name:  "groupname",
			Value: direction,
		},
	}
}

func (r groupsQueryGroupnameString) Cursor(cursor string) groupsCursorParam {
	return groupsCursorParam{
		data: builder.Field{
			Name:  "groupname",
			Value: cursor,
		},
	}
}

func (r groupsQueryGroupnameString) In(value []string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupnameString) InIfPresent(value []string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.In(value)
}

func (r groupsQueryGroupnameString) NotIn(value []string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupnameString) NotInIfPresent(value []string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupsQueryGroupnameString) Lt(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupnameString) LtIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupsQueryGroupnameString) Lte(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupnameString) LteIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupsQueryGroupnameString) Gt(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupnameString) GtIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupsQueryGroupnameString) Gte(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupnameString) GteIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupsQueryGroupnameString) Contains(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupnameString) ContainsIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r groupsQueryGroupnameString) StartsWith(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupnameString) StartsWithIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r groupsQueryGroupnameString) EndsWith(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupnameString) EndsWithIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r groupsQueryGroupnameString) Mode(value QueryMode) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupnameString) ModeIfPresent(value *QueryMode) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r groupsQueryGroupnameString) Not(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupnameString) NotIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupsQueryGroupnameString) HasPrefix(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupsQueryGroupnameString) HasPrefixIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupsQueryGroupnameString) HasSuffix(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupname",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupsQueryGroupnameString) HasSuffixIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r groupsQueryGroupnameString) Field() groupsPrismaFields {
	return groupsFieldGroupname
}

// base struct
type groupsQueryIsdeletedBoolean struct{}

// Set the required value of Isdeleted
func (r groupsQueryIsdeletedBoolean) Set(value bool) groupsWithPrismaIsdeletedSetParam {

	return groupsWithPrismaIsdeletedSetParam{
		data: builder.Field{
			Name:  "isdeleted",
			Value: value,
		},
	}

}

// Set the optional value of Isdeleted dynamically
func (r groupsQueryIsdeletedBoolean) SetIfPresent(value *Boolean) groupsWithPrismaIsdeletedSetParam {
	if value == nil {
		return groupsWithPrismaIsdeletedSetParam{}
	}

	return r.Set(*value)
}

func (r groupsQueryIsdeletedBoolean) Equals(value bool) groupsWithPrismaIsdeletedEqualsParam {

	return groupsWithPrismaIsdeletedEqualsParam{
		data: builder.Field{
			Name: "isdeleted",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryIsdeletedBoolean) EqualsIfPresent(value *bool) groupsWithPrismaIsdeletedEqualsParam {
	if value == nil {
		return groupsWithPrismaIsdeletedEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupsQueryIsdeletedBoolean) Order(direction SortOrder) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name:  "isdeleted",
			Value: direction,
		},
	}
}

func (r groupsQueryIsdeletedBoolean) Cursor(cursor bool) groupsCursorParam {
	return groupsCursorParam{
		data: builder.Field{
			Name:  "isdeleted",
			Value: cursor,
		},
	}
}

func (r groupsQueryIsdeletedBoolean) Field() groupsPrismaFields {
	return groupsFieldIsdeleted
}

// base struct
type groupsQueryGroupmetaJson struct{}

// Set the optional value of Groupmeta
func (r groupsQueryGroupmetaJson) Set(value JSON) groupsSetParam {

	return groupsSetParam{
		data: builder.Field{
			Name:  "groupmeta",
			Value: value,
		},
	}

}

// Set the optional value of Groupmeta dynamically
func (r groupsQueryGroupmetaJson) SetIfPresent(value *JSON) groupsSetParam {
	if value == nil {
		return groupsSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Groupmeta dynamically
func (r groupsQueryGroupmetaJson) SetOptional(value *JSON) groupsSetParam {
	if value == nil {

		var v *JSON
		return groupsSetParam{
			data: builder.Field{
				Name:  "groupmeta",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r groupsQueryGroupmetaJson) Equals(value JSON) groupsWithPrismaGroupmetaEqualsParam {

	return groupsWithPrismaGroupmetaEqualsParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) EqualsIfPresent(value *JSON) groupsWithPrismaGroupmetaEqualsParam {
	if value == nil {
		return groupsWithPrismaGroupmetaEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupsQueryGroupmetaJson) EqualsOptional(value *JSON) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) IsNull() groupsDefaultParam {
	var str *string = nil
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) Order(direction SortOrder) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name:  "groupmeta",
			Value: direction,
		},
	}
}

func (r groupsQueryGroupmetaJson) Cursor(cursor JSON) groupsCursorParam {
	return groupsCursorParam{
		data: builder.Field{
			Name:  "groupmeta",
			Value: cursor,
		},
	}
}

func (r groupsQueryGroupmetaJson) Path(value []string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "path",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) PathIfPresent(value []string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Path(value)
}

func (r groupsQueryGroupmetaJson) StringContains(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "string_contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) StringContainsIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.StringContains(*value)
}

func (r groupsQueryGroupmetaJson) StringStartsWith(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "string_starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) StringStartsWithIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.StringStartsWith(*value)
}

func (r groupsQueryGroupmetaJson) StringEndsWith(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "string_ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) StringEndsWithIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.StringEndsWith(*value)
}

func (r groupsQueryGroupmetaJson) ArrayStartsWith(value JSON) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "array_starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) ArrayStartsWithIfPresent(value *JSON) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.ArrayStartsWith(*value)
}

func (r groupsQueryGroupmetaJson) ArrayEndsWith(value JSON) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "array_ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) ArrayEndsWithIfPresent(value *JSON) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.ArrayEndsWith(*value)
}

func (r groupsQueryGroupmetaJson) ArrayContains(value JSON) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "array_contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) ArrayContainsIfPresent(value *JSON) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.ArrayContains(*value)
}

func (r groupsQueryGroupmetaJson) Lt(value JSON) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) LtIfPresent(value *JSON) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupsQueryGroupmetaJson) Lte(value JSON) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) LteIfPresent(value *JSON) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupsQueryGroupmetaJson) Gt(value JSON) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) GtIfPresent(value *JSON) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupsQueryGroupmetaJson) Gte(value JSON) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) GteIfPresent(value *JSON) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupsQueryGroupmetaJson) Not(value JSONNullValueFilter) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupmeta",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryGroupmetaJson) NotIfPresent(value *JSONNullValueFilter) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Not(*value)
}

func (r groupsQueryGroupmetaJson) Field() groupsPrismaFields {
	return groupsFieldGroupmeta
}

// base struct
type groupsQueryCreatedatBigInt struct{}

// Set the required value of Createdat
func (r groupsQueryCreatedatBigInt) Set(value BigInt) groupsSetParam {

	return groupsSetParam{
		data: builder.Field{
			Name:  "createdat",
			Value: value,
		},
	}

}

// Set the optional value of Createdat dynamically
func (r groupsQueryCreatedatBigInt) SetIfPresent(value *BigInt) groupsSetParam {
	if value == nil {
		return groupsSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Createdat
func (r groupsQueryCreatedatBigInt) Increment(value BigInt) groupsSetParam {
	return groupsSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedatBigInt) IncrementIfPresent(value *BigInt) groupsSetParam {
	if value == nil {
		return groupsSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Createdat
func (r groupsQueryCreatedatBigInt) Decrement(value BigInt) groupsSetParam {
	return groupsSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedatBigInt) DecrementIfPresent(value *BigInt) groupsSetParam {
	if value == nil {
		return groupsSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Createdat
func (r groupsQueryCreatedatBigInt) Multiply(value BigInt) groupsSetParam {
	return groupsSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedatBigInt) MultiplyIfPresent(value *BigInt) groupsSetParam {
	if value == nil {
		return groupsSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Createdat
func (r groupsQueryCreatedatBigInt) Divide(value BigInt) groupsSetParam {
	return groupsSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedatBigInt) DivideIfPresent(value *BigInt) groupsSetParam {
	if value == nil {
		return groupsSetParam{}
	}
	return r.Divide(*value)
}

func (r groupsQueryCreatedatBigInt) Equals(value BigInt) groupsWithPrismaCreatedatEqualsParam {

	return groupsWithPrismaCreatedatEqualsParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedatBigInt) EqualsIfPresent(value *BigInt) groupsWithPrismaCreatedatEqualsParam {
	if value == nil {
		return groupsWithPrismaCreatedatEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupsQueryCreatedatBigInt) Order(direction SortOrder) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name:  "createdat",
			Value: direction,
		},
	}
}

func (r groupsQueryCreatedatBigInt) Cursor(cursor BigInt) groupsCursorParam {
	return groupsCursorParam{
		data: builder.Field{
			Name:  "createdat",
			Value: cursor,
		},
	}
}

func (r groupsQueryCreatedatBigInt) In(value []BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedatBigInt) InIfPresent(value []BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.In(value)
}

func (r groupsQueryCreatedatBigInt) NotIn(value []BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedatBigInt) NotInIfPresent(value []BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupsQueryCreatedatBigInt) Lt(value BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedatBigInt) LtIfPresent(value *BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupsQueryCreatedatBigInt) Lte(value BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedatBigInt) LteIfPresent(value *BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupsQueryCreatedatBigInt) Gt(value BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedatBigInt) GtIfPresent(value *BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupsQueryCreatedatBigInt) Gte(value BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedatBigInt) GteIfPresent(value *BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupsQueryCreatedatBigInt) Not(value BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedatBigInt) NotIfPresent(value *BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Not(*value)
}

func (r groupsQueryCreatedatBigInt) Field() groupsPrismaFields {
	return groupsFieldCreatedat
}

// base struct
type groupsQueryCreatedbyString struct{}

// Set the required value of Createdby
func (r groupsQueryCreatedbyString) Set(value string) groupsWithPrismaCreatedbySetParam {

	return groupsWithPrismaCreatedbySetParam{
		data: builder.Field{
			Name:  "createdby",
			Value: value,
		},
	}

}

// Set the optional value of Createdby dynamically
func (r groupsQueryCreatedbyString) SetIfPresent(value *String) groupsWithPrismaCreatedbySetParam {
	if value == nil {
		return groupsWithPrismaCreatedbySetParam{}
	}

	return r.Set(*value)
}

func (r groupsQueryCreatedbyString) Equals(value string) groupsWithPrismaCreatedbyEqualsParam {

	return groupsWithPrismaCreatedbyEqualsParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedbyString) EqualsIfPresent(value *string) groupsWithPrismaCreatedbyEqualsParam {
	if value == nil {
		return groupsWithPrismaCreatedbyEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupsQueryCreatedbyString) Order(direction SortOrder) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name:  "createdby",
			Value: direction,
		},
	}
}

func (r groupsQueryCreatedbyString) Cursor(cursor string) groupsCursorParam {
	return groupsCursorParam{
		data: builder.Field{
			Name:  "createdby",
			Value: cursor,
		},
	}
}

func (r groupsQueryCreatedbyString) In(value []string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedbyString) InIfPresent(value []string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.In(value)
}

func (r groupsQueryCreatedbyString) NotIn(value []string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedbyString) NotInIfPresent(value []string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupsQueryCreatedbyString) Lt(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedbyString) LtIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupsQueryCreatedbyString) Lte(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedbyString) LteIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupsQueryCreatedbyString) Gt(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedbyString) GtIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupsQueryCreatedbyString) Gte(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedbyString) GteIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupsQueryCreatedbyString) Contains(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedbyString) ContainsIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r groupsQueryCreatedbyString) StartsWith(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedbyString) StartsWithIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r groupsQueryCreatedbyString) EndsWith(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedbyString) EndsWithIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r groupsQueryCreatedbyString) Mode(value QueryMode) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedbyString) ModeIfPresent(value *QueryMode) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r groupsQueryCreatedbyString) Not(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryCreatedbyString) NotIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupsQueryCreatedbyString) HasPrefix(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupsQueryCreatedbyString) HasPrefixIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupsQueryCreatedbyString) HasSuffix(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupsQueryCreatedbyString) HasSuffixIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r groupsQueryCreatedbyString) Field() groupsPrismaFields {
	return groupsFieldCreatedby
}

// base struct
type groupsQueryUpdatedatBigInt struct{}

// Set the required value of Updatedat
func (r groupsQueryUpdatedatBigInt) Set(value BigInt) groupsSetParam {

	return groupsSetParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: value,
		},
	}

}

// Set the optional value of Updatedat dynamically
func (r groupsQueryUpdatedatBigInt) SetIfPresent(value *BigInt) groupsSetParam {
	if value == nil {
		return groupsSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Updatedat
func (r groupsQueryUpdatedatBigInt) Increment(value BigInt) groupsSetParam {
	return groupsSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedatBigInt) IncrementIfPresent(value *BigInt) groupsSetParam {
	if value == nil {
		return groupsSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Updatedat
func (r groupsQueryUpdatedatBigInt) Decrement(value BigInt) groupsSetParam {
	return groupsSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedatBigInt) DecrementIfPresent(value *BigInt) groupsSetParam {
	if value == nil {
		return groupsSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Updatedat
func (r groupsQueryUpdatedatBigInt) Multiply(value BigInt) groupsSetParam {
	return groupsSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedatBigInt) MultiplyIfPresent(value *BigInt) groupsSetParam {
	if value == nil {
		return groupsSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Updatedat
func (r groupsQueryUpdatedatBigInt) Divide(value BigInt) groupsSetParam {
	return groupsSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedatBigInt) DivideIfPresent(value *BigInt) groupsSetParam {
	if value == nil {
		return groupsSetParam{}
	}
	return r.Divide(*value)
}

func (r groupsQueryUpdatedatBigInt) Equals(value BigInt) groupsWithPrismaUpdatedatEqualsParam {

	return groupsWithPrismaUpdatedatEqualsParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedatBigInt) EqualsIfPresent(value *BigInt) groupsWithPrismaUpdatedatEqualsParam {
	if value == nil {
		return groupsWithPrismaUpdatedatEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupsQueryUpdatedatBigInt) Order(direction SortOrder) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: direction,
		},
	}
}

func (r groupsQueryUpdatedatBigInt) Cursor(cursor BigInt) groupsCursorParam {
	return groupsCursorParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: cursor,
		},
	}
}

func (r groupsQueryUpdatedatBigInt) In(value []BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedatBigInt) InIfPresent(value []BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.In(value)
}

func (r groupsQueryUpdatedatBigInt) NotIn(value []BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedatBigInt) NotInIfPresent(value []BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupsQueryUpdatedatBigInt) Lt(value BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedatBigInt) LtIfPresent(value *BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupsQueryUpdatedatBigInt) Lte(value BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedatBigInt) LteIfPresent(value *BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupsQueryUpdatedatBigInt) Gt(value BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedatBigInt) GtIfPresent(value *BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupsQueryUpdatedatBigInt) Gte(value BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedatBigInt) GteIfPresent(value *BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupsQueryUpdatedatBigInt) Not(value BigInt) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedatBigInt) NotIfPresent(value *BigInt) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Not(*value)
}

func (r groupsQueryUpdatedatBigInt) Field() groupsPrismaFields {
	return groupsFieldUpdatedat
}

// base struct
type groupsQueryUpdatedbyString struct{}

// Set the required value of Updatedby
func (r groupsQueryUpdatedbyString) Set(value string) groupsWithPrismaUpdatedbySetParam {

	return groupsWithPrismaUpdatedbySetParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: value,
		},
	}

}

// Set the optional value of Updatedby dynamically
func (r groupsQueryUpdatedbyString) SetIfPresent(value *String) groupsWithPrismaUpdatedbySetParam {
	if value == nil {
		return groupsWithPrismaUpdatedbySetParam{}
	}

	return r.Set(*value)
}

func (r groupsQueryUpdatedbyString) Equals(value string) groupsWithPrismaUpdatedbyEqualsParam {

	return groupsWithPrismaUpdatedbyEqualsParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedbyString) EqualsIfPresent(value *string) groupsWithPrismaUpdatedbyEqualsParam {
	if value == nil {
		return groupsWithPrismaUpdatedbyEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupsQueryUpdatedbyString) Order(direction SortOrder) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: direction,
		},
	}
}

func (r groupsQueryUpdatedbyString) Cursor(cursor string) groupsCursorParam {
	return groupsCursorParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: cursor,
		},
	}
}

func (r groupsQueryUpdatedbyString) In(value []string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedbyString) InIfPresent(value []string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.In(value)
}

func (r groupsQueryUpdatedbyString) NotIn(value []string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedbyString) NotInIfPresent(value []string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupsQueryUpdatedbyString) Lt(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedbyString) LtIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupsQueryUpdatedbyString) Lte(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedbyString) LteIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupsQueryUpdatedbyString) Gt(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedbyString) GtIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupsQueryUpdatedbyString) Gte(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedbyString) GteIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupsQueryUpdatedbyString) Contains(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedbyString) ContainsIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r groupsQueryUpdatedbyString) StartsWith(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedbyString) StartsWithIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r groupsQueryUpdatedbyString) EndsWith(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedbyString) EndsWithIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r groupsQueryUpdatedbyString) Mode(value QueryMode) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedbyString) ModeIfPresent(value *QueryMode) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r groupsQueryUpdatedbyString) Not(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupsQueryUpdatedbyString) NotIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupsQueryUpdatedbyString) HasPrefix(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupsQueryUpdatedbyString) HasPrefixIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupsQueryUpdatedbyString) HasSuffix(value string) groupsDefaultParam {
	return groupsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupsQueryUpdatedbyString) HasSuffixIfPresent(value *string) groupsDefaultParam {
	if value == nil {
		return groupsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r groupsQueryUpdatedbyString) Field() groupsPrismaFields {
	return groupsFieldUpdatedby
}

// base struct
type groupsQueryGroupdevicesgroupdevices struct{}

type groupsQueryGroupdevicesRelations struct{}

// Groups -> Groupdevices
//
// @relation
// @required
func (groupsQueryGroupdevicesRelations) Some(
	params ...GroupdevicesWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Groups -> Groupdevices
//
// @relation
// @required
func (groupsQueryGroupdevicesRelations) Every(
	params ...GroupdevicesWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Groups -> Groupdevices
//
// @relation
// @required
func (groupsQueryGroupdevicesRelations) None(
	params ...GroupdevicesWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (groupsQueryGroupdevicesRelations) Fetch(

	params ...GroupdevicesWhereParam,

) groupsToGroupdevicesFindMany {
	var v groupsToGroupdevicesFindMany

	v.query.Operation = "query"
	v.query.Method = "groupdevices"
	v.query.Outputs = groupdevicesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r groupsQueryGroupdevicesRelations) Link(
	params ...GroupdevicesWhereParam,
) groupsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsSetParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r groupsQueryGroupdevicesRelations) Unlink(
	params ...GroupdevicesWhereParam,
) groupsSetParam {
	var v groupsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = groupsSetParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r groupsQueryGroupdevicesgroupdevices) Field() groupsPrismaFields {
	return groupsFieldGroupdevices
}

// base struct
type groupsQueryOrgsorgs struct{}

type groupsQueryOrgsRelations struct{}

// Groups -> Orgs
//
// @relation
// @required
func (groupsQueryOrgsRelations) Where(
	params ...OrgsWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (groupsQueryOrgsRelations) Fetch() groupsToOrgsFindUnique {
	var v groupsToOrgsFindUnique

	v.query.Operation = "query"
	v.query.Method = "orgs"
	v.query.Outputs = orgsOutput

	return v
}

func (r groupsQueryOrgsRelations) Link(
	params OrgsWhereParam,
) groupsWithPrismaOrgsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return groupsWithPrismaOrgsSetParam{}
	}

	fields = append(fields, f)

	return groupsWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r groupsQueryOrgsRelations) Unlink() groupsWithPrismaOrgsSetParam {
	var v groupsWithPrismaOrgsSetParam

	v = groupsWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r groupsQueryOrgsorgs) Field() groupsPrismaFields {
	return groupsFieldOrgs
}

// base struct
type groupsQueryGrouptreeGrouptreeGroupidTogroupsgrouptree struct{}

type groupsQueryGrouptreeGrouptreeGroupidTogroupsRelations struct{}

// Groups -> GrouptreeGrouptreeGroupidTogroups
//
// @relation
// @required
func (groupsQueryGrouptreeGrouptreeGroupidTogroupsRelations) Some(
	params ...GrouptreeWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "grouptree_grouptree_groupidTogroups",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Groups -> GrouptreeGrouptreeGroupidTogroups
//
// @relation
// @required
func (groupsQueryGrouptreeGrouptreeGroupidTogroupsRelations) Every(
	params ...GrouptreeWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "grouptree_grouptree_groupidTogroups",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Groups -> GrouptreeGrouptreeGroupidTogroups
//
// @relation
// @required
func (groupsQueryGrouptreeGrouptreeGroupidTogroupsRelations) None(
	params ...GrouptreeWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "grouptree_grouptree_groupidTogroups",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (groupsQueryGrouptreeGrouptreeGroupidTogroupsRelations) Fetch(

	params ...GrouptreeWhereParam,

) groupsToGrouptreeGrouptreeGroupidTogroupsFindMany {
	var v groupsToGrouptreeGrouptreeGroupidTogroupsFindMany

	v.query.Operation = "query"
	v.query.Method = "grouptree_grouptree_groupidTogroups"
	v.query.Outputs = grouptreeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r groupsQueryGrouptreeGrouptreeGroupidTogroupsRelations) Link(
	params ...GrouptreeWhereParam,
) groupsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsSetParam{
		data: builder.Field{
			Name: "grouptree_grouptree_groupidTogroups",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r groupsQueryGrouptreeGrouptreeGroupidTogroupsRelations) Unlink(
	params ...GrouptreeWhereParam,
) groupsSetParam {
	var v groupsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = groupsSetParam{
		data: builder.Field{
			Name: "grouptree_grouptree_groupidTogroups",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r groupsQueryGrouptreeGrouptreeGroupidTogroupsgrouptree) Field() groupsPrismaFields {
	return groupsFieldGrouptreeGrouptreeGroupidTogroups
}

// base struct
type groupsQueryGrouptreeGrouptreePgroupidTogroupsgrouptree struct{}

type groupsQueryGrouptreeGrouptreePgroupidTogroupsRelations struct{}

// Groups -> GrouptreeGrouptreePgroupidTogroups
//
// @relation
// @required
func (groupsQueryGrouptreeGrouptreePgroupidTogroupsRelations) Some(
	params ...GrouptreeWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "grouptree_grouptree_pgroupidTogroups",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Groups -> GrouptreeGrouptreePgroupidTogroups
//
// @relation
// @required
func (groupsQueryGrouptreeGrouptreePgroupidTogroupsRelations) Every(
	params ...GrouptreeWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "grouptree_grouptree_pgroupidTogroups",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Groups -> GrouptreeGrouptreePgroupidTogroups
//
// @relation
// @required
func (groupsQueryGrouptreeGrouptreePgroupidTogroupsRelations) None(
	params ...GrouptreeWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "grouptree_grouptree_pgroupidTogroups",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (groupsQueryGrouptreeGrouptreePgroupidTogroupsRelations) Fetch(

	params ...GrouptreeWhereParam,

) groupsToGrouptreeGrouptreePgroupidTogroupsFindMany {
	var v groupsToGrouptreeGrouptreePgroupidTogroupsFindMany

	v.query.Operation = "query"
	v.query.Method = "grouptree_grouptree_pgroupidTogroups"
	v.query.Outputs = grouptreeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r groupsQueryGrouptreeGrouptreePgroupidTogroupsRelations) Link(
	params ...GrouptreeWhereParam,
) groupsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsSetParam{
		data: builder.Field{
			Name: "grouptree_grouptree_pgroupidTogroups",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r groupsQueryGrouptreeGrouptreePgroupidTogroupsRelations) Unlink(
	params ...GrouptreeWhereParam,
) groupsSetParam {
	var v groupsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = groupsSetParam{
		data: builder.Field{
			Name: "grouptree_grouptree_pgroupidTogroups",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r groupsQueryGrouptreeGrouptreePgroupidTogroupsgrouptree) Field() groupsPrismaFields {
	return groupsFieldGrouptreeGrouptreePgroupidTogroups
}

// base struct
type groupsQueryGroupuserpermsgroupuserperms struct{}

type groupsQueryGroupuserpermsRelations struct{}

// Groups -> Groupuserperms
//
// @relation
// @required
func (groupsQueryGroupuserpermsRelations) Some(
	params ...GroupuserpermsWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Groups -> Groupuserperms
//
// @relation
// @required
func (groupsQueryGroupuserpermsRelations) Every(
	params ...GroupuserpermsWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Groups -> Groupuserperms
//
// @relation
// @required
func (groupsQueryGroupuserpermsRelations) None(
	params ...GroupuserpermsWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (groupsQueryGroupuserpermsRelations) Fetch(

	params ...GroupuserpermsWhereParam,

) groupsToGroupuserpermsFindMany {
	var v groupsToGroupuserpermsFindMany

	v.query.Operation = "query"
	v.query.Method = "groupuserperms"
	v.query.Outputs = groupuserpermsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r groupsQueryGroupuserpermsRelations) Link(
	params ...GroupuserpermsWhereParam,
) groupsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsSetParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r groupsQueryGroupuserpermsRelations) Unlink(
	params ...GroupuserpermsWhereParam,
) groupsSetParam {
	var v groupsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = groupsSetParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r groupsQueryGroupuserpermsgroupuserperms) Field() groupsPrismaFields {
	return groupsFieldGroupuserperms
}

// base struct
type groupsQueryOrgrgrouporgrgroup struct{}

type groupsQueryOrgrgroupRelations struct{}

// Groups -> Orgrgroup
//
// @relation
// @required
func (groupsQueryOrgrgroupRelations) Some(
	params ...OrgrgroupWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgrgroup",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Groups -> Orgrgroup
//
// @relation
// @required
func (groupsQueryOrgrgroupRelations) Every(
	params ...OrgrgroupWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgrgroup",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Groups -> Orgrgroup
//
// @relation
// @required
func (groupsQueryOrgrgroupRelations) None(
	params ...OrgrgroupWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "orgrgroup",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (groupsQueryOrgrgroupRelations) Fetch(

	params ...OrgrgroupWhereParam,

) groupsToOrgrgroupFindMany {
	var v groupsToOrgrgroupFindMany

	v.query.Operation = "query"
	v.query.Method = "orgrgroup"
	v.query.Outputs = orgrgroupOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r groupsQueryOrgrgroupRelations) Link(
	params ...OrgrgroupWhereParam,
) groupsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsSetParam{
		data: builder.Field{
			Name: "orgrgroup",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r groupsQueryOrgrgroupRelations) Unlink(
	params ...OrgrgroupWhereParam,
) groupsSetParam {
	var v groupsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = groupsSetParam{
		data: builder.Field{
			Name: "orgrgroup",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r groupsQueryOrgrgrouporgrgroup) Field() groupsPrismaFields {
	return groupsFieldOrgrgroup
}

// base struct
type groupsQueryUsergroupusergroup struct{}

type groupsQueryUsergroupRelations struct{}

// Groups -> Usergroup
//
// @relation
// @required
func (groupsQueryUsergroupRelations) Some(
	params ...UsergroupWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Groups -> Usergroup
//
// @relation
// @required
func (groupsQueryUsergroupRelations) Every(
	params ...UsergroupWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Groups -> Usergroup
//
// @relation
// @required
func (groupsQueryUsergroupRelations) None(
	params ...UsergroupWhereParam,
) groupsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsDefaultParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (groupsQueryUsergroupRelations) Fetch(

	params ...UsergroupWhereParam,

) groupsToUsergroupFindMany {
	var v groupsToUsergroupFindMany

	v.query.Operation = "query"
	v.query.Method = "usergroup"
	v.query.Outputs = usergroupOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r groupsQueryUsergroupRelations) Link(
	params ...UsergroupWhereParam,
) groupsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupsSetParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r groupsQueryUsergroupRelations) Unlink(
	params ...UsergroupWhereParam,
) groupsSetParam {
	var v groupsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = groupsSetParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r groupsQueryUsergroupusergroup) Field() groupsPrismaFields {
	return groupsFieldUsergroup
}

// Grouptree acts as a namespaces to access query methods for the Grouptree model
var Grouptree = grouptreeQuery{}

// grouptreeQuery exposes query functions for the grouptree model
type grouptreeQuery struct {

	// Orgid
	//
	// @required
	Orgid grouptreeQueryOrgidString

	// Pgroupid
	//
	// @required
	Pgroupid grouptreeQueryPgroupidString

	// Groupid
	//
	// @required
	Groupid grouptreeQueryGroupidString

	// Name
	//
	// @required
	Name grouptreeQueryNameString

	GroupsGrouptreeGroupidTogroups grouptreeQueryGroupsGrouptreeGroupidTogroupsRelations

	Orgs grouptreeQueryOrgsRelations

	GroupsGrouptreePgroupidTogroups grouptreeQueryGroupsGrouptreePgroupidTogroupsRelations
}

func (grouptreeQuery) Not(params ...GrouptreeWhereParam) grouptreeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return grouptreeDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (grouptreeQuery) Or(params ...GrouptreeWhereParam) grouptreeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return grouptreeDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (grouptreeQuery) And(params ...GrouptreeWhereParam) grouptreeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return grouptreeDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (grouptreeQuery) OrgidPgroupidName(
	_orgid GrouptreeWithPrismaOrgidWhereParam,

	_pgroupid GrouptreeWithPrismaPgroupidWhereParam,

	_name GrouptreeWithPrismaNameWhereParam,
) GrouptreeEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _orgid.field())
	fields = append(fields, _pgroupid.field())
	fields = append(fields, _name.field())

	return grouptreeEqualsUniqueParam{
		data: builder.Field{
			Name:   "orgid_pgroupid_name",
			Fields: builder.TransformEquals(fields),
		},
	}
}

func (grouptreeQuery) OrgidPgroupidGroupid(
	_orgid GrouptreeWithPrismaOrgidWhereParam,

	_pgroupid GrouptreeWithPrismaPgroupidWhereParam,

	_groupid GrouptreeWithPrismaGroupidWhereParam,
) GrouptreeEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _orgid.field())
	fields = append(fields, _pgroupid.field())
	fields = append(fields, _groupid.field())

	return grouptreeEqualsUniqueParam{
		data: builder.Field{
			Name:   "orgid_pgroupid_groupid",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type grouptreeQueryOrgidString struct{}

// Set the required value of Orgid
func (r grouptreeQueryOrgidString) Set(value string) grouptreeSetParam {

	return grouptreeSetParam{
		data: builder.Field{
			Name:  "orgid",
			Value: value,
		},
	}

}

// Set the optional value of Orgid dynamically
func (r grouptreeQueryOrgidString) SetIfPresent(value *String) grouptreeSetParam {
	if value == nil {
		return grouptreeSetParam{}
	}

	return r.Set(*value)
}

func (r grouptreeQueryOrgidString) Equals(value string) grouptreeWithPrismaOrgidEqualsParam {

	return grouptreeWithPrismaOrgidEqualsParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryOrgidString) EqualsIfPresent(value *string) grouptreeWithPrismaOrgidEqualsParam {
	if value == nil {
		return grouptreeWithPrismaOrgidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r grouptreeQueryOrgidString) Order(direction SortOrder) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name:  "orgid",
			Value: direction,
		},
	}
}

func (r grouptreeQueryOrgidString) Cursor(cursor string) grouptreeCursorParam {
	return grouptreeCursorParam{
		data: builder.Field{
			Name:  "orgid",
			Value: cursor,
		},
	}
}

func (r grouptreeQueryOrgidString) In(value []string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryOrgidString) InIfPresent(value []string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.In(value)
}

func (r grouptreeQueryOrgidString) NotIn(value []string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryOrgidString) NotInIfPresent(value []string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r grouptreeQueryOrgidString) Lt(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryOrgidString) LtIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r grouptreeQueryOrgidString) Lte(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryOrgidString) LteIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r grouptreeQueryOrgidString) Gt(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryOrgidString) GtIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r grouptreeQueryOrgidString) Gte(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryOrgidString) GteIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r grouptreeQueryOrgidString) Contains(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryOrgidString) ContainsIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Contains(*value)
}

func (r grouptreeQueryOrgidString) StartsWith(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryOrgidString) StartsWithIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r grouptreeQueryOrgidString) EndsWith(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryOrgidString) EndsWithIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r grouptreeQueryOrgidString) Mode(value QueryMode) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryOrgidString) ModeIfPresent(value *QueryMode) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Mode(*value)
}

func (r grouptreeQueryOrgidString) Not(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryOrgidString) NotIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r grouptreeQueryOrgidString) HasPrefix(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r grouptreeQueryOrgidString) HasPrefixIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r grouptreeQueryOrgidString) HasSuffix(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r grouptreeQueryOrgidString) HasSuffixIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r grouptreeQueryOrgidString) Field() grouptreePrismaFields {
	return grouptreeFieldOrgid
}

// base struct
type grouptreeQueryPgroupidString struct{}

// Set the required value of Pgroupid
func (r grouptreeQueryPgroupidString) Set(value string) grouptreeSetParam {

	return grouptreeSetParam{
		data: builder.Field{
			Name:  "pgroupid",
			Value: value,
		},
	}

}

// Set the optional value of Pgroupid dynamically
func (r grouptreeQueryPgroupidString) SetIfPresent(value *String) grouptreeSetParam {
	if value == nil {
		return grouptreeSetParam{}
	}

	return r.Set(*value)
}

func (r grouptreeQueryPgroupidString) Equals(value string) grouptreeWithPrismaPgroupidEqualsParam {

	return grouptreeWithPrismaPgroupidEqualsParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryPgroupidString) EqualsIfPresent(value *string) grouptreeWithPrismaPgroupidEqualsParam {
	if value == nil {
		return grouptreeWithPrismaPgroupidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r grouptreeQueryPgroupidString) Order(direction SortOrder) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name:  "pgroupid",
			Value: direction,
		},
	}
}

func (r grouptreeQueryPgroupidString) Cursor(cursor string) grouptreeCursorParam {
	return grouptreeCursorParam{
		data: builder.Field{
			Name:  "pgroupid",
			Value: cursor,
		},
	}
}

func (r grouptreeQueryPgroupidString) In(value []string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryPgroupidString) InIfPresent(value []string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.In(value)
}

func (r grouptreeQueryPgroupidString) NotIn(value []string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryPgroupidString) NotInIfPresent(value []string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r grouptreeQueryPgroupidString) Lt(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryPgroupidString) LtIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r grouptreeQueryPgroupidString) Lte(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryPgroupidString) LteIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r grouptreeQueryPgroupidString) Gt(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryPgroupidString) GtIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r grouptreeQueryPgroupidString) Gte(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryPgroupidString) GteIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r grouptreeQueryPgroupidString) Contains(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryPgroupidString) ContainsIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Contains(*value)
}

func (r grouptreeQueryPgroupidString) StartsWith(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryPgroupidString) StartsWithIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r grouptreeQueryPgroupidString) EndsWith(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryPgroupidString) EndsWithIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r grouptreeQueryPgroupidString) Mode(value QueryMode) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryPgroupidString) ModeIfPresent(value *QueryMode) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Mode(*value)
}

func (r grouptreeQueryPgroupidString) Not(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryPgroupidString) NotIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r grouptreeQueryPgroupidString) HasPrefix(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r grouptreeQueryPgroupidString) HasPrefixIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r grouptreeQueryPgroupidString) HasSuffix(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "pgroupid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r grouptreeQueryPgroupidString) HasSuffixIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r grouptreeQueryPgroupidString) Field() grouptreePrismaFields {
	return grouptreeFieldPgroupid
}

// base struct
type grouptreeQueryGroupidString struct{}

// Set the required value of Groupid
func (r grouptreeQueryGroupidString) Set(value string) grouptreeSetParam {

	return grouptreeSetParam{
		data: builder.Field{
			Name:  "groupid",
			Value: value,
		},
	}

}

// Set the optional value of Groupid dynamically
func (r grouptreeQueryGroupidString) SetIfPresent(value *String) grouptreeSetParam {
	if value == nil {
		return grouptreeSetParam{}
	}

	return r.Set(*value)
}

func (r grouptreeQueryGroupidString) Equals(value string) grouptreeWithPrismaGroupidEqualsParam {

	return grouptreeWithPrismaGroupidEqualsParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryGroupidString) EqualsIfPresent(value *string) grouptreeWithPrismaGroupidEqualsParam {
	if value == nil {
		return grouptreeWithPrismaGroupidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r grouptreeQueryGroupidString) Order(direction SortOrder) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name:  "groupid",
			Value: direction,
		},
	}
}

func (r grouptreeQueryGroupidString) Cursor(cursor string) grouptreeCursorParam {
	return grouptreeCursorParam{
		data: builder.Field{
			Name:  "groupid",
			Value: cursor,
		},
	}
}

func (r grouptreeQueryGroupidString) In(value []string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryGroupidString) InIfPresent(value []string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.In(value)
}

func (r grouptreeQueryGroupidString) NotIn(value []string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryGroupidString) NotInIfPresent(value []string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r grouptreeQueryGroupidString) Lt(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryGroupidString) LtIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r grouptreeQueryGroupidString) Lte(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryGroupidString) LteIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r grouptreeQueryGroupidString) Gt(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryGroupidString) GtIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r grouptreeQueryGroupidString) Gte(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryGroupidString) GteIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r grouptreeQueryGroupidString) Contains(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryGroupidString) ContainsIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Contains(*value)
}

func (r grouptreeQueryGroupidString) StartsWith(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryGroupidString) StartsWithIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r grouptreeQueryGroupidString) EndsWith(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryGroupidString) EndsWithIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r grouptreeQueryGroupidString) Mode(value QueryMode) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryGroupidString) ModeIfPresent(value *QueryMode) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Mode(*value)
}

func (r grouptreeQueryGroupidString) Not(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryGroupidString) NotIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r grouptreeQueryGroupidString) HasPrefix(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r grouptreeQueryGroupidString) HasPrefixIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r grouptreeQueryGroupidString) HasSuffix(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r grouptreeQueryGroupidString) HasSuffixIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r grouptreeQueryGroupidString) Field() grouptreePrismaFields {
	return grouptreeFieldGroupid
}

// base struct
type grouptreeQueryNameString struct{}

// Set the required value of Name
func (r grouptreeQueryNameString) Set(value string) grouptreeWithPrismaNameSetParam {

	return grouptreeWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r grouptreeQueryNameString) SetIfPresent(value *String) grouptreeWithPrismaNameSetParam {
	if value == nil {
		return grouptreeWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r grouptreeQueryNameString) Equals(value string) grouptreeWithPrismaNameEqualsParam {

	return grouptreeWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryNameString) EqualsIfPresent(value *string) grouptreeWithPrismaNameEqualsParam {
	if value == nil {
		return grouptreeWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r grouptreeQueryNameString) Order(direction SortOrder) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r grouptreeQueryNameString) Cursor(cursor string) grouptreeCursorParam {
	return grouptreeCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r grouptreeQueryNameString) In(value []string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryNameString) InIfPresent(value []string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.In(value)
}

func (r grouptreeQueryNameString) NotIn(value []string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryNameString) NotInIfPresent(value []string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.NotIn(value)
}

func (r grouptreeQueryNameString) Lt(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryNameString) LtIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Lt(*value)
}

func (r grouptreeQueryNameString) Lte(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryNameString) LteIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Lte(*value)
}

func (r grouptreeQueryNameString) Gt(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryNameString) GtIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Gt(*value)
}

func (r grouptreeQueryNameString) Gte(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryNameString) GteIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Gte(*value)
}

func (r grouptreeQueryNameString) Contains(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryNameString) ContainsIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Contains(*value)
}

func (r grouptreeQueryNameString) StartsWith(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryNameString) StartsWithIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r grouptreeQueryNameString) EndsWith(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryNameString) EndsWithIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r grouptreeQueryNameString) Mode(value QueryMode) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryNameString) ModeIfPresent(value *QueryMode) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Mode(*value)
}

func (r grouptreeQueryNameString) Not(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r grouptreeQueryNameString) NotIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r grouptreeQueryNameString) HasPrefix(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r grouptreeQueryNameString) HasPrefixIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r grouptreeQueryNameString) HasSuffix(value string) grouptreeDefaultParam {
	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r grouptreeQueryNameString) HasSuffixIfPresent(value *string) grouptreeDefaultParam {
	if value == nil {
		return grouptreeDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r grouptreeQueryNameString) Field() grouptreePrismaFields {
	return grouptreeFieldName
}

// base struct
type grouptreeQueryGroupsGrouptreeGroupidTogroupsgroups struct{}

type grouptreeQueryGroupsGrouptreeGroupidTogroupsRelations struct{}

// Grouptree -> GroupsGrouptreeGroupidTogroups
//
// @relation
// @required
func (grouptreeQueryGroupsGrouptreeGroupidTogroupsRelations) Where(
	params ...GroupsWhereParam,
) grouptreeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groups_grouptree_groupidTogroups",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (grouptreeQueryGroupsGrouptreeGroupidTogroupsRelations) Fetch() grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique {
	var v grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique

	v.query.Operation = "query"
	v.query.Method = "groups_grouptree_groupidTogroups"
	v.query.Outputs = groupsOutput

	return v
}

func (r grouptreeQueryGroupsGrouptreeGroupidTogroupsRelations) Link(
	params GroupsWhereParam,
) grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam{}
	}

	fields = append(fields, f)

	return grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam{
		data: builder.Field{
			Name: "groups_grouptree_groupidTogroups",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r grouptreeQueryGroupsGrouptreeGroupidTogroupsRelations) Unlink() grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam {
	var v grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam

	v = grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam{
		data: builder.Field{
			Name: "groups_grouptree_groupidTogroups",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r grouptreeQueryGroupsGrouptreeGroupidTogroupsgroups) Field() grouptreePrismaFields {
	return grouptreeFieldGroupsGrouptreeGroupidTogroups
}

// base struct
type grouptreeQueryOrgsorgs struct{}

type grouptreeQueryOrgsRelations struct{}

// Grouptree -> Orgs
//
// @relation
// @required
func (grouptreeQueryOrgsRelations) Where(
	params ...OrgsWhereParam,
) grouptreeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (grouptreeQueryOrgsRelations) Fetch() grouptreeToOrgsFindUnique {
	var v grouptreeToOrgsFindUnique

	v.query.Operation = "query"
	v.query.Method = "orgs"
	v.query.Outputs = orgsOutput

	return v
}

func (r grouptreeQueryOrgsRelations) Link(
	params OrgsWhereParam,
) grouptreeWithPrismaOrgsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return grouptreeWithPrismaOrgsSetParam{}
	}

	fields = append(fields, f)

	return grouptreeWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r grouptreeQueryOrgsRelations) Unlink() grouptreeWithPrismaOrgsSetParam {
	var v grouptreeWithPrismaOrgsSetParam

	v = grouptreeWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r grouptreeQueryOrgsorgs) Field() grouptreePrismaFields {
	return grouptreeFieldOrgs
}

// base struct
type grouptreeQueryGroupsGrouptreePgroupidTogroupsgroups struct{}

type grouptreeQueryGroupsGrouptreePgroupidTogroupsRelations struct{}

// Grouptree -> GroupsGrouptreePgroupidTogroups
//
// @relation
// @required
func (grouptreeQueryGroupsGrouptreePgroupidTogroupsRelations) Where(
	params ...GroupsWhereParam,
) grouptreeDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return grouptreeDefaultParam{
		data: builder.Field{
			Name: "groups_grouptree_pgroupidTogroups",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (grouptreeQueryGroupsGrouptreePgroupidTogroupsRelations) Fetch() grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique {
	var v grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique

	v.query.Operation = "query"
	v.query.Method = "groups_grouptree_pgroupidTogroups"
	v.query.Outputs = groupsOutput

	return v
}

func (r grouptreeQueryGroupsGrouptreePgroupidTogroupsRelations) Link(
	params GroupsWhereParam,
) grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam{}
	}

	fields = append(fields, f)

	return grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam{
		data: builder.Field{
			Name: "groups_grouptree_pgroupidTogroups",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r grouptreeQueryGroupsGrouptreePgroupidTogroupsRelations) Unlink() grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam {
	var v grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam

	v = grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam{
		data: builder.Field{
			Name: "groups_grouptree_pgroupidTogroups",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r grouptreeQueryGroupsGrouptreePgroupidTogroupsgroups) Field() grouptreePrismaFields {
	return grouptreeFieldGroupsGrouptreePgroupidTogroups
}

// Groupuserperms acts as a namespaces to access query methods for the Groupuserperms model
var Groupuserperms = groupuserpermsQuery{}

// groupuserpermsQuery exposes query functions for the groupuserperms model
type groupuserpermsQuery struct {

	// Orgid
	//
	// @required
	Orgid groupuserpermsQueryOrgidString

	// Groupid
	//
	// @required
	Groupid groupuserpermsQueryGroupidString

	// Userid
	//
	// @required
	Userid groupuserpermsQueryUseridString

	// Permid
	//
	// @required
	Permid groupuserpermsQueryPermidString

	Groups groupuserpermsQueryGroupsRelations

	Orgs groupuserpermsQueryOrgsRelations

	Users groupuserpermsQueryUsersRelations
}

func (groupuserpermsQuery) Not(params ...GroupuserpermsWhereParam) groupuserpermsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (groupuserpermsQuery) Or(params ...GroupuserpermsWhereParam) groupuserpermsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (groupuserpermsQuery) And(params ...GroupuserpermsWhereParam) groupuserpermsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (groupuserpermsQuery) OrgidGroupidUseridPermid(
	_orgid GroupuserpermsWithPrismaOrgidWhereParam,

	_groupid GroupuserpermsWithPrismaGroupidWhereParam,

	_userid GroupuserpermsWithPrismaUseridWhereParam,

	_permid GroupuserpermsWithPrismaPermidWhereParam,
) GroupuserpermsEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _orgid.field())
	fields = append(fields, _groupid.field())
	fields = append(fields, _userid.field())
	fields = append(fields, _permid.field())

	return groupuserpermsEqualsUniqueParam{
		data: builder.Field{
			Name:   "orgid_groupid_userid_permid",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type groupuserpermsQueryOrgidString struct{}

// Set the required value of Orgid
func (r groupuserpermsQueryOrgidString) Set(value string) groupuserpermsSetParam {

	return groupuserpermsSetParam{
		data: builder.Field{
			Name:  "orgid",
			Value: value,
		},
	}

}

// Set the optional value of Orgid dynamically
func (r groupuserpermsQueryOrgidString) SetIfPresent(value *String) groupuserpermsSetParam {
	if value == nil {
		return groupuserpermsSetParam{}
	}

	return r.Set(*value)
}

func (r groupuserpermsQueryOrgidString) Equals(value string) groupuserpermsWithPrismaOrgidEqualsParam {

	return groupuserpermsWithPrismaOrgidEqualsParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgidString) EqualsIfPresent(value *string) groupuserpermsWithPrismaOrgidEqualsParam {
	if value == nil {
		return groupuserpermsWithPrismaOrgidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupuserpermsQueryOrgidString) Order(direction SortOrder) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name:  "orgid",
			Value: direction,
		},
	}
}

func (r groupuserpermsQueryOrgidString) Cursor(cursor string) groupuserpermsCursorParam {
	return groupuserpermsCursorParam{
		data: builder.Field{
			Name:  "orgid",
			Value: cursor,
		},
	}
}

func (r groupuserpermsQueryOrgidString) In(value []string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgidString) InIfPresent(value []string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.In(value)
}

func (r groupuserpermsQueryOrgidString) NotIn(value []string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgidString) NotInIfPresent(value []string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupuserpermsQueryOrgidString) Lt(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgidString) LtIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupuserpermsQueryOrgidString) Lte(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgidString) LteIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupuserpermsQueryOrgidString) Gt(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgidString) GtIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupuserpermsQueryOrgidString) Gte(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgidString) GteIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupuserpermsQueryOrgidString) Contains(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgidString) ContainsIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r groupuserpermsQueryOrgidString) StartsWith(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgidString) StartsWithIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r groupuserpermsQueryOrgidString) EndsWith(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgidString) EndsWithIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r groupuserpermsQueryOrgidString) Mode(value QueryMode) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgidString) ModeIfPresent(value *QueryMode) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r groupuserpermsQueryOrgidString) Not(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgidString) NotIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupuserpermsQueryOrgidString) HasPrefix(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupuserpermsQueryOrgidString) HasPrefixIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupuserpermsQueryOrgidString) HasSuffix(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupuserpermsQueryOrgidString) HasSuffixIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r groupuserpermsQueryOrgidString) Field() groupuserpermsPrismaFields {
	return groupuserpermsFieldOrgid
}

// base struct
type groupuserpermsQueryGroupidString struct{}

// Set the required value of Groupid
func (r groupuserpermsQueryGroupidString) Set(value string) groupuserpermsSetParam {

	return groupuserpermsSetParam{
		data: builder.Field{
			Name:  "groupid",
			Value: value,
		},
	}

}

// Set the optional value of Groupid dynamically
func (r groupuserpermsQueryGroupidString) SetIfPresent(value *String) groupuserpermsSetParam {
	if value == nil {
		return groupuserpermsSetParam{}
	}

	return r.Set(*value)
}

func (r groupuserpermsQueryGroupidString) Equals(value string) groupuserpermsWithPrismaGroupidEqualsParam {

	return groupuserpermsWithPrismaGroupidEqualsParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupidString) EqualsIfPresent(value *string) groupuserpermsWithPrismaGroupidEqualsParam {
	if value == nil {
		return groupuserpermsWithPrismaGroupidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupuserpermsQueryGroupidString) Order(direction SortOrder) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name:  "groupid",
			Value: direction,
		},
	}
}

func (r groupuserpermsQueryGroupidString) Cursor(cursor string) groupuserpermsCursorParam {
	return groupuserpermsCursorParam{
		data: builder.Field{
			Name:  "groupid",
			Value: cursor,
		},
	}
}

func (r groupuserpermsQueryGroupidString) In(value []string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupidString) InIfPresent(value []string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.In(value)
}

func (r groupuserpermsQueryGroupidString) NotIn(value []string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupidString) NotInIfPresent(value []string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupuserpermsQueryGroupidString) Lt(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupidString) LtIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupuserpermsQueryGroupidString) Lte(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupidString) LteIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupuserpermsQueryGroupidString) Gt(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupidString) GtIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupuserpermsQueryGroupidString) Gte(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupidString) GteIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupuserpermsQueryGroupidString) Contains(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupidString) ContainsIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r groupuserpermsQueryGroupidString) StartsWith(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupidString) StartsWithIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r groupuserpermsQueryGroupidString) EndsWith(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupidString) EndsWithIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r groupuserpermsQueryGroupidString) Mode(value QueryMode) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupidString) ModeIfPresent(value *QueryMode) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r groupuserpermsQueryGroupidString) Not(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupidString) NotIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupuserpermsQueryGroupidString) HasPrefix(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupuserpermsQueryGroupidString) HasPrefixIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupuserpermsQueryGroupidString) HasSuffix(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupuserpermsQueryGroupidString) HasSuffixIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r groupuserpermsQueryGroupidString) Field() groupuserpermsPrismaFields {
	return groupuserpermsFieldGroupid
}

// base struct
type groupuserpermsQueryUseridString struct{}

// Set the required value of Userid
func (r groupuserpermsQueryUseridString) Set(value string) groupuserpermsSetParam {

	return groupuserpermsSetParam{
		data: builder.Field{
			Name:  "userid",
			Value: value,
		},
	}

}

// Set the optional value of Userid dynamically
func (r groupuserpermsQueryUseridString) SetIfPresent(value *String) groupuserpermsSetParam {
	if value == nil {
		return groupuserpermsSetParam{}
	}

	return r.Set(*value)
}

func (r groupuserpermsQueryUseridString) Equals(value string) groupuserpermsWithPrismaUseridEqualsParam {

	return groupuserpermsWithPrismaUseridEqualsParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryUseridString) EqualsIfPresent(value *string) groupuserpermsWithPrismaUseridEqualsParam {
	if value == nil {
		return groupuserpermsWithPrismaUseridEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupuserpermsQueryUseridString) Order(direction SortOrder) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name:  "userid",
			Value: direction,
		},
	}
}

func (r groupuserpermsQueryUseridString) Cursor(cursor string) groupuserpermsCursorParam {
	return groupuserpermsCursorParam{
		data: builder.Field{
			Name:  "userid",
			Value: cursor,
		},
	}
}

func (r groupuserpermsQueryUseridString) In(value []string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryUseridString) InIfPresent(value []string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.In(value)
}

func (r groupuserpermsQueryUseridString) NotIn(value []string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryUseridString) NotInIfPresent(value []string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupuserpermsQueryUseridString) Lt(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryUseridString) LtIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupuserpermsQueryUseridString) Lte(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryUseridString) LteIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupuserpermsQueryUseridString) Gt(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryUseridString) GtIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupuserpermsQueryUseridString) Gte(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryUseridString) GteIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupuserpermsQueryUseridString) Contains(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryUseridString) ContainsIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r groupuserpermsQueryUseridString) StartsWith(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryUseridString) StartsWithIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r groupuserpermsQueryUseridString) EndsWith(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryUseridString) EndsWithIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r groupuserpermsQueryUseridString) Mode(value QueryMode) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryUseridString) ModeIfPresent(value *QueryMode) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r groupuserpermsQueryUseridString) Not(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryUseridString) NotIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupuserpermsQueryUseridString) HasPrefix(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupuserpermsQueryUseridString) HasPrefixIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupuserpermsQueryUseridString) HasSuffix(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupuserpermsQueryUseridString) HasSuffixIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r groupuserpermsQueryUseridString) Field() groupuserpermsPrismaFields {
	return groupuserpermsFieldUserid
}

// base struct
type groupuserpermsQueryPermidString struct{}

// Set the required value of Permid
func (r groupuserpermsQueryPermidString) Set(value string) groupuserpermsWithPrismaPermidSetParam {

	return groupuserpermsWithPrismaPermidSetParam{
		data: builder.Field{
			Name:  "permid",
			Value: value,
		},
	}

}

// Set the optional value of Permid dynamically
func (r groupuserpermsQueryPermidString) SetIfPresent(value *String) groupuserpermsWithPrismaPermidSetParam {
	if value == nil {
		return groupuserpermsWithPrismaPermidSetParam{}
	}

	return r.Set(*value)
}

func (r groupuserpermsQueryPermidString) Equals(value string) groupuserpermsWithPrismaPermidEqualsParam {

	return groupuserpermsWithPrismaPermidEqualsParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryPermidString) EqualsIfPresent(value *string) groupuserpermsWithPrismaPermidEqualsParam {
	if value == nil {
		return groupuserpermsWithPrismaPermidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r groupuserpermsQueryPermidString) Order(direction SortOrder) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name:  "permid",
			Value: direction,
		},
	}
}

func (r groupuserpermsQueryPermidString) Cursor(cursor string) groupuserpermsCursorParam {
	return groupuserpermsCursorParam{
		data: builder.Field{
			Name:  "permid",
			Value: cursor,
		},
	}
}

func (r groupuserpermsQueryPermidString) In(value []string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryPermidString) InIfPresent(value []string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.In(value)
}

func (r groupuserpermsQueryPermidString) NotIn(value []string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryPermidString) NotInIfPresent(value []string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r groupuserpermsQueryPermidString) Lt(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryPermidString) LtIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r groupuserpermsQueryPermidString) Lte(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryPermidString) LteIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r groupuserpermsQueryPermidString) Gt(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryPermidString) GtIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r groupuserpermsQueryPermidString) Gte(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryPermidString) GteIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r groupuserpermsQueryPermidString) Contains(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryPermidString) ContainsIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r groupuserpermsQueryPermidString) StartsWith(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryPermidString) StartsWithIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r groupuserpermsQueryPermidString) EndsWith(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryPermidString) EndsWithIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r groupuserpermsQueryPermidString) Mode(value QueryMode) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryPermidString) ModeIfPresent(value *QueryMode) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r groupuserpermsQueryPermidString) Not(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r groupuserpermsQueryPermidString) NotIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r groupuserpermsQueryPermidString) HasPrefix(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r groupuserpermsQueryPermidString) HasPrefixIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r groupuserpermsQueryPermidString) HasSuffix(value string) groupuserpermsDefaultParam {
	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "permid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r groupuserpermsQueryPermidString) HasSuffixIfPresent(value *string) groupuserpermsDefaultParam {
	if value == nil {
		return groupuserpermsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r groupuserpermsQueryPermidString) Field() groupuserpermsPrismaFields {
	return groupuserpermsFieldPermid
}

// base struct
type groupuserpermsQueryGroupsgroups struct{}

type groupuserpermsQueryGroupsRelations struct{}

// Groupuserperms -> Groups
//
// @relation
// @required
func (groupuserpermsQueryGroupsRelations) Where(
	params ...GroupsWhereParam,
) groupuserpermsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (groupuserpermsQueryGroupsRelations) Fetch() groupuserpermsToGroupsFindUnique {
	var v groupuserpermsToGroupsFindUnique

	v.query.Operation = "query"
	v.query.Method = "groups"
	v.query.Outputs = groupsOutput

	return v
}

func (r groupuserpermsQueryGroupsRelations) Link(
	params GroupsWhereParam,
) groupuserpermsWithPrismaGroupsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return groupuserpermsWithPrismaGroupsSetParam{}
	}

	fields = append(fields, f)

	return groupuserpermsWithPrismaGroupsSetParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r groupuserpermsQueryGroupsRelations) Unlink() groupuserpermsWithPrismaGroupsSetParam {
	var v groupuserpermsWithPrismaGroupsSetParam

	v = groupuserpermsWithPrismaGroupsSetParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r groupuserpermsQueryGroupsgroups) Field() groupuserpermsPrismaFields {
	return groupuserpermsFieldGroups
}

// base struct
type groupuserpermsQueryOrgsorgs struct{}

type groupuserpermsQueryOrgsRelations struct{}

// Groupuserperms -> Orgs
//
// @relation
// @required
func (groupuserpermsQueryOrgsRelations) Where(
	params ...OrgsWhereParam,
) groupuserpermsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (groupuserpermsQueryOrgsRelations) Fetch() groupuserpermsToOrgsFindUnique {
	var v groupuserpermsToOrgsFindUnique

	v.query.Operation = "query"
	v.query.Method = "orgs"
	v.query.Outputs = orgsOutput

	return v
}

func (r groupuserpermsQueryOrgsRelations) Link(
	params OrgsWhereParam,
) groupuserpermsWithPrismaOrgsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return groupuserpermsWithPrismaOrgsSetParam{}
	}

	fields = append(fields, f)

	return groupuserpermsWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r groupuserpermsQueryOrgsRelations) Unlink() groupuserpermsWithPrismaOrgsSetParam {
	var v groupuserpermsWithPrismaOrgsSetParam

	v = groupuserpermsWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r groupuserpermsQueryOrgsorgs) Field() groupuserpermsPrismaFields {
	return groupuserpermsFieldOrgs
}

// base struct
type groupuserpermsQueryUsersusers struct{}

type groupuserpermsQueryUsersRelations struct{}

// Groupuserperms -> Users
//
// @relation
// @required
func (groupuserpermsQueryUsersRelations) Where(
	params ...UsersWhereParam,
) groupuserpermsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return groupuserpermsDefaultParam{
		data: builder.Field{
			Name: "users",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (groupuserpermsQueryUsersRelations) Fetch() groupuserpermsToUsersFindUnique {
	var v groupuserpermsToUsersFindUnique

	v.query.Operation = "query"
	v.query.Method = "users"
	v.query.Outputs = usersOutput

	return v
}

func (r groupuserpermsQueryUsersRelations) Link(
	params UsersWhereParam,
) groupuserpermsWithPrismaUsersSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return groupuserpermsWithPrismaUsersSetParam{}
	}

	fields = append(fields, f)

	return groupuserpermsWithPrismaUsersSetParam{
		data: builder.Field{
			Name: "users",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r groupuserpermsQueryUsersRelations) Unlink() groupuserpermsWithPrismaUsersSetParam {
	var v groupuserpermsWithPrismaUsersSetParam

	v = groupuserpermsWithPrismaUsersSetParam{
		data: builder.Field{
			Name: "users",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r groupuserpermsQueryUsersusers) Field() groupuserpermsPrismaFields {
	return groupuserpermsFieldUsers
}

// Orgdevices acts as a namespaces to access query methods for the Orgdevices model
var Orgdevices = orgdevicesQuery{}

// orgdevicesQuery exposes query functions for the orgdevices model
type orgdevicesQuery struct {

	// Orgid
	//
	// @required
	Orgid orgdevicesQueryOrgidString

	// Deviceid
	//
	// @required
	Deviceid orgdevicesQueryDeviceidString

	// Orgdevicemeta
	//
	// @required
	Orgdevicemeta orgdevicesQueryOrgdevicemetaJson

	// Updatedat
	//
	// @required
	Updatedat orgdevicesQueryUpdatedatBigInt

	// Updatedby
	//
	// @required
	Updatedby orgdevicesQueryUpdatedbyString

	Devices orgdevicesQueryDevicesRelations

	Orgs orgdevicesQueryOrgsRelations
}

func (orgdevicesQuery) Not(params ...OrgdevicesWhereParam) orgdevicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgdevicesDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (orgdevicesQuery) Or(params ...OrgdevicesWhereParam) orgdevicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgdevicesDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (orgdevicesQuery) And(params ...OrgdevicesWhereParam) orgdevicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgdevicesDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (orgdevicesQuery) OrgidDeviceid(
	_orgid OrgdevicesWithPrismaOrgidWhereParam,

	_deviceid OrgdevicesWithPrismaDeviceidWhereParam,
) OrgdevicesEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _orgid.field())
	fields = append(fields, _deviceid.field())

	return orgdevicesEqualsUniqueParam{
		data: builder.Field{
			Name:   "orgid_deviceid",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type orgdevicesQueryOrgidString struct{}

// Set the required value of Orgid
func (r orgdevicesQueryOrgidString) Set(value string) orgdevicesSetParam {

	return orgdevicesSetParam{
		data: builder.Field{
			Name:  "orgid",
			Value: value,
		},
	}

}

// Set the optional value of Orgid dynamically
func (r orgdevicesQueryOrgidString) SetIfPresent(value *String) orgdevicesSetParam {
	if value == nil {
		return orgdevicesSetParam{}
	}

	return r.Set(*value)
}

func (r orgdevicesQueryOrgidString) Equals(value string) orgdevicesWithPrismaOrgidEqualsParam {

	return orgdevicesWithPrismaOrgidEqualsParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgidString) EqualsIfPresent(value *string) orgdevicesWithPrismaOrgidEqualsParam {
	if value == nil {
		return orgdevicesWithPrismaOrgidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orgdevicesQueryOrgidString) Order(direction SortOrder) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name:  "orgid",
			Value: direction,
		},
	}
}

func (r orgdevicesQueryOrgidString) Cursor(cursor string) orgdevicesCursorParam {
	return orgdevicesCursorParam{
		data: builder.Field{
			Name:  "orgid",
			Value: cursor,
		},
	}
}

func (r orgdevicesQueryOrgidString) In(value []string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgidString) InIfPresent(value []string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.In(value)
}

func (r orgdevicesQueryOrgidString) NotIn(value []string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgidString) NotInIfPresent(value []string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orgdevicesQueryOrgidString) Lt(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgidString) LtIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orgdevicesQueryOrgidString) Lte(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgidString) LteIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orgdevicesQueryOrgidString) Gt(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgidString) GtIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orgdevicesQueryOrgidString) Gte(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgidString) GteIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orgdevicesQueryOrgidString) Contains(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgidString) ContainsIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r orgdevicesQueryOrgidString) StartsWith(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgidString) StartsWithIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r orgdevicesQueryOrgidString) EndsWith(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgidString) EndsWithIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r orgdevicesQueryOrgidString) Mode(value QueryMode) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgidString) ModeIfPresent(value *QueryMode) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r orgdevicesQueryOrgidString) Not(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgidString) NotIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orgdevicesQueryOrgidString) HasPrefix(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orgdevicesQueryOrgidString) HasPrefixIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orgdevicesQueryOrgidString) HasSuffix(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orgdevicesQueryOrgidString) HasSuffixIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r orgdevicesQueryOrgidString) Field() orgdevicesPrismaFields {
	return orgdevicesFieldOrgid
}

// base struct
type orgdevicesQueryDeviceidString struct{}

// Set the required value of Deviceid
func (r orgdevicesQueryDeviceidString) Set(value string) orgdevicesSetParam {

	return orgdevicesSetParam{
		data: builder.Field{
			Name:  "deviceid",
			Value: value,
		},
	}

}

// Set the optional value of Deviceid dynamically
func (r orgdevicesQueryDeviceidString) SetIfPresent(value *String) orgdevicesSetParam {
	if value == nil {
		return orgdevicesSetParam{}
	}

	return r.Set(*value)
}

func (r orgdevicesQueryDeviceidString) Equals(value string) orgdevicesWithPrismaDeviceidEqualsParam {

	return orgdevicesWithPrismaDeviceidEqualsParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryDeviceidString) EqualsIfPresent(value *string) orgdevicesWithPrismaDeviceidEqualsParam {
	if value == nil {
		return orgdevicesWithPrismaDeviceidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orgdevicesQueryDeviceidString) Order(direction SortOrder) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name:  "deviceid",
			Value: direction,
		},
	}
}

func (r orgdevicesQueryDeviceidString) Cursor(cursor string) orgdevicesCursorParam {
	return orgdevicesCursorParam{
		data: builder.Field{
			Name:  "deviceid",
			Value: cursor,
		},
	}
}

func (r orgdevicesQueryDeviceidString) In(value []string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryDeviceidString) InIfPresent(value []string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.In(value)
}

func (r orgdevicesQueryDeviceidString) NotIn(value []string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryDeviceidString) NotInIfPresent(value []string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orgdevicesQueryDeviceidString) Lt(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryDeviceidString) LtIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orgdevicesQueryDeviceidString) Lte(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryDeviceidString) LteIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orgdevicesQueryDeviceidString) Gt(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryDeviceidString) GtIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orgdevicesQueryDeviceidString) Gte(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryDeviceidString) GteIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orgdevicesQueryDeviceidString) Contains(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryDeviceidString) ContainsIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r orgdevicesQueryDeviceidString) StartsWith(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryDeviceidString) StartsWithIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r orgdevicesQueryDeviceidString) EndsWith(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryDeviceidString) EndsWithIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r orgdevicesQueryDeviceidString) Mode(value QueryMode) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryDeviceidString) ModeIfPresent(value *QueryMode) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r orgdevicesQueryDeviceidString) Not(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryDeviceidString) NotIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orgdevicesQueryDeviceidString) HasPrefix(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orgdevicesQueryDeviceidString) HasPrefixIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orgdevicesQueryDeviceidString) HasSuffix(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "deviceid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orgdevicesQueryDeviceidString) HasSuffixIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r orgdevicesQueryDeviceidString) Field() orgdevicesPrismaFields {
	return orgdevicesFieldDeviceid
}

// base struct
type orgdevicesQueryOrgdevicemetaJson struct{}

// Set the required value of Orgdevicemeta
func (r orgdevicesQueryOrgdevicemetaJson) Set(value JSON) orgdevicesWithPrismaOrgdevicemetaSetParam {

	return orgdevicesWithPrismaOrgdevicemetaSetParam{
		data: builder.Field{
			Name:  "orgdevicemeta",
			Value: value,
		},
	}

}

// Set the optional value of Orgdevicemeta dynamically
func (r orgdevicesQueryOrgdevicemetaJson) SetIfPresent(value *JSON) orgdevicesWithPrismaOrgdevicemetaSetParam {
	if value == nil {
		return orgdevicesWithPrismaOrgdevicemetaSetParam{}
	}

	return r.Set(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) Equals(value JSON) orgdevicesWithPrismaOrgdevicemetaEqualsParam {

	return orgdevicesWithPrismaOrgdevicemetaEqualsParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) EqualsIfPresent(value *JSON) orgdevicesWithPrismaOrgdevicemetaEqualsParam {
	if value == nil {
		return orgdevicesWithPrismaOrgdevicemetaEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) Order(direction SortOrder) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name:  "orgdevicemeta",
			Value: direction,
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) Cursor(cursor JSON) orgdevicesCursorParam {
	return orgdevicesCursorParam{
		data: builder.Field{
			Name:  "orgdevicemeta",
			Value: cursor,
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) Path(value []string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "path",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) PathIfPresent(value []string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Path(value)
}

func (r orgdevicesQueryOrgdevicemetaJson) StringContains(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "string_contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) StringContainsIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.StringContains(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) StringStartsWith(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "string_starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) StringStartsWithIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.StringStartsWith(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) StringEndsWith(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "string_ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) StringEndsWithIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.StringEndsWith(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) ArrayStartsWith(value JSON) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "array_starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) ArrayStartsWithIfPresent(value *JSON) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.ArrayStartsWith(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) ArrayEndsWith(value JSON) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "array_ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) ArrayEndsWithIfPresent(value *JSON) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.ArrayEndsWith(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) ArrayContains(value JSON) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "array_contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) ArrayContainsIfPresent(value *JSON) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.ArrayContains(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) Lt(value JSON) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) LtIfPresent(value *JSON) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) Lte(value JSON) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) LteIfPresent(value *JSON) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) Gt(value JSON) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) GtIfPresent(value *JSON) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) Gte(value JSON) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) GteIfPresent(value *JSON) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) Not(value JSONNullValueFilter) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgdevicemeta",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgdevicemetaJson) NotIfPresent(value *JSONNullValueFilter) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Not(*value)
}

func (r orgdevicesQueryOrgdevicemetaJson) Field() orgdevicesPrismaFields {
	return orgdevicesFieldOrgdevicemeta
}

// base struct
type orgdevicesQueryUpdatedatBigInt struct{}

// Set the required value of Updatedat
func (r orgdevicesQueryUpdatedatBigInt) Set(value BigInt) orgdevicesSetParam {

	return orgdevicesSetParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: value,
		},
	}

}

// Set the optional value of Updatedat dynamically
func (r orgdevicesQueryUpdatedatBigInt) SetIfPresent(value *BigInt) orgdevicesSetParam {
	if value == nil {
		return orgdevicesSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Updatedat
func (r orgdevicesQueryUpdatedatBigInt) Increment(value BigInt) orgdevicesSetParam {
	return orgdevicesSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) IncrementIfPresent(value *BigInt) orgdevicesSetParam {
	if value == nil {
		return orgdevicesSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Updatedat
func (r orgdevicesQueryUpdatedatBigInt) Decrement(value BigInt) orgdevicesSetParam {
	return orgdevicesSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) DecrementIfPresent(value *BigInt) orgdevicesSetParam {
	if value == nil {
		return orgdevicesSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Updatedat
func (r orgdevicesQueryUpdatedatBigInt) Multiply(value BigInt) orgdevicesSetParam {
	return orgdevicesSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) MultiplyIfPresent(value *BigInt) orgdevicesSetParam {
	if value == nil {
		return orgdevicesSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Updatedat
func (r orgdevicesQueryUpdatedatBigInt) Divide(value BigInt) orgdevicesSetParam {
	return orgdevicesSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) DivideIfPresent(value *BigInt) orgdevicesSetParam {
	if value == nil {
		return orgdevicesSetParam{}
	}
	return r.Divide(*value)
}

func (r orgdevicesQueryUpdatedatBigInt) Equals(value BigInt) orgdevicesWithPrismaUpdatedatEqualsParam {

	return orgdevicesWithPrismaUpdatedatEqualsParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) EqualsIfPresent(value *BigInt) orgdevicesWithPrismaUpdatedatEqualsParam {
	if value == nil {
		return orgdevicesWithPrismaUpdatedatEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orgdevicesQueryUpdatedatBigInt) Order(direction SortOrder) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: direction,
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) Cursor(cursor BigInt) orgdevicesCursorParam {
	return orgdevicesCursorParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: cursor,
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) In(value []BigInt) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) InIfPresent(value []BigInt) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.In(value)
}

func (r orgdevicesQueryUpdatedatBigInt) NotIn(value []BigInt) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) NotInIfPresent(value []BigInt) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orgdevicesQueryUpdatedatBigInt) Lt(value BigInt) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) LtIfPresent(value *BigInt) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orgdevicesQueryUpdatedatBigInt) Lte(value BigInt) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) LteIfPresent(value *BigInt) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orgdevicesQueryUpdatedatBigInt) Gt(value BigInt) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) GtIfPresent(value *BigInt) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orgdevicesQueryUpdatedatBigInt) Gte(value BigInt) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) GteIfPresent(value *BigInt) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orgdevicesQueryUpdatedatBigInt) Not(value BigInt) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedatBigInt) NotIfPresent(value *BigInt) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Not(*value)
}

func (r orgdevicesQueryUpdatedatBigInt) Field() orgdevicesPrismaFields {
	return orgdevicesFieldUpdatedat
}

// base struct
type orgdevicesQueryUpdatedbyString struct{}

// Set the required value of Updatedby
func (r orgdevicesQueryUpdatedbyString) Set(value string) orgdevicesWithPrismaUpdatedbySetParam {

	return orgdevicesWithPrismaUpdatedbySetParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: value,
		},
	}

}

// Set the optional value of Updatedby dynamically
func (r orgdevicesQueryUpdatedbyString) SetIfPresent(value *String) orgdevicesWithPrismaUpdatedbySetParam {
	if value == nil {
		return orgdevicesWithPrismaUpdatedbySetParam{}
	}

	return r.Set(*value)
}

func (r orgdevicesQueryUpdatedbyString) Equals(value string) orgdevicesWithPrismaUpdatedbyEqualsParam {

	return orgdevicesWithPrismaUpdatedbyEqualsParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) EqualsIfPresent(value *string) orgdevicesWithPrismaUpdatedbyEqualsParam {
	if value == nil {
		return orgdevicesWithPrismaUpdatedbyEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orgdevicesQueryUpdatedbyString) Order(direction SortOrder) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: direction,
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) Cursor(cursor string) orgdevicesCursorParam {
	return orgdevicesCursorParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: cursor,
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) In(value []string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) InIfPresent(value []string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.In(value)
}

func (r orgdevicesQueryUpdatedbyString) NotIn(value []string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) NotInIfPresent(value []string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orgdevicesQueryUpdatedbyString) Lt(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) LtIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orgdevicesQueryUpdatedbyString) Lte(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) LteIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orgdevicesQueryUpdatedbyString) Gt(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) GtIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orgdevicesQueryUpdatedbyString) Gte(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) GteIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orgdevicesQueryUpdatedbyString) Contains(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) ContainsIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Contains(*value)
}

func (r orgdevicesQueryUpdatedbyString) StartsWith(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) StartsWithIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r orgdevicesQueryUpdatedbyString) EndsWith(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) EndsWithIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r orgdevicesQueryUpdatedbyString) Mode(value QueryMode) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) ModeIfPresent(value *QueryMode) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Mode(*value)
}

func (r orgdevicesQueryUpdatedbyString) Not(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgdevicesQueryUpdatedbyString) NotIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orgdevicesQueryUpdatedbyString) HasPrefix(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orgdevicesQueryUpdatedbyString) HasPrefixIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orgdevicesQueryUpdatedbyString) HasSuffix(value string) orgdevicesDefaultParam {
	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orgdevicesQueryUpdatedbyString) HasSuffixIfPresent(value *string) orgdevicesDefaultParam {
	if value == nil {
		return orgdevicesDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r orgdevicesQueryUpdatedbyString) Field() orgdevicesPrismaFields {
	return orgdevicesFieldUpdatedby
}

// base struct
type orgdevicesQueryDevicesdevices struct{}

type orgdevicesQueryDevicesRelations struct{}

// Orgdevices -> Devices
//
// @relation
// @required
func (orgdevicesQueryDevicesRelations) Where(
	params ...DevicesWhereParam,
) orgdevicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (orgdevicesQueryDevicesRelations) Fetch() orgdevicesToDevicesFindUnique {
	var v orgdevicesToDevicesFindUnique

	v.query.Operation = "query"
	v.query.Method = "devices"
	v.query.Outputs = devicesOutput

	return v
}

func (r orgdevicesQueryDevicesRelations) Link(
	params DevicesWhereParam,
) orgdevicesWithPrismaDevicesSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return orgdevicesWithPrismaDevicesSetParam{}
	}

	fields = append(fields, f)

	return orgdevicesWithPrismaDevicesSetParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r orgdevicesQueryDevicesRelations) Unlink() orgdevicesWithPrismaDevicesSetParam {
	var v orgdevicesWithPrismaDevicesSetParam

	v = orgdevicesWithPrismaDevicesSetParam{
		data: builder.Field{
			Name: "devices",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r orgdevicesQueryDevicesdevices) Field() orgdevicesPrismaFields {
	return orgdevicesFieldDevices
}

// base struct
type orgdevicesQueryOrgsorgs struct{}

type orgdevicesQueryOrgsRelations struct{}

// Orgdevices -> Orgs
//
// @relation
// @required
func (orgdevicesQueryOrgsRelations) Where(
	params ...OrgsWhereParam,
) orgdevicesDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgdevicesDefaultParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (orgdevicesQueryOrgsRelations) Fetch() orgdevicesToOrgsFindUnique {
	var v orgdevicesToOrgsFindUnique

	v.query.Operation = "query"
	v.query.Method = "orgs"
	v.query.Outputs = orgsOutput

	return v
}

func (r orgdevicesQueryOrgsRelations) Link(
	params OrgsWhereParam,
) orgdevicesWithPrismaOrgsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return orgdevicesWithPrismaOrgsSetParam{}
	}

	fields = append(fields, f)

	return orgdevicesWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r orgdevicesQueryOrgsRelations) Unlink() orgdevicesWithPrismaOrgsSetParam {
	var v orgdevicesWithPrismaOrgsSetParam

	v = orgdevicesWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r orgdevicesQueryOrgsorgs) Field() orgdevicesPrismaFields {
	return orgdevicesFieldOrgs
}

// Orgrgroup acts as a namespaces to access query methods for the Orgrgroup model
var Orgrgroup = orgrgroupQuery{}

// orgrgroupQuery exposes query functions for the orgrgroup model
type orgrgroupQuery struct {

	// Orgid
	//
	// @required
	Orgid orgrgroupQueryOrgidString

	// Rootgroupid
	//
	// @required
	Rootgroupid orgrgroupQueryRootgroupidString

	Orgs orgrgroupQueryOrgsRelations

	Groups orgrgroupQueryGroupsRelations
}

func (orgrgroupQuery) Not(params ...OrgrgroupWhereParam) orgrgroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgrgroupDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (orgrgroupQuery) Or(params ...OrgrgroupWhereParam) orgrgroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgrgroupDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (orgrgroupQuery) And(params ...OrgrgroupWhereParam) orgrgroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgrgroupDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type orgrgroupQueryOrgidString struct{}

// Set the required value of Orgid
func (r orgrgroupQueryOrgidString) Set(value string) orgrgroupSetParam {

	return orgrgroupSetParam{
		data: builder.Field{
			Name:  "orgid",
			Value: value,
		},
	}

}

// Set the optional value of Orgid dynamically
func (r orgrgroupQueryOrgidString) SetIfPresent(value *String) orgrgroupSetParam {
	if value == nil {
		return orgrgroupSetParam{}
	}

	return r.Set(*value)
}

func (r orgrgroupQueryOrgidString) Equals(value string) orgrgroupWithPrismaOrgidEqualsUniqueParam {

	return orgrgroupWithPrismaOrgidEqualsUniqueParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgidString) EqualsIfPresent(value *string) orgrgroupWithPrismaOrgidEqualsUniqueParam {
	if value == nil {
		return orgrgroupWithPrismaOrgidEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r orgrgroupQueryOrgidString) Order(direction SortOrder) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name:  "orgid",
			Value: direction,
		},
	}
}

func (r orgrgroupQueryOrgidString) Cursor(cursor string) orgrgroupCursorParam {
	return orgrgroupCursorParam{
		data: builder.Field{
			Name:  "orgid",
			Value: cursor,
		},
	}
}

func (r orgrgroupQueryOrgidString) In(value []string) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgidString) InIfPresent(value []string) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.In(value)
}

func (r orgrgroupQueryOrgidString) NotIn(value []string) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgidString) NotInIfPresent(value []string) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.NotIn(value)
}

func (r orgrgroupQueryOrgidString) Lt(value string) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgidString) LtIfPresent(value *string) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.Lt(*value)
}

func (r orgrgroupQueryOrgidString) Lte(value string) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgidString) LteIfPresent(value *string) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.Lte(*value)
}

func (r orgrgroupQueryOrgidString) Gt(value string) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgidString) GtIfPresent(value *string) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.Gt(*value)
}

func (r orgrgroupQueryOrgidString) Gte(value string) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgidString) GteIfPresent(value *string) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.Gte(*value)
}

func (r orgrgroupQueryOrgidString) Contains(value string) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgidString) ContainsIfPresent(value *string) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.Contains(*value)
}

func (r orgrgroupQueryOrgidString) StartsWith(value string) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgidString) StartsWithIfPresent(value *string) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r orgrgroupQueryOrgidString) EndsWith(value string) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgidString) EndsWithIfPresent(value *string) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r orgrgroupQueryOrgidString) Mode(value QueryMode) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgidString) ModeIfPresent(value *QueryMode) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.Mode(*value)
}

func (r orgrgroupQueryOrgidString) Not(value string) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgidString) NotIfPresent(value *string) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orgrgroupQueryOrgidString) HasPrefix(value string) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orgrgroupQueryOrgidString) HasPrefixIfPresent(value *string) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orgrgroupQueryOrgidString) HasSuffix(value string) orgrgroupParamUnique {
	return orgrgroupParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orgrgroupQueryOrgidString) HasSuffixIfPresent(value *string) orgrgroupParamUnique {
	if value == nil {
		return orgrgroupParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r orgrgroupQueryOrgidString) Field() orgrgroupPrismaFields {
	return orgrgroupFieldOrgid
}

// base struct
type orgrgroupQueryRootgroupidString struct{}

// Set the required value of Rootgroupid
func (r orgrgroupQueryRootgroupidString) Set(value string) orgrgroupSetParam {

	return orgrgroupSetParam{
		data: builder.Field{
			Name:  "rootgroupid",
			Value: value,
		},
	}

}

// Set the optional value of Rootgroupid dynamically
func (r orgrgroupQueryRootgroupidString) SetIfPresent(value *String) orgrgroupSetParam {
	if value == nil {
		return orgrgroupSetParam{}
	}

	return r.Set(*value)
}

func (r orgrgroupQueryRootgroupidString) Equals(value string) orgrgroupWithPrismaRootgroupidEqualsParam {

	return orgrgroupWithPrismaRootgroupidEqualsParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryRootgroupidString) EqualsIfPresent(value *string) orgrgroupWithPrismaRootgroupidEqualsParam {
	if value == nil {
		return orgrgroupWithPrismaRootgroupidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orgrgroupQueryRootgroupidString) Order(direction SortOrder) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name:  "rootgroupid",
			Value: direction,
		},
	}
}

func (r orgrgroupQueryRootgroupidString) Cursor(cursor string) orgrgroupCursorParam {
	return orgrgroupCursorParam{
		data: builder.Field{
			Name:  "rootgroupid",
			Value: cursor,
		},
	}
}

func (r orgrgroupQueryRootgroupidString) In(value []string) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryRootgroupidString) InIfPresent(value []string) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.In(value)
}

func (r orgrgroupQueryRootgroupidString) NotIn(value []string) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryRootgroupidString) NotInIfPresent(value []string) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orgrgroupQueryRootgroupidString) Lt(value string) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryRootgroupidString) LtIfPresent(value *string) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orgrgroupQueryRootgroupidString) Lte(value string) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryRootgroupidString) LteIfPresent(value *string) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orgrgroupQueryRootgroupidString) Gt(value string) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryRootgroupidString) GtIfPresent(value *string) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orgrgroupQueryRootgroupidString) Gte(value string) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryRootgroupidString) GteIfPresent(value *string) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orgrgroupQueryRootgroupidString) Contains(value string) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryRootgroupidString) ContainsIfPresent(value *string) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.Contains(*value)
}

func (r orgrgroupQueryRootgroupidString) StartsWith(value string) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryRootgroupidString) StartsWithIfPresent(value *string) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r orgrgroupQueryRootgroupidString) EndsWith(value string) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryRootgroupidString) EndsWithIfPresent(value *string) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r orgrgroupQueryRootgroupidString) Mode(value QueryMode) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryRootgroupidString) ModeIfPresent(value *QueryMode) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.Mode(*value)
}

func (r orgrgroupQueryRootgroupidString) Not(value string) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgrgroupQueryRootgroupidString) NotIfPresent(value *string) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orgrgroupQueryRootgroupidString) HasPrefix(value string) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orgrgroupQueryRootgroupidString) HasPrefixIfPresent(value *string) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orgrgroupQueryRootgroupidString) HasSuffix(value string) orgrgroupDefaultParam {
	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "rootgroupid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orgrgroupQueryRootgroupidString) HasSuffixIfPresent(value *string) orgrgroupDefaultParam {
	if value == nil {
		return orgrgroupDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r orgrgroupQueryRootgroupidString) Field() orgrgroupPrismaFields {
	return orgrgroupFieldRootgroupid
}

// base struct
type orgrgroupQueryOrgsorgs struct{}

type orgrgroupQueryOrgsRelations struct{}

// Orgrgroup -> Orgs
//
// @relation
// @required
func (orgrgroupQueryOrgsRelations) Where(
	params ...OrgsWhereParam,
) orgrgroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (orgrgroupQueryOrgsRelations) Fetch() orgrgroupToOrgsFindUnique {
	var v orgrgroupToOrgsFindUnique

	v.query.Operation = "query"
	v.query.Method = "orgs"
	v.query.Outputs = orgsOutput

	return v
}

func (r orgrgroupQueryOrgsRelations) Link(
	params OrgsWhereParam,
) orgrgroupWithPrismaOrgsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return orgrgroupWithPrismaOrgsSetParam{}
	}

	fields = append(fields, f)

	return orgrgroupWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r orgrgroupQueryOrgsRelations) Unlink() orgrgroupWithPrismaOrgsSetParam {
	var v orgrgroupWithPrismaOrgsSetParam

	v = orgrgroupWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r orgrgroupQueryOrgsorgs) Field() orgrgroupPrismaFields {
	return orgrgroupFieldOrgs
}

// base struct
type orgrgroupQueryGroupsgroups struct{}

type orgrgroupQueryGroupsRelations struct{}

// Orgrgroup -> Groups
//
// @relation
// @required
func (orgrgroupQueryGroupsRelations) Where(
	params ...GroupsWhereParam,
) orgrgroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgrgroupDefaultParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (orgrgroupQueryGroupsRelations) Fetch() orgrgroupToGroupsFindUnique {
	var v orgrgroupToGroupsFindUnique

	v.query.Operation = "query"
	v.query.Method = "groups"
	v.query.Outputs = groupsOutput

	return v
}

func (r orgrgroupQueryGroupsRelations) Link(
	params GroupsWhereParam,
) orgrgroupWithPrismaGroupsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return orgrgroupWithPrismaGroupsSetParam{}
	}

	fields = append(fields, f)

	return orgrgroupWithPrismaGroupsSetParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r orgrgroupQueryGroupsRelations) Unlink() orgrgroupWithPrismaGroupsSetParam {
	var v orgrgroupWithPrismaGroupsSetParam

	v = orgrgroupWithPrismaGroupsSetParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r orgrgroupQueryGroupsgroups) Field() orgrgroupPrismaFields {
	return orgrgroupFieldGroups
}

// Orgs acts as a namespaces to access query methods for the Orgs model
var Orgs = orgsQuery{}

// orgsQuery exposes query functions for the orgs model
type orgsQuery struct {

	// Orgid
	//
	// @required
	Orgid orgsQueryOrgidString

	// Orgname
	//
	// @required
	// @unique
	Orgname orgsQueryOrgnameString

	// Orgmeta
	//
	// @required
	Orgmeta orgsQueryOrgmetaJson

	// Isenabled
	//
	// @required
	Isenabled orgsQueryIsenabledBoolean

	// Createdby
	//
	// @required
	Createdby orgsQueryCreatedbyString

	// Updatedby
	//
	// @required
	Updatedby orgsQueryUpdatedbyString

	// Createdat
	//
	// @required
	Createdat orgsQueryCreatedatBigInt

	// Updatedat
	//
	// @required
	Updatedat orgsQueryUpdatedatBigInt

	Groupdevices orgsQueryGroupdevicesRelations

	Groups orgsQueryGroupsRelations

	Grouptree orgsQueryGrouptreeRelations

	Groupuserperms orgsQueryGroupuserpermsRelations

	Orgdevices orgsQueryOrgdevicesRelations

	Orgrgroup orgsQueryOrgrgroupRelations

	Usergroup orgsQueryUsergroupRelations
}

func (orgsQuery) Not(params ...OrgsWhereParam) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (orgsQuery) Or(params ...OrgsWhereParam) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (orgsQuery) And(params ...OrgsWhereParam) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type orgsQueryOrgidString struct{}

// Set the required value of Orgid
func (r orgsQueryOrgidString) Set(value string) orgsWithPrismaOrgidSetParam {

	return orgsWithPrismaOrgidSetParam{
		data: builder.Field{
			Name:  "orgid",
			Value: value,
		},
	}

}

// Set the optional value of Orgid dynamically
func (r orgsQueryOrgidString) SetIfPresent(value *String) orgsWithPrismaOrgidSetParam {
	if value == nil {
		return orgsWithPrismaOrgidSetParam{}
	}

	return r.Set(*value)
}

func (r orgsQueryOrgidString) Equals(value string) orgsWithPrismaOrgidEqualsUniqueParam {

	return orgsWithPrismaOrgidEqualsUniqueParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgidString) EqualsIfPresent(value *string) orgsWithPrismaOrgidEqualsUniqueParam {
	if value == nil {
		return orgsWithPrismaOrgidEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r orgsQueryOrgidString) Order(direction SortOrder) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name:  "orgid",
			Value: direction,
		},
	}
}

func (r orgsQueryOrgidString) Cursor(cursor string) orgsCursorParam {
	return orgsCursorParam{
		data: builder.Field{
			Name:  "orgid",
			Value: cursor,
		},
	}
}

func (r orgsQueryOrgidString) In(value []string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgidString) InIfPresent(value []string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.In(value)
}

func (r orgsQueryOrgidString) NotIn(value []string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgidString) NotInIfPresent(value []string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.NotIn(value)
}

func (r orgsQueryOrgidString) Lt(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgidString) LtIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Lt(*value)
}

func (r orgsQueryOrgidString) Lte(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgidString) LteIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Lte(*value)
}

func (r orgsQueryOrgidString) Gt(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgidString) GtIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Gt(*value)
}

func (r orgsQueryOrgidString) Gte(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgidString) GteIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Gte(*value)
}

func (r orgsQueryOrgidString) Contains(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgidString) ContainsIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Contains(*value)
}

func (r orgsQueryOrgidString) StartsWith(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgidString) StartsWithIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r orgsQueryOrgidString) EndsWith(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgidString) EndsWithIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r orgsQueryOrgidString) Mode(value QueryMode) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgidString) ModeIfPresent(value *QueryMode) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Mode(*value)
}

func (r orgsQueryOrgidString) Not(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgidString) NotIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orgsQueryOrgidString) HasPrefix(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orgsQueryOrgidString) HasPrefixIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orgsQueryOrgidString) HasSuffix(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orgsQueryOrgidString) HasSuffixIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r orgsQueryOrgidString) Field() orgsPrismaFields {
	return orgsFieldOrgid
}

// base struct
type orgsQueryOrgnameString struct{}

// Set the required value of Orgname
func (r orgsQueryOrgnameString) Set(value string) orgsWithPrismaOrgnameSetParam {

	return orgsWithPrismaOrgnameSetParam{
		data: builder.Field{
			Name:  "orgname",
			Value: value,
		},
	}

}

// Set the optional value of Orgname dynamically
func (r orgsQueryOrgnameString) SetIfPresent(value *String) orgsWithPrismaOrgnameSetParam {
	if value == nil {
		return orgsWithPrismaOrgnameSetParam{}
	}

	return r.Set(*value)
}

func (r orgsQueryOrgnameString) Equals(value string) orgsWithPrismaOrgnameEqualsUniqueParam {

	return orgsWithPrismaOrgnameEqualsUniqueParam{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgnameString) EqualsIfPresent(value *string) orgsWithPrismaOrgnameEqualsUniqueParam {
	if value == nil {
		return orgsWithPrismaOrgnameEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r orgsQueryOrgnameString) Order(direction SortOrder) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name:  "orgname",
			Value: direction,
		},
	}
}

func (r orgsQueryOrgnameString) Cursor(cursor string) orgsCursorParam {
	return orgsCursorParam{
		data: builder.Field{
			Name:  "orgname",
			Value: cursor,
		},
	}
}

func (r orgsQueryOrgnameString) In(value []string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgnameString) InIfPresent(value []string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.In(value)
}

func (r orgsQueryOrgnameString) NotIn(value []string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgnameString) NotInIfPresent(value []string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.NotIn(value)
}

func (r orgsQueryOrgnameString) Lt(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgnameString) LtIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Lt(*value)
}

func (r orgsQueryOrgnameString) Lte(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgnameString) LteIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Lte(*value)
}

func (r orgsQueryOrgnameString) Gt(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgnameString) GtIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Gt(*value)
}

func (r orgsQueryOrgnameString) Gte(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgnameString) GteIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Gte(*value)
}

func (r orgsQueryOrgnameString) Contains(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgnameString) ContainsIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Contains(*value)
}

func (r orgsQueryOrgnameString) StartsWith(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgnameString) StartsWithIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r orgsQueryOrgnameString) EndsWith(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgnameString) EndsWithIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r orgsQueryOrgnameString) Mode(value QueryMode) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgnameString) ModeIfPresent(value *QueryMode) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Mode(*value)
}

func (r orgsQueryOrgnameString) Not(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgnameString) NotIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orgsQueryOrgnameString) HasPrefix(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orgsQueryOrgnameString) HasPrefixIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orgsQueryOrgnameString) HasSuffix(value string) orgsParamUnique {
	return orgsParamUnique{
		data: builder.Field{
			Name: "orgname",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orgsQueryOrgnameString) HasSuffixIfPresent(value *string) orgsParamUnique {
	if value == nil {
		return orgsParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r orgsQueryOrgnameString) Field() orgsPrismaFields {
	return orgsFieldOrgname
}

// base struct
type orgsQueryOrgmetaJson struct{}

// Set the required value of Orgmeta
func (r orgsQueryOrgmetaJson) Set(value JSON) orgsWithPrismaOrgmetaSetParam {

	return orgsWithPrismaOrgmetaSetParam{
		data: builder.Field{
			Name:  "orgmeta",
			Value: value,
		},
	}

}

// Set the optional value of Orgmeta dynamically
func (r orgsQueryOrgmetaJson) SetIfPresent(value *JSON) orgsWithPrismaOrgmetaSetParam {
	if value == nil {
		return orgsWithPrismaOrgmetaSetParam{}
	}

	return r.Set(*value)
}

func (r orgsQueryOrgmetaJson) Equals(value JSON) orgsWithPrismaOrgmetaEqualsParam {

	return orgsWithPrismaOrgmetaEqualsParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) EqualsIfPresent(value *JSON) orgsWithPrismaOrgmetaEqualsParam {
	if value == nil {
		return orgsWithPrismaOrgmetaEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orgsQueryOrgmetaJson) Order(direction SortOrder) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name:  "orgmeta",
			Value: direction,
		},
	}
}

func (r orgsQueryOrgmetaJson) Cursor(cursor JSON) orgsCursorParam {
	return orgsCursorParam{
		data: builder.Field{
			Name:  "orgmeta",
			Value: cursor,
		},
	}
}

func (r orgsQueryOrgmetaJson) Path(value []string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "path",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) PathIfPresent(value []string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Path(value)
}

func (r orgsQueryOrgmetaJson) StringContains(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "string_contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) StringContainsIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.StringContains(*value)
}

func (r orgsQueryOrgmetaJson) StringStartsWith(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "string_starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) StringStartsWithIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.StringStartsWith(*value)
}

func (r orgsQueryOrgmetaJson) StringEndsWith(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "string_ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) StringEndsWithIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.StringEndsWith(*value)
}

func (r orgsQueryOrgmetaJson) ArrayStartsWith(value JSON) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "array_starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) ArrayStartsWithIfPresent(value *JSON) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.ArrayStartsWith(*value)
}

func (r orgsQueryOrgmetaJson) ArrayEndsWith(value JSON) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "array_ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) ArrayEndsWithIfPresent(value *JSON) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.ArrayEndsWith(*value)
}

func (r orgsQueryOrgmetaJson) ArrayContains(value JSON) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "array_contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) ArrayContainsIfPresent(value *JSON) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.ArrayContains(*value)
}

func (r orgsQueryOrgmetaJson) Lt(value JSON) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) LtIfPresent(value *JSON) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orgsQueryOrgmetaJson) Lte(value JSON) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) LteIfPresent(value *JSON) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orgsQueryOrgmetaJson) Gt(value JSON) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) GtIfPresent(value *JSON) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orgsQueryOrgmetaJson) Gte(value JSON) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) GteIfPresent(value *JSON) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orgsQueryOrgmetaJson) Not(value JSONNullValueFilter) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgmeta",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryOrgmetaJson) NotIfPresent(value *JSONNullValueFilter) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Not(*value)
}

func (r orgsQueryOrgmetaJson) Field() orgsPrismaFields {
	return orgsFieldOrgmeta
}

// base struct
type orgsQueryIsenabledBoolean struct{}

// Set the required value of Isenabled
func (r orgsQueryIsenabledBoolean) Set(value bool) orgsSetParam {

	return orgsSetParam{
		data: builder.Field{
			Name:  "isenabled",
			Value: value,
		},
	}

}

// Set the optional value of Isenabled dynamically
func (r orgsQueryIsenabledBoolean) SetIfPresent(value *Boolean) orgsSetParam {
	if value == nil {
		return orgsSetParam{}
	}

	return r.Set(*value)
}

func (r orgsQueryIsenabledBoolean) Equals(value bool) orgsWithPrismaIsenabledEqualsParam {

	return orgsWithPrismaIsenabledEqualsParam{
		data: builder.Field{
			Name: "isenabled",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryIsenabledBoolean) EqualsIfPresent(value *bool) orgsWithPrismaIsenabledEqualsParam {
	if value == nil {
		return orgsWithPrismaIsenabledEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orgsQueryIsenabledBoolean) Order(direction SortOrder) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name:  "isenabled",
			Value: direction,
		},
	}
}

func (r orgsQueryIsenabledBoolean) Cursor(cursor bool) orgsCursorParam {
	return orgsCursorParam{
		data: builder.Field{
			Name:  "isenabled",
			Value: cursor,
		},
	}
}

func (r orgsQueryIsenabledBoolean) Field() orgsPrismaFields {
	return orgsFieldIsenabled
}

// base struct
type orgsQueryCreatedbyString struct{}

// Set the required value of Createdby
func (r orgsQueryCreatedbyString) Set(value string) orgsWithPrismaCreatedbySetParam {

	return orgsWithPrismaCreatedbySetParam{
		data: builder.Field{
			Name:  "createdby",
			Value: value,
		},
	}

}

// Set the optional value of Createdby dynamically
func (r orgsQueryCreatedbyString) SetIfPresent(value *String) orgsWithPrismaCreatedbySetParam {
	if value == nil {
		return orgsWithPrismaCreatedbySetParam{}
	}

	return r.Set(*value)
}

func (r orgsQueryCreatedbyString) Equals(value string) orgsWithPrismaCreatedbyEqualsParam {

	return orgsWithPrismaCreatedbyEqualsParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedbyString) EqualsIfPresent(value *string) orgsWithPrismaCreatedbyEqualsParam {
	if value == nil {
		return orgsWithPrismaCreatedbyEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orgsQueryCreatedbyString) Order(direction SortOrder) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name:  "createdby",
			Value: direction,
		},
	}
}

func (r orgsQueryCreatedbyString) Cursor(cursor string) orgsCursorParam {
	return orgsCursorParam{
		data: builder.Field{
			Name:  "createdby",
			Value: cursor,
		},
	}
}

func (r orgsQueryCreatedbyString) In(value []string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedbyString) InIfPresent(value []string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.In(value)
}

func (r orgsQueryCreatedbyString) NotIn(value []string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedbyString) NotInIfPresent(value []string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orgsQueryCreatedbyString) Lt(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedbyString) LtIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orgsQueryCreatedbyString) Lte(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedbyString) LteIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orgsQueryCreatedbyString) Gt(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedbyString) GtIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orgsQueryCreatedbyString) Gte(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedbyString) GteIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orgsQueryCreatedbyString) Contains(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedbyString) ContainsIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r orgsQueryCreatedbyString) StartsWith(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedbyString) StartsWithIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r orgsQueryCreatedbyString) EndsWith(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedbyString) EndsWithIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r orgsQueryCreatedbyString) Mode(value QueryMode) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedbyString) ModeIfPresent(value *QueryMode) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r orgsQueryCreatedbyString) Not(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedbyString) NotIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orgsQueryCreatedbyString) HasPrefix(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orgsQueryCreatedbyString) HasPrefixIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orgsQueryCreatedbyString) HasSuffix(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdby",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orgsQueryCreatedbyString) HasSuffixIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r orgsQueryCreatedbyString) Field() orgsPrismaFields {
	return orgsFieldCreatedby
}

// base struct
type orgsQueryUpdatedbyString struct{}

// Set the required value of Updatedby
func (r orgsQueryUpdatedbyString) Set(value string) orgsWithPrismaUpdatedbySetParam {

	return orgsWithPrismaUpdatedbySetParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: value,
		},
	}

}

// Set the optional value of Updatedby dynamically
func (r orgsQueryUpdatedbyString) SetIfPresent(value *String) orgsWithPrismaUpdatedbySetParam {
	if value == nil {
		return orgsWithPrismaUpdatedbySetParam{}
	}

	return r.Set(*value)
}

func (r orgsQueryUpdatedbyString) Equals(value string) orgsWithPrismaUpdatedbyEqualsParam {

	return orgsWithPrismaUpdatedbyEqualsParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedbyString) EqualsIfPresent(value *string) orgsWithPrismaUpdatedbyEqualsParam {
	if value == nil {
		return orgsWithPrismaUpdatedbyEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orgsQueryUpdatedbyString) Order(direction SortOrder) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: direction,
		},
	}
}

func (r orgsQueryUpdatedbyString) Cursor(cursor string) orgsCursorParam {
	return orgsCursorParam{
		data: builder.Field{
			Name:  "updatedby",
			Value: cursor,
		},
	}
}

func (r orgsQueryUpdatedbyString) In(value []string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedbyString) InIfPresent(value []string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.In(value)
}

func (r orgsQueryUpdatedbyString) NotIn(value []string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedbyString) NotInIfPresent(value []string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orgsQueryUpdatedbyString) Lt(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedbyString) LtIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orgsQueryUpdatedbyString) Lte(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedbyString) LteIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orgsQueryUpdatedbyString) Gt(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedbyString) GtIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orgsQueryUpdatedbyString) Gte(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedbyString) GteIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orgsQueryUpdatedbyString) Contains(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedbyString) ContainsIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Contains(*value)
}

func (r orgsQueryUpdatedbyString) StartsWith(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedbyString) StartsWithIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r orgsQueryUpdatedbyString) EndsWith(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedbyString) EndsWithIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r orgsQueryUpdatedbyString) Mode(value QueryMode) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedbyString) ModeIfPresent(value *QueryMode) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Mode(*value)
}

func (r orgsQueryUpdatedbyString) Not(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedbyString) NotIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r orgsQueryUpdatedbyString) HasPrefix(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r orgsQueryUpdatedbyString) HasPrefixIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r orgsQueryUpdatedbyString) HasSuffix(value string) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedby",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r orgsQueryUpdatedbyString) HasSuffixIfPresent(value *string) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r orgsQueryUpdatedbyString) Field() orgsPrismaFields {
	return orgsFieldUpdatedby
}

// base struct
type orgsQueryCreatedatBigInt struct{}

// Set the required value of Createdat
func (r orgsQueryCreatedatBigInt) Set(value BigInt) orgsSetParam {

	return orgsSetParam{
		data: builder.Field{
			Name:  "createdat",
			Value: value,
		},
	}

}

// Set the optional value of Createdat dynamically
func (r orgsQueryCreatedatBigInt) SetIfPresent(value *BigInt) orgsSetParam {
	if value == nil {
		return orgsSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Createdat
func (r orgsQueryCreatedatBigInt) Increment(value BigInt) orgsSetParam {
	return orgsSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedatBigInt) IncrementIfPresent(value *BigInt) orgsSetParam {
	if value == nil {
		return orgsSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Createdat
func (r orgsQueryCreatedatBigInt) Decrement(value BigInt) orgsSetParam {
	return orgsSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedatBigInt) DecrementIfPresent(value *BigInt) orgsSetParam {
	if value == nil {
		return orgsSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Createdat
func (r orgsQueryCreatedatBigInt) Multiply(value BigInt) orgsSetParam {
	return orgsSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedatBigInt) MultiplyIfPresent(value *BigInt) orgsSetParam {
	if value == nil {
		return orgsSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Createdat
func (r orgsQueryCreatedatBigInt) Divide(value BigInt) orgsSetParam {
	return orgsSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedatBigInt) DivideIfPresent(value *BigInt) orgsSetParam {
	if value == nil {
		return orgsSetParam{}
	}
	return r.Divide(*value)
}

func (r orgsQueryCreatedatBigInt) Equals(value BigInt) orgsWithPrismaCreatedatEqualsParam {

	return orgsWithPrismaCreatedatEqualsParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedatBigInt) EqualsIfPresent(value *BigInt) orgsWithPrismaCreatedatEqualsParam {
	if value == nil {
		return orgsWithPrismaCreatedatEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orgsQueryCreatedatBigInt) Order(direction SortOrder) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name:  "createdat",
			Value: direction,
		},
	}
}

func (r orgsQueryCreatedatBigInt) Cursor(cursor BigInt) orgsCursorParam {
	return orgsCursorParam{
		data: builder.Field{
			Name:  "createdat",
			Value: cursor,
		},
	}
}

func (r orgsQueryCreatedatBigInt) In(value []BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedatBigInt) InIfPresent(value []BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.In(value)
}

func (r orgsQueryCreatedatBigInt) NotIn(value []BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedatBigInt) NotInIfPresent(value []BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orgsQueryCreatedatBigInt) Lt(value BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedatBigInt) LtIfPresent(value *BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orgsQueryCreatedatBigInt) Lte(value BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedatBigInt) LteIfPresent(value *BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orgsQueryCreatedatBigInt) Gt(value BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedatBigInt) GtIfPresent(value *BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orgsQueryCreatedatBigInt) Gte(value BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedatBigInt) GteIfPresent(value *BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orgsQueryCreatedatBigInt) Not(value BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryCreatedatBigInt) NotIfPresent(value *BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Not(*value)
}

func (r orgsQueryCreatedatBigInt) Field() orgsPrismaFields {
	return orgsFieldCreatedat
}

// base struct
type orgsQueryUpdatedatBigInt struct{}

// Set the required value of Updatedat
func (r orgsQueryUpdatedatBigInt) Set(value BigInt) orgsSetParam {

	return orgsSetParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: value,
		},
	}

}

// Set the optional value of Updatedat dynamically
func (r orgsQueryUpdatedatBigInt) SetIfPresent(value *BigInt) orgsSetParam {
	if value == nil {
		return orgsSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Updatedat
func (r orgsQueryUpdatedatBigInt) Increment(value BigInt) orgsSetParam {
	return orgsSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedatBigInt) IncrementIfPresent(value *BigInt) orgsSetParam {
	if value == nil {
		return orgsSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Updatedat
func (r orgsQueryUpdatedatBigInt) Decrement(value BigInt) orgsSetParam {
	return orgsSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedatBigInt) DecrementIfPresent(value *BigInt) orgsSetParam {
	if value == nil {
		return orgsSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Updatedat
func (r orgsQueryUpdatedatBigInt) Multiply(value BigInt) orgsSetParam {
	return orgsSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedatBigInt) MultiplyIfPresent(value *BigInt) orgsSetParam {
	if value == nil {
		return orgsSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Updatedat
func (r orgsQueryUpdatedatBigInt) Divide(value BigInt) orgsSetParam {
	return orgsSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedatBigInt) DivideIfPresent(value *BigInt) orgsSetParam {
	if value == nil {
		return orgsSetParam{}
	}
	return r.Divide(*value)
}

func (r orgsQueryUpdatedatBigInt) Equals(value BigInt) orgsWithPrismaUpdatedatEqualsParam {

	return orgsWithPrismaUpdatedatEqualsParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedatBigInt) EqualsIfPresent(value *BigInt) orgsWithPrismaUpdatedatEqualsParam {
	if value == nil {
		return orgsWithPrismaUpdatedatEqualsParam{}
	}
	return r.Equals(*value)
}

func (r orgsQueryUpdatedatBigInt) Order(direction SortOrder) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: direction,
		},
	}
}

func (r orgsQueryUpdatedatBigInt) Cursor(cursor BigInt) orgsCursorParam {
	return orgsCursorParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: cursor,
		},
	}
}

func (r orgsQueryUpdatedatBigInt) In(value []BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedatBigInt) InIfPresent(value []BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.In(value)
}

func (r orgsQueryUpdatedatBigInt) NotIn(value []BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedatBigInt) NotInIfPresent(value []BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.NotIn(value)
}

func (r orgsQueryUpdatedatBigInt) Lt(value BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedatBigInt) LtIfPresent(value *BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Lt(*value)
}

func (r orgsQueryUpdatedatBigInt) Lte(value BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedatBigInt) LteIfPresent(value *BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Lte(*value)
}

func (r orgsQueryUpdatedatBigInt) Gt(value BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedatBigInt) GtIfPresent(value *BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Gt(*value)
}

func (r orgsQueryUpdatedatBigInt) Gte(value BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedatBigInt) GteIfPresent(value *BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Gte(*value)
}

func (r orgsQueryUpdatedatBigInt) Not(value BigInt) orgsDefaultParam {
	return orgsDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r orgsQueryUpdatedatBigInt) NotIfPresent(value *BigInt) orgsDefaultParam {
	if value == nil {
		return orgsDefaultParam{}
	}
	return r.Not(*value)
}

func (r orgsQueryUpdatedatBigInt) Field() orgsPrismaFields {
	return orgsFieldUpdatedat
}

// base struct
type orgsQueryGroupdevicesgroupdevices struct{}

type orgsQueryGroupdevicesRelations struct{}

// Orgs -> Groupdevices
//
// @relation
// @required
func (orgsQueryGroupdevicesRelations) Some(
	params ...GroupdevicesWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Orgs -> Groupdevices
//
// @relation
// @required
func (orgsQueryGroupdevicesRelations) Every(
	params ...GroupdevicesWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Orgs -> Groupdevices
//
// @relation
// @required
func (orgsQueryGroupdevicesRelations) None(
	params ...GroupdevicesWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (orgsQueryGroupdevicesRelations) Fetch(

	params ...GroupdevicesWhereParam,

) orgsToGroupdevicesFindMany {
	var v orgsToGroupdevicesFindMany

	v.query.Operation = "query"
	v.query.Method = "groupdevices"
	v.query.Outputs = groupdevicesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orgsQueryGroupdevicesRelations) Link(
	params ...GroupdevicesWhereParam,
) orgsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsSetParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r orgsQueryGroupdevicesRelations) Unlink(
	params ...GroupdevicesWhereParam,
) orgsSetParam {
	var v orgsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = orgsSetParam{
		data: builder.Field{
			Name: "groupdevices",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r orgsQueryGroupdevicesgroupdevices) Field() orgsPrismaFields {
	return orgsFieldGroupdevices
}

// base struct
type orgsQueryGroupsgroups struct{}

type orgsQueryGroupsRelations struct{}

// Orgs -> Groups
//
// @relation
// @required
func (orgsQueryGroupsRelations) Some(
	params ...GroupsWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Orgs -> Groups
//
// @relation
// @required
func (orgsQueryGroupsRelations) Every(
	params ...GroupsWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Orgs -> Groups
//
// @relation
// @required
func (orgsQueryGroupsRelations) None(
	params ...GroupsWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (orgsQueryGroupsRelations) Fetch(

	params ...GroupsWhereParam,

) orgsToGroupsFindMany {
	var v orgsToGroupsFindMany

	v.query.Operation = "query"
	v.query.Method = "groups"
	v.query.Outputs = groupsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orgsQueryGroupsRelations) Link(
	params ...GroupsWhereParam,
) orgsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsSetParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r orgsQueryGroupsRelations) Unlink(
	params ...GroupsWhereParam,
) orgsSetParam {
	var v orgsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = orgsSetParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r orgsQueryGroupsgroups) Field() orgsPrismaFields {
	return orgsFieldGroups
}

// base struct
type orgsQueryGrouptreegrouptree struct{}

type orgsQueryGrouptreeRelations struct{}

// Orgs -> Grouptree
//
// @relation
// @required
func (orgsQueryGrouptreeRelations) Some(
	params ...GrouptreeWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "grouptree",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Orgs -> Grouptree
//
// @relation
// @required
func (orgsQueryGrouptreeRelations) Every(
	params ...GrouptreeWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "grouptree",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Orgs -> Grouptree
//
// @relation
// @required
func (orgsQueryGrouptreeRelations) None(
	params ...GrouptreeWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "grouptree",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (orgsQueryGrouptreeRelations) Fetch(

	params ...GrouptreeWhereParam,

) orgsToGrouptreeFindMany {
	var v orgsToGrouptreeFindMany

	v.query.Operation = "query"
	v.query.Method = "grouptree"
	v.query.Outputs = grouptreeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orgsQueryGrouptreeRelations) Link(
	params ...GrouptreeWhereParam,
) orgsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsSetParam{
		data: builder.Field{
			Name: "grouptree",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r orgsQueryGrouptreeRelations) Unlink(
	params ...GrouptreeWhereParam,
) orgsSetParam {
	var v orgsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = orgsSetParam{
		data: builder.Field{
			Name: "grouptree",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r orgsQueryGrouptreegrouptree) Field() orgsPrismaFields {
	return orgsFieldGrouptree
}

// base struct
type orgsQueryGroupuserpermsgroupuserperms struct{}

type orgsQueryGroupuserpermsRelations struct{}

// Orgs -> Groupuserperms
//
// @relation
// @required
func (orgsQueryGroupuserpermsRelations) Some(
	params ...GroupuserpermsWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Orgs -> Groupuserperms
//
// @relation
// @required
func (orgsQueryGroupuserpermsRelations) Every(
	params ...GroupuserpermsWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Orgs -> Groupuserperms
//
// @relation
// @required
func (orgsQueryGroupuserpermsRelations) None(
	params ...GroupuserpermsWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (orgsQueryGroupuserpermsRelations) Fetch(

	params ...GroupuserpermsWhereParam,

) orgsToGroupuserpermsFindMany {
	var v orgsToGroupuserpermsFindMany

	v.query.Operation = "query"
	v.query.Method = "groupuserperms"
	v.query.Outputs = groupuserpermsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orgsQueryGroupuserpermsRelations) Link(
	params ...GroupuserpermsWhereParam,
) orgsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsSetParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r orgsQueryGroupuserpermsRelations) Unlink(
	params ...GroupuserpermsWhereParam,
) orgsSetParam {
	var v orgsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = orgsSetParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r orgsQueryGroupuserpermsgroupuserperms) Field() orgsPrismaFields {
	return orgsFieldGroupuserperms
}

// base struct
type orgsQueryOrgdevicesorgdevices struct{}

type orgsQueryOrgdevicesRelations struct{}

// Orgs -> Orgdevices
//
// @relation
// @required
func (orgsQueryOrgdevicesRelations) Some(
	params ...OrgdevicesWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgdevices",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Orgs -> Orgdevices
//
// @relation
// @required
func (orgsQueryOrgdevicesRelations) Every(
	params ...OrgdevicesWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgdevices",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Orgs -> Orgdevices
//
// @relation
// @required
func (orgsQueryOrgdevicesRelations) None(
	params ...OrgdevicesWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgdevices",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (orgsQueryOrgdevicesRelations) Fetch(

	params ...OrgdevicesWhereParam,

) orgsToOrgdevicesFindMany {
	var v orgsToOrgdevicesFindMany

	v.query.Operation = "query"
	v.query.Method = "orgdevices"
	v.query.Outputs = orgdevicesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orgsQueryOrgdevicesRelations) Link(
	params ...OrgdevicesWhereParam,
) orgsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsSetParam{
		data: builder.Field{
			Name: "orgdevices",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r orgsQueryOrgdevicesRelations) Unlink(
	params ...OrgdevicesWhereParam,
) orgsSetParam {
	var v orgsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = orgsSetParam{
		data: builder.Field{
			Name: "orgdevices",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r orgsQueryOrgdevicesorgdevices) Field() orgsPrismaFields {
	return orgsFieldOrgdevices
}

// base struct
type orgsQueryOrgrgrouporgrgroup struct{}

type orgsQueryOrgrgroupRelations struct{}

// Orgs -> Orgrgroup
//
// @relation
// @optional
func (orgsQueryOrgrgroupRelations) Where(
	params ...OrgrgroupWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "orgrgroup",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (orgsQueryOrgrgroupRelations) Fetch() orgsToOrgrgroupFindUnique {
	var v orgsToOrgrgroupFindUnique

	v.query.Operation = "query"
	v.query.Method = "orgrgroup"
	v.query.Outputs = orgrgroupOutput

	return v
}

func (r orgsQueryOrgrgroupRelations) Link(
	params OrgrgroupWhereParam,
) orgsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return orgsSetParam{}
	}

	fields = append(fields, f)

	return orgsSetParam{
		data: builder.Field{
			Name: "orgrgroup",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r orgsQueryOrgrgroupRelations) Unlink() orgsSetParam {
	var v orgsSetParam

	v = orgsSetParam{
		data: builder.Field{
			Name: "orgrgroup",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r orgsQueryOrgrgrouporgrgroup) Field() orgsPrismaFields {
	return orgsFieldOrgrgroup
}

// base struct
type orgsQueryUsergroupusergroup struct{}

type orgsQueryUsergroupRelations struct{}

// Orgs -> Usergroup
//
// @relation
// @required
func (orgsQueryUsergroupRelations) Some(
	params ...UsergroupWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Orgs -> Usergroup
//
// @relation
// @required
func (orgsQueryUsergroupRelations) Every(
	params ...UsergroupWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Orgs -> Usergroup
//
// @relation
// @required
func (orgsQueryUsergroupRelations) None(
	params ...UsergroupWhereParam,
) orgsDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsDefaultParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (orgsQueryUsergroupRelations) Fetch(

	params ...UsergroupWhereParam,

) orgsToUsergroupFindMany {
	var v orgsToUsergroupFindMany

	v.query.Operation = "query"
	v.query.Method = "usergroup"
	v.query.Outputs = usergroupOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orgsQueryUsergroupRelations) Link(
	params ...UsergroupWhereParam,
) orgsSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return orgsSetParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r orgsQueryUsergroupRelations) Unlink(
	params ...UsergroupWhereParam,
) orgsSetParam {
	var v orgsSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = orgsSetParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r orgsQueryUsergroupusergroup) Field() orgsPrismaFields {
	return orgsFieldUsergroup
}

// Usergroup acts as a namespaces to access query methods for the Usergroup model
var Usergroup = usergroupQuery{}

// usergroupQuery exposes query functions for the usergroup model
type usergroupQuery struct {

	// Userid
	//
	// @required
	Userid usergroupQueryUseridString

	// Orgid
	//
	// @required
	Orgid usergroupQueryOrgidString

	// Groupid
	//
	// @required
	Groupid usergroupQueryGroupidString

	Groups usergroupQueryGroupsRelations

	Orgs usergroupQueryOrgsRelations

	Users usergroupQueryUsersRelations
}

func (usergroupQuery) Not(params ...UsergroupWhereParam) usergroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usergroupDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (usergroupQuery) Or(params ...UsergroupWhereParam) usergroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usergroupDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (usergroupQuery) And(params ...UsergroupWhereParam) usergroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usergroupDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (usergroupQuery) UseridOrgidGroupid(
	_userid UsergroupWithPrismaUseridWhereParam,

	_orgid UsergroupWithPrismaOrgidWhereParam,

	_groupid UsergroupWithPrismaGroupidWhereParam,
) UsergroupEqualsUniqueWhereParam {
	var fields []builder.Field

	fields = append(fields, _userid.field())
	fields = append(fields, _orgid.field())
	fields = append(fields, _groupid.field())

	return usergroupEqualsUniqueParam{
		data: builder.Field{
			Name:   "userid_orgid_groupid",
			Fields: builder.TransformEquals(fields),
		},
	}
}

// base struct
type usergroupQueryUseridString struct{}

// Set the required value of Userid
func (r usergroupQueryUseridString) Set(value string) usergroupSetParam {

	return usergroupSetParam{
		data: builder.Field{
			Name:  "userid",
			Value: value,
		},
	}

}

// Set the optional value of Userid dynamically
func (r usergroupQueryUseridString) SetIfPresent(value *String) usergroupSetParam {
	if value == nil {
		return usergroupSetParam{}
	}

	return r.Set(*value)
}

func (r usergroupQueryUseridString) Equals(value string) usergroupWithPrismaUseridEqualsParam {

	return usergroupWithPrismaUseridEqualsParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryUseridString) EqualsIfPresent(value *string) usergroupWithPrismaUseridEqualsParam {
	if value == nil {
		return usergroupWithPrismaUseridEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usergroupQueryUseridString) Order(direction SortOrder) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name:  "userid",
			Value: direction,
		},
	}
}

func (r usergroupQueryUseridString) Cursor(cursor string) usergroupCursorParam {
	return usergroupCursorParam{
		data: builder.Field{
			Name:  "userid",
			Value: cursor,
		},
	}
}

func (r usergroupQueryUseridString) In(value []string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryUseridString) InIfPresent(value []string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.In(value)
}

func (r usergroupQueryUseridString) NotIn(value []string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryUseridString) NotInIfPresent(value []string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usergroupQueryUseridString) Lt(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryUseridString) LtIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usergroupQueryUseridString) Lte(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryUseridString) LteIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usergroupQueryUseridString) Gt(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryUseridString) GtIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usergroupQueryUseridString) Gte(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryUseridString) GteIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usergroupQueryUseridString) Contains(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryUseridString) ContainsIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usergroupQueryUseridString) StartsWith(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryUseridString) StartsWithIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usergroupQueryUseridString) EndsWith(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryUseridString) EndsWithIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usergroupQueryUseridString) Mode(value QueryMode) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryUseridString) ModeIfPresent(value *QueryMode) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usergroupQueryUseridString) Not(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryUseridString) NotIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usergroupQueryUseridString) HasPrefix(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usergroupQueryUseridString) HasPrefixIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usergroupQueryUseridString) HasSuffix(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usergroupQueryUseridString) HasSuffixIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r usergroupQueryUseridString) Field() usergroupPrismaFields {
	return usergroupFieldUserid
}

// base struct
type usergroupQueryOrgidString struct{}

// Set the required value of Orgid
func (r usergroupQueryOrgidString) Set(value string) usergroupSetParam {

	return usergroupSetParam{
		data: builder.Field{
			Name:  "orgid",
			Value: value,
		},
	}

}

// Set the optional value of Orgid dynamically
func (r usergroupQueryOrgidString) SetIfPresent(value *String) usergroupSetParam {
	if value == nil {
		return usergroupSetParam{}
	}

	return r.Set(*value)
}

func (r usergroupQueryOrgidString) Equals(value string) usergroupWithPrismaOrgidEqualsParam {

	return usergroupWithPrismaOrgidEqualsParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryOrgidString) EqualsIfPresent(value *string) usergroupWithPrismaOrgidEqualsParam {
	if value == nil {
		return usergroupWithPrismaOrgidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usergroupQueryOrgidString) Order(direction SortOrder) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name:  "orgid",
			Value: direction,
		},
	}
}

func (r usergroupQueryOrgidString) Cursor(cursor string) usergroupCursorParam {
	return usergroupCursorParam{
		data: builder.Field{
			Name:  "orgid",
			Value: cursor,
		},
	}
}

func (r usergroupQueryOrgidString) In(value []string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryOrgidString) InIfPresent(value []string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.In(value)
}

func (r usergroupQueryOrgidString) NotIn(value []string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryOrgidString) NotInIfPresent(value []string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usergroupQueryOrgidString) Lt(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryOrgidString) LtIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usergroupQueryOrgidString) Lte(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryOrgidString) LteIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usergroupQueryOrgidString) Gt(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryOrgidString) GtIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usergroupQueryOrgidString) Gte(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryOrgidString) GteIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usergroupQueryOrgidString) Contains(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryOrgidString) ContainsIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usergroupQueryOrgidString) StartsWith(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryOrgidString) StartsWithIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usergroupQueryOrgidString) EndsWith(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryOrgidString) EndsWithIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usergroupQueryOrgidString) Mode(value QueryMode) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryOrgidString) ModeIfPresent(value *QueryMode) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usergroupQueryOrgidString) Not(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryOrgidString) NotIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usergroupQueryOrgidString) HasPrefix(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usergroupQueryOrgidString) HasPrefixIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usergroupQueryOrgidString) HasSuffix(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usergroupQueryOrgidString) HasSuffixIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r usergroupQueryOrgidString) Field() usergroupPrismaFields {
	return usergroupFieldOrgid
}

// base struct
type usergroupQueryGroupidString struct{}

// Set the required value of Groupid
func (r usergroupQueryGroupidString) Set(value string) usergroupSetParam {

	return usergroupSetParam{
		data: builder.Field{
			Name:  "groupid",
			Value: value,
		},
	}

}

// Set the optional value of Groupid dynamically
func (r usergroupQueryGroupidString) SetIfPresent(value *String) usergroupSetParam {
	if value == nil {
		return usergroupSetParam{}
	}

	return r.Set(*value)
}

func (r usergroupQueryGroupidString) Equals(value string) usergroupWithPrismaGroupidEqualsParam {

	return usergroupWithPrismaGroupidEqualsParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryGroupidString) EqualsIfPresent(value *string) usergroupWithPrismaGroupidEqualsParam {
	if value == nil {
		return usergroupWithPrismaGroupidEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usergroupQueryGroupidString) Order(direction SortOrder) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name:  "groupid",
			Value: direction,
		},
	}
}

func (r usergroupQueryGroupidString) Cursor(cursor string) usergroupCursorParam {
	return usergroupCursorParam{
		data: builder.Field{
			Name:  "groupid",
			Value: cursor,
		},
	}
}

func (r usergroupQueryGroupidString) In(value []string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryGroupidString) InIfPresent(value []string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.In(value)
}

func (r usergroupQueryGroupidString) NotIn(value []string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryGroupidString) NotInIfPresent(value []string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usergroupQueryGroupidString) Lt(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryGroupidString) LtIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usergroupQueryGroupidString) Lte(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryGroupidString) LteIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usergroupQueryGroupidString) Gt(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryGroupidString) GtIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usergroupQueryGroupidString) Gte(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryGroupidString) GteIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usergroupQueryGroupidString) Contains(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryGroupidString) ContainsIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usergroupQueryGroupidString) StartsWith(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryGroupidString) StartsWithIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usergroupQueryGroupidString) EndsWith(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryGroupidString) EndsWithIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usergroupQueryGroupidString) Mode(value QueryMode) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryGroupidString) ModeIfPresent(value *QueryMode) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usergroupQueryGroupidString) Not(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r usergroupQueryGroupidString) NotIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usergroupQueryGroupidString) HasPrefix(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usergroupQueryGroupidString) HasPrefixIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usergroupQueryGroupidString) HasSuffix(value string) usergroupDefaultParam {
	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groupid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usergroupQueryGroupidString) HasSuffixIfPresent(value *string) usergroupDefaultParam {
	if value == nil {
		return usergroupDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r usergroupQueryGroupidString) Field() usergroupPrismaFields {
	return usergroupFieldGroupid
}

// base struct
type usergroupQueryGroupsgroups struct{}

type usergroupQueryGroupsRelations struct{}

// Usergroup -> Groups
//
// @relation
// @required
func (usergroupQueryGroupsRelations) Where(
	params ...GroupsWhereParam,
) usergroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usergroupDefaultParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (usergroupQueryGroupsRelations) Fetch() usergroupToGroupsFindUnique {
	var v usergroupToGroupsFindUnique

	v.query.Operation = "query"
	v.query.Method = "groups"
	v.query.Outputs = groupsOutput

	return v
}

func (r usergroupQueryGroupsRelations) Link(
	params GroupsWhereParam,
) usergroupWithPrismaGroupsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return usergroupWithPrismaGroupsSetParam{}
	}

	fields = append(fields, f)

	return usergroupWithPrismaGroupsSetParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r usergroupQueryGroupsRelations) Unlink() usergroupWithPrismaGroupsSetParam {
	var v usergroupWithPrismaGroupsSetParam

	v = usergroupWithPrismaGroupsSetParam{
		data: builder.Field{
			Name: "groups",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r usergroupQueryGroupsgroups) Field() usergroupPrismaFields {
	return usergroupFieldGroups
}

// base struct
type usergroupQueryOrgsorgs struct{}

type usergroupQueryOrgsRelations struct{}

// Usergroup -> Orgs
//
// @relation
// @required
func (usergroupQueryOrgsRelations) Where(
	params ...OrgsWhereParam,
) usergroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usergroupDefaultParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (usergroupQueryOrgsRelations) Fetch() usergroupToOrgsFindUnique {
	var v usergroupToOrgsFindUnique

	v.query.Operation = "query"
	v.query.Method = "orgs"
	v.query.Outputs = orgsOutput

	return v
}

func (r usergroupQueryOrgsRelations) Link(
	params OrgsWhereParam,
) usergroupWithPrismaOrgsSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return usergroupWithPrismaOrgsSetParam{}
	}

	fields = append(fields, f)

	return usergroupWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r usergroupQueryOrgsRelations) Unlink() usergroupWithPrismaOrgsSetParam {
	var v usergroupWithPrismaOrgsSetParam

	v = usergroupWithPrismaOrgsSetParam{
		data: builder.Field{
			Name: "orgs",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r usergroupQueryOrgsorgs) Field() usergroupPrismaFields {
	return usergroupFieldOrgs
}

// base struct
type usergroupQueryUsersusers struct{}

type usergroupQueryUsersRelations struct{}

// Usergroup -> Users
//
// @relation
// @required
func (usergroupQueryUsersRelations) Where(
	params ...UsersWhereParam,
) usergroupDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usergroupDefaultParam{
		data: builder.Field{
			Name: "users",
			Fields: []builder.Field{
				{
					Name:   "is",
					Fields: fields,
				},
			},
		},
	}
}

func (usergroupQueryUsersRelations) Fetch() usergroupToUsersFindUnique {
	var v usergroupToUsersFindUnique

	v.query.Operation = "query"
	v.query.Method = "users"
	v.query.Outputs = usersOutput

	return v
}

func (r usergroupQueryUsersRelations) Link(
	params UsersWhereParam,
) usergroupWithPrismaUsersSetParam {
	var fields []builder.Field

	f := params.field()
	if f.Fields == nil && f.Value == nil {
		return usergroupWithPrismaUsersSetParam{}
	}

	fields = append(fields, f)

	return usergroupWithPrismaUsersSetParam{
		data: builder.Field{
			Name: "users",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),
				},
			},
		},
	}
}

func (r usergroupQueryUsersRelations) Unlink() usergroupWithPrismaUsersSetParam {
	var v usergroupWithPrismaUsersSetParam

	v = usergroupWithPrismaUsersSetParam{
		data: builder.Field{
			Name: "users",
			Fields: []builder.Field{
				{
					Name:  "disconnect",
					Value: true,
				},
			},
		},
	}

	return v
}

func (r usergroupQueryUsersusers) Field() usergroupPrismaFields {
	return usergroupFieldUsers
}

// Users acts as a namespaces to access query methods for the Users model
var Users = usersQuery{}

// usersQuery exposes query functions for the users model
type usersQuery struct {

	// Userid
	//
	// @required
	Userid usersQueryUseridString

	// Name
	//
	// @required
	Name usersQueryNameString

	// Email
	//
	// @required
	Email usersQueryEmailString

	// Isemailverified
	//
	// @required
	Isemailverified usersQueryIsemailverifiedBoolean

	// Usermeta
	//
	// @optional
	Usermeta usersQueryUsermetaJson

	// Isenabled
	//
	// @required
	Isenabled usersQueryIsenabledBoolean

	// Secretprv
	//
	// @required
	Secretprv usersQuerySecretprvString

	// Secretpub
	//
	// @required
	Secretpub usersQuerySecretpubString

	// Createdat
	//
	// @required
	Createdat usersQueryCreatedatBigInt

	// Updatedat
	//
	// @required
	Updatedat usersQueryUpdatedatBigInt

	Groupuserperms usersQueryGroupuserpermsRelations

	Usergroup usersQueryUsergroupRelations
}

func (usersQuery) Not(params ...UsersWhereParam) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name:     "NOT",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (usersQuery) Or(params ...UsersWhereParam) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name:     "OR",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

func (usersQuery) And(params ...UsersWhereParam) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name:     "AND",
			List:     true,
			WrapList: true,
			Fields:   fields,
		},
	}
}

// base struct
type usersQueryUseridString struct{}

// Set the required value of Userid
func (r usersQueryUseridString) Set(value string) usersWithPrismaUseridSetParam {

	return usersWithPrismaUseridSetParam{
		data: builder.Field{
			Name:  "userid",
			Value: value,
		},
	}

}

// Set the optional value of Userid dynamically
func (r usersQueryUseridString) SetIfPresent(value *String) usersWithPrismaUseridSetParam {
	if value == nil {
		return usersWithPrismaUseridSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryUseridString) Equals(value string) usersWithPrismaUseridEqualsUniqueParam {

	return usersWithPrismaUseridEqualsUniqueParam{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUseridString) EqualsIfPresent(value *string) usersWithPrismaUseridEqualsUniqueParam {
	if value == nil {
		return usersWithPrismaUseridEqualsUniqueParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryUseridString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "userid",
			Value: direction,
		},
	}
}

func (r usersQueryUseridString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "userid",
			Value: cursor,
		},
	}
}

func (r usersQueryUseridString) In(value []string) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUseridString) InIfPresent(value []string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.In(value)
}

func (r usersQueryUseridString) NotIn(value []string) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUseridString) NotInIfPresent(value []string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.NotIn(value)
}

func (r usersQueryUseridString) Lt(value string) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUseridString) LtIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Lt(*value)
}

func (r usersQueryUseridString) Lte(value string) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUseridString) LteIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Lte(*value)
}

func (r usersQueryUseridString) Gt(value string) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUseridString) GtIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Gt(*value)
}

func (r usersQueryUseridString) Gte(value string) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUseridString) GteIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Gte(*value)
}

func (r usersQueryUseridString) Contains(value string) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUseridString) ContainsIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Contains(*value)
}

func (r usersQueryUseridString) StartsWith(value string) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUseridString) StartsWithIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryUseridString) EndsWith(value string) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUseridString) EndsWithIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryUseridString) Mode(value QueryMode) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUseridString) ModeIfPresent(value *QueryMode) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Mode(*value)
}

func (r usersQueryUseridString) Not(value string) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUseridString) NotIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryUseridString) HasPrefix(value string) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryUseridString) HasPrefixIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryUseridString) HasSuffix(value string) usersParamUnique {
	return usersParamUnique{
		data: builder.Field{
			Name: "userid",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryUseridString) HasSuffixIfPresent(value *string) usersParamUnique {
	if value == nil {
		return usersParamUnique{}
	}
	return r.HasSuffix(*value)
}

func (r usersQueryUseridString) Field() usersPrismaFields {
	return usersFieldUserid
}

// base struct
type usersQueryNameString struct{}

// Set the required value of Name
func (r usersQueryNameString) Set(value string) usersWithPrismaNameSetParam {

	return usersWithPrismaNameSetParam{
		data: builder.Field{
			Name:  "name",
			Value: value,
		},
	}

}

// Set the optional value of Name dynamically
func (r usersQueryNameString) SetIfPresent(value *String) usersWithPrismaNameSetParam {
	if value == nil {
		return usersWithPrismaNameSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryNameString) Equals(value string) usersWithPrismaNameEqualsParam {

	return usersWithPrismaNameEqualsParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) EqualsIfPresent(value *string) usersWithPrismaNameEqualsParam {
	if value == nil {
		return usersWithPrismaNameEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryNameString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "name",
			Value: direction,
		},
	}
}

func (r usersQueryNameString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "name",
			Value: cursor,
		},
	}
}

func (r usersQueryNameString) In(value []string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryNameString) NotIn(value []string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryNameString) Lt(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryNameString) Lte(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryNameString) Gt(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryNameString) Gte(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryNameString) Contains(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryNameString) StartsWith(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryNameString) EndsWith(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryNameString) Mode(value QueryMode) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryNameString) Not(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryNameString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryNameString) HasPrefix(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryNameString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryNameString) HasSuffix(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "name",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryNameString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r usersQueryNameString) Field() usersPrismaFields {
	return usersFieldName
}

// base struct
type usersQueryEmailString struct{}

// Set the required value of Email
func (r usersQueryEmailString) Set(value string) usersWithPrismaEmailSetParam {

	return usersWithPrismaEmailSetParam{
		data: builder.Field{
			Name:  "email",
			Value: value,
		},
	}

}

// Set the optional value of Email dynamically
func (r usersQueryEmailString) SetIfPresent(value *String) usersWithPrismaEmailSetParam {
	if value == nil {
		return usersWithPrismaEmailSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryEmailString) Equals(value string) usersWithPrismaEmailEqualsParam {

	return usersWithPrismaEmailEqualsParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) EqualsIfPresent(value *string) usersWithPrismaEmailEqualsParam {
	if value == nil {
		return usersWithPrismaEmailEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryEmailString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "email",
			Value: direction,
		},
	}
}

func (r usersQueryEmailString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "email",
			Value: cursor,
		},
	}
}

func (r usersQueryEmailString) In(value []string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryEmailString) NotIn(value []string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryEmailString) Lt(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryEmailString) Lte(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryEmailString) Gt(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryEmailString) Gte(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryEmailString) Contains(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQueryEmailString) StartsWith(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQueryEmailString) EndsWith(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQueryEmailString) Mode(value QueryMode) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQueryEmailString) Not(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryEmailString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQueryEmailString) HasPrefix(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQueryEmailString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQueryEmailString) HasSuffix(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "email",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQueryEmailString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r usersQueryEmailString) Field() usersPrismaFields {
	return usersFieldEmail
}

// base struct
type usersQueryIsemailverifiedBoolean struct{}

// Set the required value of Isemailverified
func (r usersQueryIsemailverifiedBoolean) Set(value bool) usersWithPrismaIsemailverifiedSetParam {

	return usersWithPrismaIsemailverifiedSetParam{
		data: builder.Field{
			Name:  "isemailverified",
			Value: value,
		},
	}

}

// Set the optional value of Isemailverified dynamically
func (r usersQueryIsemailverifiedBoolean) SetIfPresent(value *Boolean) usersWithPrismaIsemailverifiedSetParam {
	if value == nil {
		return usersWithPrismaIsemailverifiedSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryIsemailverifiedBoolean) Equals(value bool) usersWithPrismaIsemailverifiedEqualsParam {

	return usersWithPrismaIsemailverifiedEqualsParam{
		data: builder.Field{
			Name: "isemailverified",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIsemailverifiedBoolean) EqualsIfPresent(value *bool) usersWithPrismaIsemailverifiedEqualsParam {
	if value == nil {
		return usersWithPrismaIsemailverifiedEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryIsemailverifiedBoolean) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "isemailverified",
			Value: direction,
		},
	}
}

func (r usersQueryIsemailverifiedBoolean) Cursor(cursor bool) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "isemailverified",
			Value: cursor,
		},
	}
}

func (r usersQueryIsemailverifiedBoolean) Field() usersPrismaFields {
	return usersFieldIsemailverified
}

// base struct
type usersQueryUsermetaJson struct{}

// Set the optional value of Usermeta
func (r usersQueryUsermetaJson) Set(value JSON) usersSetParam {

	return usersSetParam{
		data: builder.Field{
			Name:  "usermeta",
			Value: value,
		},
	}

}

// Set the optional value of Usermeta dynamically
func (r usersQueryUsermetaJson) SetIfPresent(value *JSON) usersSetParam {
	if value == nil {
		return usersSetParam{}
	}

	return r.Set(*value)
}

// Set the optional value of Usermeta dynamically
func (r usersQueryUsermetaJson) SetOptional(value *JSON) usersSetParam {
	if value == nil {

		var v *JSON
		return usersSetParam{
			data: builder.Field{
				Name:  "usermeta",
				Value: v,
			},
		}
	}

	return r.Set(*value)
}

func (r usersQueryUsermetaJson) Equals(value JSON) usersWithPrismaUsermetaEqualsParam {

	return usersWithPrismaUsermetaEqualsParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) EqualsIfPresent(value *JSON) usersWithPrismaUsermetaEqualsParam {
	if value == nil {
		return usersWithPrismaUsermetaEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryUsermetaJson) EqualsOptional(value *JSON) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) IsNull() usersDefaultParam {
	var str *string = nil
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: str,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "usermeta",
			Value: direction,
		},
	}
}

func (r usersQueryUsermetaJson) Cursor(cursor JSON) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "usermeta",
			Value: cursor,
		},
	}
}

func (r usersQueryUsermetaJson) Path(value []string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "path",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) PathIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Path(value)
}

func (r usersQueryUsermetaJson) StringContains(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "string_contains",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) StringContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StringContains(*value)
}

func (r usersQueryUsermetaJson) StringStartsWith(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "string_starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) StringStartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StringStartsWith(*value)
}

func (r usersQueryUsermetaJson) StringEndsWith(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "string_ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) StringEndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StringEndsWith(*value)
}

func (r usersQueryUsermetaJson) ArrayStartsWith(value JSON) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "array_starts_with",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) ArrayStartsWithIfPresent(value *JSON) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.ArrayStartsWith(*value)
}

func (r usersQueryUsermetaJson) ArrayEndsWith(value JSON) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "array_ends_with",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) ArrayEndsWithIfPresent(value *JSON) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.ArrayEndsWith(*value)
}

func (r usersQueryUsermetaJson) ArrayContains(value JSON) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "array_contains",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) ArrayContainsIfPresent(value *JSON) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.ArrayContains(*value)
}

func (r usersQueryUsermetaJson) Lt(value JSON) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) LtIfPresent(value *JSON) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryUsermetaJson) Lte(value JSON) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) LteIfPresent(value *JSON) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryUsermetaJson) Gt(value JSON) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) GtIfPresent(value *JSON) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryUsermetaJson) Gte(value JSON) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) GteIfPresent(value *JSON) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryUsermetaJson) Not(value JSONNullValueFilter) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "usermeta",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUsermetaJson) NotIfPresent(value *JSONNullValueFilter) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

func (r usersQueryUsermetaJson) Field() usersPrismaFields {
	return usersFieldUsermeta
}

// base struct
type usersQueryIsenabledBoolean struct{}

// Set the required value of Isenabled
func (r usersQueryIsenabledBoolean) Set(value bool) usersWithPrismaIsenabledSetParam {

	return usersWithPrismaIsenabledSetParam{
		data: builder.Field{
			Name:  "isenabled",
			Value: value,
		},
	}

}

// Set the optional value of Isenabled dynamically
func (r usersQueryIsenabledBoolean) SetIfPresent(value *Boolean) usersWithPrismaIsenabledSetParam {
	if value == nil {
		return usersWithPrismaIsenabledSetParam{}
	}

	return r.Set(*value)
}

func (r usersQueryIsenabledBoolean) Equals(value bool) usersWithPrismaIsenabledEqualsParam {

	return usersWithPrismaIsenabledEqualsParam{
		data: builder.Field{
			Name: "isenabled",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryIsenabledBoolean) EqualsIfPresent(value *bool) usersWithPrismaIsenabledEqualsParam {
	if value == nil {
		return usersWithPrismaIsenabledEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryIsenabledBoolean) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "isenabled",
			Value: direction,
		},
	}
}

func (r usersQueryIsenabledBoolean) Cursor(cursor bool) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "isenabled",
			Value: cursor,
		},
	}
}

func (r usersQueryIsenabledBoolean) Field() usersPrismaFields {
	return usersFieldIsenabled
}

// base struct
type usersQuerySecretprvString struct{}

// Set the required value of Secretprv
func (r usersQuerySecretprvString) Set(value string) usersWithPrismaSecretprvSetParam {

	return usersWithPrismaSecretprvSetParam{
		data: builder.Field{
			Name:  "secretprv",
			Value: value,
		},
	}

}

// Set the optional value of Secretprv dynamically
func (r usersQuerySecretprvString) SetIfPresent(value *String) usersWithPrismaSecretprvSetParam {
	if value == nil {
		return usersWithPrismaSecretprvSetParam{}
	}

	return r.Set(*value)
}

func (r usersQuerySecretprvString) Equals(value string) usersWithPrismaSecretprvEqualsParam {

	return usersWithPrismaSecretprvEqualsParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretprvString) EqualsIfPresent(value *string) usersWithPrismaSecretprvEqualsParam {
	if value == nil {
		return usersWithPrismaSecretprvEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQuerySecretprvString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "secretprv",
			Value: direction,
		},
	}
}

func (r usersQuerySecretprvString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "secretprv",
			Value: cursor,
		},
	}
}

func (r usersQuerySecretprvString) In(value []string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretprvString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQuerySecretprvString) NotIn(value []string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretprvString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQuerySecretprvString) Lt(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretprvString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQuerySecretprvString) Lte(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretprvString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQuerySecretprvString) Gt(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretprvString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQuerySecretprvString) Gte(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretprvString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQuerySecretprvString) Contains(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretprvString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQuerySecretprvString) StartsWith(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretprvString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQuerySecretprvString) EndsWith(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretprvString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQuerySecretprvString) Mode(value QueryMode) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretprvString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQuerySecretprvString) Not(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretprvString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQuerySecretprvString) HasPrefix(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQuerySecretprvString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQuerySecretprvString) HasSuffix(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretprv",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQuerySecretprvString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r usersQuerySecretprvString) Field() usersPrismaFields {
	return usersFieldSecretprv
}

// base struct
type usersQuerySecretpubString struct{}

// Set the required value of Secretpub
func (r usersQuerySecretpubString) Set(value string) usersWithPrismaSecretpubSetParam {

	return usersWithPrismaSecretpubSetParam{
		data: builder.Field{
			Name:  "secretpub",
			Value: value,
		},
	}

}

// Set the optional value of Secretpub dynamically
func (r usersQuerySecretpubString) SetIfPresent(value *String) usersWithPrismaSecretpubSetParam {
	if value == nil {
		return usersWithPrismaSecretpubSetParam{}
	}

	return r.Set(*value)
}

func (r usersQuerySecretpubString) Equals(value string) usersWithPrismaSecretpubEqualsParam {

	return usersWithPrismaSecretpubEqualsParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretpubString) EqualsIfPresent(value *string) usersWithPrismaSecretpubEqualsParam {
	if value == nil {
		return usersWithPrismaSecretpubEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQuerySecretpubString) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "secretpub",
			Value: direction,
		},
	}
}

func (r usersQuerySecretpubString) Cursor(cursor string) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "secretpub",
			Value: cursor,
		},
	}
}

func (r usersQuerySecretpubString) In(value []string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretpubString) InIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQuerySecretpubString) NotIn(value []string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretpubString) NotInIfPresent(value []string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQuerySecretpubString) Lt(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretpubString) LtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQuerySecretpubString) Lte(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretpubString) LteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQuerySecretpubString) Gt(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretpubString) GtIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQuerySecretpubString) Gte(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretpubString) GteIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQuerySecretpubString) Contains(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "contains",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretpubString) ContainsIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Contains(*value)
}

func (r usersQuerySecretpubString) StartsWith(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "startsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretpubString) StartsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.StartsWith(*value)
}

func (r usersQuerySecretpubString) EndsWith(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "endsWith",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretpubString) EndsWithIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.EndsWith(*value)
}

func (r usersQuerySecretpubString) Mode(value QueryMode) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "mode",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretpubString) ModeIfPresent(value *QueryMode) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Mode(*value)
}

func (r usersQuerySecretpubString) Not(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r usersQuerySecretpubString) NotIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

// deprecated: Use StartsWith instead.

func (r usersQuerySecretpubString) HasPrefix(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "starts_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use StartsWithIfPresent instead.
func (r usersQuerySecretpubString) HasPrefixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasPrefix(*value)
}

// deprecated: Use EndsWith instead.

func (r usersQuerySecretpubString) HasSuffix(value string) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "secretpub",
			Fields: []builder.Field{
				{
					Name:  "ends_with",
					Value: value,
				},
			},
		},
	}
}

// deprecated: Use EndsWithIfPresent instead.
func (r usersQuerySecretpubString) HasSuffixIfPresent(value *string) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.HasSuffix(*value)
}

func (r usersQuerySecretpubString) Field() usersPrismaFields {
	return usersFieldSecretpub
}

// base struct
type usersQueryCreatedatBigInt struct{}

// Set the required value of Createdat
func (r usersQueryCreatedatBigInt) Set(value BigInt) usersWithPrismaCreatedatSetParam {

	return usersWithPrismaCreatedatSetParam{
		data: builder.Field{
			Name:  "createdat",
			Value: value,
		},
	}

}

// Set the optional value of Createdat dynamically
func (r usersQueryCreatedatBigInt) SetIfPresent(value *BigInt) usersWithPrismaCreatedatSetParam {
	if value == nil {
		return usersWithPrismaCreatedatSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Createdat
func (r usersQueryCreatedatBigInt) Increment(value BigInt) usersWithPrismaCreatedatSetParam {
	return usersWithPrismaCreatedatSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedatBigInt) IncrementIfPresent(value *BigInt) usersWithPrismaCreatedatSetParam {
	if value == nil {
		return usersWithPrismaCreatedatSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Createdat
func (r usersQueryCreatedatBigInt) Decrement(value BigInt) usersWithPrismaCreatedatSetParam {
	return usersWithPrismaCreatedatSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedatBigInt) DecrementIfPresent(value *BigInt) usersWithPrismaCreatedatSetParam {
	if value == nil {
		return usersWithPrismaCreatedatSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Createdat
func (r usersQueryCreatedatBigInt) Multiply(value BigInt) usersWithPrismaCreatedatSetParam {
	return usersWithPrismaCreatedatSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedatBigInt) MultiplyIfPresent(value *BigInt) usersWithPrismaCreatedatSetParam {
	if value == nil {
		return usersWithPrismaCreatedatSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Createdat
func (r usersQueryCreatedatBigInt) Divide(value BigInt) usersWithPrismaCreatedatSetParam {
	return usersWithPrismaCreatedatSetParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedatBigInt) DivideIfPresent(value *BigInt) usersWithPrismaCreatedatSetParam {
	if value == nil {
		return usersWithPrismaCreatedatSetParam{}
	}
	return r.Divide(*value)
}

func (r usersQueryCreatedatBigInt) Equals(value BigInt) usersWithPrismaCreatedatEqualsParam {

	return usersWithPrismaCreatedatEqualsParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedatBigInt) EqualsIfPresent(value *BigInt) usersWithPrismaCreatedatEqualsParam {
	if value == nil {
		return usersWithPrismaCreatedatEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryCreatedatBigInt) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "createdat",
			Value: direction,
		},
	}
}

func (r usersQueryCreatedatBigInt) Cursor(cursor BigInt) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "createdat",
			Value: cursor,
		},
	}
}

func (r usersQueryCreatedatBigInt) In(value []BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedatBigInt) InIfPresent(value []BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryCreatedatBigInt) NotIn(value []BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedatBigInt) NotInIfPresent(value []BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryCreatedatBigInt) Lt(value BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedatBigInt) LtIfPresent(value *BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryCreatedatBigInt) Lte(value BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedatBigInt) LteIfPresent(value *BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryCreatedatBigInt) Gt(value BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedatBigInt) GtIfPresent(value *BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryCreatedatBigInt) Gte(value BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedatBigInt) GteIfPresent(value *BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryCreatedatBigInt) Not(value BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "createdat",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryCreatedatBigInt) NotIfPresent(value *BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

func (r usersQueryCreatedatBigInt) Field() usersPrismaFields {
	return usersFieldCreatedat
}

// base struct
type usersQueryUpdatedatBigInt struct{}

// Set the required value of Updatedat
func (r usersQueryUpdatedatBigInt) Set(value BigInt) usersWithPrismaUpdatedatSetParam {

	return usersWithPrismaUpdatedatSetParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: value,
		},
	}

}

// Set the optional value of Updatedat dynamically
func (r usersQueryUpdatedatBigInt) SetIfPresent(value *BigInt) usersWithPrismaUpdatedatSetParam {
	if value == nil {
		return usersWithPrismaUpdatedatSetParam{}
	}

	return r.Set(*value)
}

// Increment the required value of Updatedat
func (r usersQueryUpdatedatBigInt) Increment(value BigInt) usersWithPrismaUpdatedatSetParam {
	return usersWithPrismaUpdatedatSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "increment",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedatBigInt) IncrementIfPresent(value *BigInt) usersWithPrismaUpdatedatSetParam {
	if value == nil {
		return usersWithPrismaUpdatedatSetParam{}
	}
	return r.Increment(*value)
}

// Decrement the required value of Updatedat
func (r usersQueryUpdatedatBigInt) Decrement(value BigInt) usersWithPrismaUpdatedatSetParam {
	return usersWithPrismaUpdatedatSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "decrement",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedatBigInt) DecrementIfPresent(value *BigInt) usersWithPrismaUpdatedatSetParam {
	if value == nil {
		return usersWithPrismaUpdatedatSetParam{}
	}
	return r.Decrement(*value)
}

// Multiply the required value of Updatedat
func (r usersQueryUpdatedatBigInt) Multiply(value BigInt) usersWithPrismaUpdatedatSetParam {
	return usersWithPrismaUpdatedatSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "multiply",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedatBigInt) MultiplyIfPresent(value *BigInt) usersWithPrismaUpdatedatSetParam {
	if value == nil {
		return usersWithPrismaUpdatedatSetParam{}
	}
	return r.Multiply(*value)
}

// Divide the required value of Updatedat
func (r usersQueryUpdatedatBigInt) Divide(value BigInt) usersWithPrismaUpdatedatSetParam {
	return usersWithPrismaUpdatedatSetParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				builder.Field{
					Name:  "divide",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedatBigInt) DivideIfPresent(value *BigInt) usersWithPrismaUpdatedatSetParam {
	if value == nil {
		return usersWithPrismaUpdatedatSetParam{}
	}
	return r.Divide(*value)
}

func (r usersQueryUpdatedatBigInt) Equals(value BigInt) usersWithPrismaUpdatedatEqualsParam {

	return usersWithPrismaUpdatedatEqualsParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "equals",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedatBigInt) EqualsIfPresent(value *BigInt) usersWithPrismaUpdatedatEqualsParam {
	if value == nil {
		return usersWithPrismaUpdatedatEqualsParam{}
	}
	return r.Equals(*value)
}

func (r usersQueryUpdatedatBigInt) Order(direction SortOrder) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: direction,
		},
	}
}

func (r usersQueryUpdatedatBigInt) Cursor(cursor BigInt) usersCursorParam {
	return usersCursorParam{
		data: builder.Field{
			Name:  "updatedat",
			Value: cursor,
		},
	}
}

func (r usersQueryUpdatedatBigInt) In(value []BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "in",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedatBigInt) InIfPresent(value []BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.In(value)
}

func (r usersQueryUpdatedatBigInt) NotIn(value []BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "notIn",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedatBigInt) NotInIfPresent(value []BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.NotIn(value)
}

func (r usersQueryUpdatedatBigInt) Lt(value BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedatBigInt) LtIfPresent(value *BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lt(*value)
}

func (r usersQueryUpdatedatBigInt) Lte(value BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "lte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedatBigInt) LteIfPresent(value *BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Lte(*value)
}

func (r usersQueryUpdatedatBigInt) Gt(value BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gt",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedatBigInt) GtIfPresent(value *BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gt(*value)
}

func (r usersQueryUpdatedatBigInt) Gte(value BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "gte",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedatBigInt) GteIfPresent(value *BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Gte(*value)
}

func (r usersQueryUpdatedatBigInt) Not(value BigInt) usersDefaultParam {
	return usersDefaultParam{
		data: builder.Field{
			Name: "updatedat",
			Fields: []builder.Field{
				{
					Name:  "not",
					Value: value,
				},
			},
		},
	}
}

func (r usersQueryUpdatedatBigInt) NotIfPresent(value *BigInt) usersDefaultParam {
	if value == nil {
		return usersDefaultParam{}
	}
	return r.Not(*value)
}

func (r usersQueryUpdatedatBigInt) Field() usersPrismaFields {
	return usersFieldUpdatedat
}

// base struct
type usersQueryGroupuserpermsgroupuserperms struct{}

type usersQueryGroupuserpermsRelations struct{}

// Users -> Groupuserperms
//
// @relation
// @required
func (usersQueryGroupuserpermsRelations) Some(
	params ...GroupuserpermsWhereParam,
) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Users -> Groupuserperms
//
// @relation
// @required
func (usersQueryGroupuserpermsRelations) Every(
	params ...GroupuserpermsWhereParam,
) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Users -> Groupuserperms
//
// @relation
// @required
func (usersQueryGroupuserpermsRelations) None(
	params ...GroupuserpermsWhereParam,
) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (usersQueryGroupuserpermsRelations) Fetch(

	params ...GroupuserpermsWhereParam,

) usersToGroupuserpermsFindMany {
	var v usersToGroupuserpermsFindMany

	v.query.Operation = "query"
	v.query.Method = "groupuserperms"
	v.query.Outputs = groupuserpermsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r usersQueryGroupuserpermsRelations) Link(
	params ...GroupuserpermsWhereParam,
) usersSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersSetParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r usersQueryGroupuserpermsRelations) Unlink(
	params ...GroupuserpermsWhereParam,
) usersSetParam {
	var v usersSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = usersSetParam{
		data: builder.Field{
			Name: "groupuserperms",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r usersQueryGroupuserpermsgroupuserperms) Field() usersPrismaFields {
	return usersFieldGroupuserperms
}

// base struct
type usersQueryUsergroupusergroup struct{}

type usersQueryUsergroupRelations struct{}

// Users -> Usergroup
//
// @relation
// @required
func (usersQueryUsergroupRelations) Some(
	params ...UsergroupWhereParam,
) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:   "some",
					Fields: fields,
				},
			},
		},
	}
}

// Users -> Usergroup
//
// @relation
// @required
func (usersQueryUsergroupRelations) Every(
	params ...UsergroupWhereParam,
) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:   "every",
					Fields: fields,
				},
			},
		},
	}
}

// Users -> Usergroup
//
// @relation
// @required
func (usersQueryUsergroupRelations) None(
	params ...UsergroupWhereParam,
) usersDefaultParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersDefaultParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:   "none",
					Fields: fields,
				},
			},
		},
	}
}

func (usersQueryUsergroupRelations) Fetch(

	params ...UsergroupWhereParam,

) usersToUsergroupFindMany {
	var v usersToUsergroupFindMany

	v.query.Operation = "query"
	v.query.Method = "usergroup"
	v.query.Outputs = usergroupOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r usersQueryUsergroupRelations) Link(
	params ...UsergroupWhereParam,
) usersSetParam {
	var fields []builder.Field

	for _, q := range params {
		fields = append(fields, q.field())
	}

	return usersSetParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:   "connect",
					Fields: builder.TransformEquals(fields),

					List:     true,
					WrapList: true,
				},
			},
		},
	}
}

func (r usersQueryUsergroupRelations) Unlink(
	params ...UsergroupWhereParam,
) usersSetParam {
	var v usersSetParam

	var fields []builder.Field
	for _, q := range params {
		fields = append(fields, q.field())
	}
	v = usersSetParam{
		data: builder.Field{
			Name: "usergroup",
			Fields: []builder.Field{
				{
					Name:     "disconnect",
					List:     true,
					WrapList: true,
					Fields:   builder.TransformEquals(fields),
				},
			},
		},
	}

	return v
}

func (r usersQueryUsergroupusergroup) Field() usersPrismaFields {
	return usersFieldUsergroup
}

// --- template actions.gotpl ---
var countOutput = []builder.Output{
	{Name: "count"},
}

type activitylogActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var activitylogOutput = []builder.Output{
	{Name: "auditid"},
	{Name: "msgtype"},
	{Name: "msgpayload"},
	{Name: "updatedat"},
}

type ActivitylogRelationWith interface {
	getQuery() builder.Query
	with()
	activitylogRelation()
}

type ActivitylogWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	activitylogModel()
}

type activitylogDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogDefaultParam) field() builder.Field {
	return p.data
}

func (p activitylogDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogDefaultParam) activitylogModel() {}

type ActivitylogOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	activitylogModel()
}

type activitylogOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogOrderByParam) field() builder.Field {
	return p.data
}

func (p activitylogOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogOrderByParam) activitylogModel() {}

type ActivitylogCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	activitylogModel()
	isCursor()
}

type activitylogCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogCursorParam) field() builder.Field {
	return p.data
}

func (p activitylogCursorParam) isCursor() {}

func (p activitylogCursorParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogCursorParam) activitylogModel() {}

type ActivitylogParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	activitylogModel()
}

type activitylogParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogParamUnique) activitylogModel() {}

func (activitylogParamUnique) unique() {}

func (p activitylogParamUnique) field() builder.Field {
	return p.data
}

func (p activitylogParamUnique) getQuery() builder.Query {
	return p.query
}

type ActivitylogEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	activitylogModel()
}

type activitylogEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogEqualsParam) activitylogModel() {}

func (activitylogEqualsParam) equals() {}

func (p activitylogEqualsParam) field() builder.Field {
	return p.data
}

func (p activitylogEqualsParam) getQuery() builder.Query {
	return p.query
}

type ActivitylogEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	activitylogModel()
}

type activitylogEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogEqualsUniqueParam) activitylogModel() {}

func (activitylogEqualsUniqueParam) unique() {}
func (activitylogEqualsUniqueParam) equals() {}

func (p activitylogEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p activitylogEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type ActivitylogSetParam interface {
	field() builder.Field
	settable()
	activitylogModel()
}

type activitylogSetParam struct {
	data builder.Field
}

func (activitylogSetParam) settable() {}

func (p activitylogSetParam) field() builder.Field {
	return p.data
}

func (p activitylogSetParam) activitylogModel() {}

type ActivitylogWithPrismaAuditidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	activitylogModel()
	auditidField()
}

type ActivitylogWithPrismaAuditidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	activitylogModel()
	auditidField()
}

type activitylogWithPrismaAuditidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogWithPrismaAuditidSetParam) field() builder.Field {
	return p.data
}

func (p activitylogWithPrismaAuditidSetParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogWithPrismaAuditidSetParam) activitylogModel() {}

func (p activitylogWithPrismaAuditidSetParam) auditidField() {}

type ActivitylogWithPrismaAuditidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	activitylogModel()
	auditidField()
}

type activitylogWithPrismaAuditidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogWithPrismaAuditidEqualsParam) field() builder.Field {
	return p.data
}

func (p activitylogWithPrismaAuditidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogWithPrismaAuditidEqualsParam) activitylogModel() {}

func (p activitylogWithPrismaAuditidEqualsParam) auditidField() {}

func (activitylogWithPrismaAuditidSetParam) settable()  {}
func (activitylogWithPrismaAuditidEqualsParam) equals() {}

type activitylogWithPrismaAuditidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogWithPrismaAuditidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p activitylogWithPrismaAuditidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogWithPrismaAuditidEqualsUniqueParam) activitylogModel() {}
func (p activitylogWithPrismaAuditidEqualsUniqueParam) auditidField()     {}

func (activitylogWithPrismaAuditidEqualsUniqueParam) unique() {}
func (activitylogWithPrismaAuditidEqualsUniqueParam) equals() {}

type ActivitylogWithPrismaMsgtypeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	activitylogModel()
	msgtypeField()
}

type ActivitylogWithPrismaMsgtypeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	activitylogModel()
	msgtypeField()
}

type activitylogWithPrismaMsgtypeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogWithPrismaMsgtypeSetParam) field() builder.Field {
	return p.data
}

func (p activitylogWithPrismaMsgtypeSetParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogWithPrismaMsgtypeSetParam) activitylogModel() {}

func (p activitylogWithPrismaMsgtypeSetParam) msgtypeField() {}

type ActivitylogWithPrismaMsgtypeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	activitylogModel()
	msgtypeField()
}

type activitylogWithPrismaMsgtypeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogWithPrismaMsgtypeEqualsParam) field() builder.Field {
	return p.data
}

func (p activitylogWithPrismaMsgtypeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogWithPrismaMsgtypeEqualsParam) activitylogModel() {}

func (p activitylogWithPrismaMsgtypeEqualsParam) msgtypeField() {}

func (activitylogWithPrismaMsgtypeSetParam) settable()  {}
func (activitylogWithPrismaMsgtypeEqualsParam) equals() {}

type activitylogWithPrismaMsgtypeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogWithPrismaMsgtypeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p activitylogWithPrismaMsgtypeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogWithPrismaMsgtypeEqualsUniqueParam) activitylogModel() {}
func (p activitylogWithPrismaMsgtypeEqualsUniqueParam) msgtypeField()     {}

func (activitylogWithPrismaMsgtypeEqualsUniqueParam) unique() {}
func (activitylogWithPrismaMsgtypeEqualsUniqueParam) equals() {}

type ActivitylogWithPrismaMsgpayloadEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	activitylogModel()
	msgpayloadField()
}

type ActivitylogWithPrismaMsgpayloadSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	activitylogModel()
	msgpayloadField()
}

type activitylogWithPrismaMsgpayloadSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogWithPrismaMsgpayloadSetParam) field() builder.Field {
	return p.data
}

func (p activitylogWithPrismaMsgpayloadSetParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogWithPrismaMsgpayloadSetParam) activitylogModel() {}

func (p activitylogWithPrismaMsgpayloadSetParam) msgpayloadField() {}

type ActivitylogWithPrismaMsgpayloadWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	activitylogModel()
	msgpayloadField()
}

type activitylogWithPrismaMsgpayloadEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogWithPrismaMsgpayloadEqualsParam) field() builder.Field {
	return p.data
}

func (p activitylogWithPrismaMsgpayloadEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogWithPrismaMsgpayloadEqualsParam) activitylogModel() {}

func (p activitylogWithPrismaMsgpayloadEqualsParam) msgpayloadField() {}

func (activitylogWithPrismaMsgpayloadSetParam) settable()  {}
func (activitylogWithPrismaMsgpayloadEqualsParam) equals() {}

type activitylogWithPrismaMsgpayloadEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogWithPrismaMsgpayloadEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p activitylogWithPrismaMsgpayloadEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogWithPrismaMsgpayloadEqualsUniqueParam) activitylogModel() {}
func (p activitylogWithPrismaMsgpayloadEqualsUniqueParam) msgpayloadField()  {}

func (activitylogWithPrismaMsgpayloadEqualsUniqueParam) unique() {}
func (activitylogWithPrismaMsgpayloadEqualsUniqueParam) equals() {}

type ActivitylogWithPrismaUpdatedatEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	activitylogModel()
	updatedatField()
}

type ActivitylogWithPrismaUpdatedatSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	activitylogModel()
	updatedatField()
}

type activitylogWithPrismaUpdatedatSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogWithPrismaUpdatedatSetParam) field() builder.Field {
	return p.data
}

func (p activitylogWithPrismaUpdatedatSetParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogWithPrismaUpdatedatSetParam) activitylogModel() {}

func (p activitylogWithPrismaUpdatedatSetParam) updatedatField() {}

type ActivitylogWithPrismaUpdatedatWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	activitylogModel()
	updatedatField()
}

type activitylogWithPrismaUpdatedatEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogWithPrismaUpdatedatEqualsParam) field() builder.Field {
	return p.data
}

func (p activitylogWithPrismaUpdatedatEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogWithPrismaUpdatedatEqualsParam) activitylogModel() {}

func (p activitylogWithPrismaUpdatedatEqualsParam) updatedatField() {}

func (activitylogWithPrismaUpdatedatSetParam) settable()  {}
func (activitylogWithPrismaUpdatedatEqualsParam) equals() {}

type activitylogWithPrismaUpdatedatEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p activitylogWithPrismaUpdatedatEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p activitylogWithPrismaUpdatedatEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p activitylogWithPrismaUpdatedatEqualsUniqueParam) activitylogModel() {}
func (p activitylogWithPrismaUpdatedatEqualsUniqueParam) updatedatField()   {}

func (activitylogWithPrismaUpdatedatEqualsUniqueParam) unique() {}
func (activitylogWithPrismaUpdatedatEqualsUniqueParam) equals() {}

type devicesActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var devicesOutput = []builder.Output{
	{Name: "deviceid"},
	{Name: "devicemeta"},
	{Name: "createdat"},
	{Name: "createdby"},
	{Name: "updatedat"},
	{Name: "updatedby"},
}

type DevicesRelationWith interface {
	getQuery() builder.Query
	with()
	devicesRelation()
}

type DevicesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
}

type devicesDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesDefaultParam) field() builder.Field {
	return p.data
}

func (p devicesDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p devicesDefaultParam) devicesModel() {}

type DevicesOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
}

type devicesOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesOrderByParam) field() builder.Field {
	return p.data
}

func (p devicesOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p devicesOrderByParam) devicesModel() {}

type DevicesCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	isCursor()
}

type devicesCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesCursorParam) field() builder.Field {
	return p.data
}

func (p devicesCursorParam) isCursor() {}

func (p devicesCursorParam) getQuery() builder.Query {
	return p.query
}

func (p devicesCursorParam) devicesModel() {}

type DevicesParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	devicesModel()
}

type devicesParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p devicesParamUnique) devicesModel() {}

func (devicesParamUnique) unique() {}

func (p devicesParamUnique) field() builder.Field {
	return p.data
}

func (p devicesParamUnique) getQuery() builder.Query {
	return p.query
}

type DevicesEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesModel()
}

type devicesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesEqualsParam) devicesModel() {}

func (devicesEqualsParam) equals() {}

func (p devicesEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesEqualsParam) getQuery() builder.Query {
	return p.query
}

type DevicesEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	devicesModel()
}

type devicesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesEqualsUniqueParam) devicesModel() {}

func (devicesEqualsUniqueParam) unique() {}
func (devicesEqualsUniqueParam) equals() {}

func (p devicesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type DevicesSetParam interface {
	field() builder.Field
	settable()
	devicesModel()
}

type devicesSetParam struct {
	data builder.Field
}

func (devicesSetParam) settable() {}

func (p devicesSetParam) field() builder.Field {
	return p.data
}

func (p devicesSetParam) devicesModel() {}

type DevicesWithPrismaDeviceidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesModel()
	deviceidField()
}

type DevicesWithPrismaDeviceidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	deviceidField()
}

type devicesWithPrismaDeviceidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaDeviceidSetParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaDeviceidSetParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaDeviceidSetParam) devicesModel() {}

func (p devicesWithPrismaDeviceidSetParam) deviceidField() {}

type DevicesWithPrismaDeviceidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	deviceidField()
}

type devicesWithPrismaDeviceidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaDeviceidEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaDeviceidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaDeviceidEqualsParam) devicesModel() {}

func (p devicesWithPrismaDeviceidEqualsParam) deviceidField() {}

func (devicesWithPrismaDeviceidSetParam) settable()  {}
func (devicesWithPrismaDeviceidEqualsParam) equals() {}

type devicesWithPrismaDeviceidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaDeviceidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaDeviceidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaDeviceidEqualsUniqueParam) devicesModel()  {}
func (p devicesWithPrismaDeviceidEqualsUniqueParam) deviceidField() {}

func (devicesWithPrismaDeviceidEqualsUniqueParam) unique() {}
func (devicesWithPrismaDeviceidEqualsUniqueParam) equals() {}

type DevicesWithPrismaDevicemetaEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesModel()
	devicemetaField()
}

type DevicesWithPrismaDevicemetaSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	devicemetaField()
}

type devicesWithPrismaDevicemetaSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaDevicemetaSetParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaDevicemetaSetParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaDevicemetaSetParam) devicesModel() {}

func (p devicesWithPrismaDevicemetaSetParam) devicemetaField() {}

type DevicesWithPrismaDevicemetaWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	devicemetaField()
}

type devicesWithPrismaDevicemetaEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaDevicemetaEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaDevicemetaEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaDevicemetaEqualsParam) devicesModel() {}

func (p devicesWithPrismaDevicemetaEqualsParam) devicemetaField() {}

func (devicesWithPrismaDevicemetaSetParam) settable()  {}
func (devicesWithPrismaDevicemetaEqualsParam) equals() {}

type devicesWithPrismaDevicemetaEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaDevicemetaEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaDevicemetaEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaDevicemetaEqualsUniqueParam) devicesModel()    {}
func (p devicesWithPrismaDevicemetaEqualsUniqueParam) devicemetaField() {}

func (devicesWithPrismaDevicemetaEqualsUniqueParam) unique() {}
func (devicesWithPrismaDevicemetaEqualsUniqueParam) equals() {}

type DevicesWithPrismaCreatedatEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesModel()
	createdatField()
}

type DevicesWithPrismaCreatedatSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	createdatField()
}

type devicesWithPrismaCreatedatSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaCreatedatSetParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaCreatedatSetParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaCreatedatSetParam) devicesModel() {}

func (p devicesWithPrismaCreatedatSetParam) createdatField() {}

type DevicesWithPrismaCreatedatWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	createdatField()
}

type devicesWithPrismaCreatedatEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaCreatedatEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaCreatedatEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaCreatedatEqualsParam) devicesModel() {}

func (p devicesWithPrismaCreatedatEqualsParam) createdatField() {}

func (devicesWithPrismaCreatedatSetParam) settable()  {}
func (devicesWithPrismaCreatedatEqualsParam) equals() {}

type devicesWithPrismaCreatedatEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaCreatedatEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaCreatedatEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaCreatedatEqualsUniqueParam) devicesModel()   {}
func (p devicesWithPrismaCreatedatEqualsUniqueParam) createdatField() {}

func (devicesWithPrismaCreatedatEqualsUniqueParam) unique() {}
func (devicesWithPrismaCreatedatEqualsUniqueParam) equals() {}

type DevicesWithPrismaCreatedbyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesModel()
	createdbyField()
}

type DevicesWithPrismaCreatedbySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	createdbyField()
}

type devicesWithPrismaCreatedbySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaCreatedbySetParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaCreatedbySetParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaCreatedbySetParam) devicesModel() {}

func (p devicesWithPrismaCreatedbySetParam) createdbyField() {}

type DevicesWithPrismaCreatedbyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	createdbyField()
}

type devicesWithPrismaCreatedbyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaCreatedbyEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaCreatedbyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaCreatedbyEqualsParam) devicesModel() {}

func (p devicesWithPrismaCreatedbyEqualsParam) createdbyField() {}

func (devicesWithPrismaCreatedbySetParam) settable()  {}
func (devicesWithPrismaCreatedbyEqualsParam) equals() {}

type devicesWithPrismaCreatedbyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaCreatedbyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaCreatedbyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaCreatedbyEqualsUniqueParam) devicesModel()   {}
func (p devicesWithPrismaCreatedbyEqualsUniqueParam) createdbyField() {}

func (devicesWithPrismaCreatedbyEqualsUniqueParam) unique() {}
func (devicesWithPrismaCreatedbyEqualsUniqueParam) equals() {}

type DevicesWithPrismaUpdatedatEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesModel()
	updatedatField()
}

type DevicesWithPrismaUpdatedatSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	updatedatField()
}

type devicesWithPrismaUpdatedatSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaUpdatedatSetParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaUpdatedatSetParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaUpdatedatSetParam) devicesModel() {}

func (p devicesWithPrismaUpdatedatSetParam) updatedatField() {}

type DevicesWithPrismaUpdatedatWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	updatedatField()
}

type devicesWithPrismaUpdatedatEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaUpdatedatEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaUpdatedatEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaUpdatedatEqualsParam) devicesModel() {}

func (p devicesWithPrismaUpdatedatEqualsParam) updatedatField() {}

func (devicesWithPrismaUpdatedatSetParam) settable()  {}
func (devicesWithPrismaUpdatedatEqualsParam) equals() {}

type devicesWithPrismaUpdatedatEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaUpdatedatEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaUpdatedatEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaUpdatedatEqualsUniqueParam) devicesModel()   {}
func (p devicesWithPrismaUpdatedatEqualsUniqueParam) updatedatField() {}

func (devicesWithPrismaUpdatedatEqualsUniqueParam) unique() {}
func (devicesWithPrismaUpdatedatEqualsUniqueParam) equals() {}

type DevicesWithPrismaUpdatedbyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesModel()
	updatedbyField()
}

type DevicesWithPrismaUpdatedbySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	updatedbyField()
}

type devicesWithPrismaUpdatedbySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaUpdatedbySetParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaUpdatedbySetParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaUpdatedbySetParam) devicesModel() {}

func (p devicesWithPrismaUpdatedbySetParam) updatedbyField() {}

type DevicesWithPrismaUpdatedbyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	updatedbyField()
}

type devicesWithPrismaUpdatedbyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaUpdatedbyEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaUpdatedbyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaUpdatedbyEqualsParam) devicesModel() {}

func (p devicesWithPrismaUpdatedbyEqualsParam) updatedbyField() {}

func (devicesWithPrismaUpdatedbySetParam) settable()  {}
func (devicesWithPrismaUpdatedbyEqualsParam) equals() {}

type devicesWithPrismaUpdatedbyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaUpdatedbyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaUpdatedbyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaUpdatedbyEqualsUniqueParam) devicesModel()   {}
func (p devicesWithPrismaUpdatedbyEqualsUniqueParam) updatedbyField() {}

func (devicesWithPrismaUpdatedbyEqualsUniqueParam) unique() {}
func (devicesWithPrismaUpdatedbyEqualsUniqueParam) equals() {}

type DevicesWithPrismaGroupdevicesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesModel()
	groupdevicesField()
}

type DevicesWithPrismaGroupdevicesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	groupdevicesField()
}

type devicesWithPrismaGroupdevicesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaGroupdevicesSetParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaGroupdevicesSetParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaGroupdevicesSetParam) devicesModel() {}

func (p devicesWithPrismaGroupdevicesSetParam) groupdevicesField() {}

type DevicesWithPrismaGroupdevicesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	groupdevicesField()
}

type devicesWithPrismaGroupdevicesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaGroupdevicesEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaGroupdevicesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaGroupdevicesEqualsParam) devicesModel() {}

func (p devicesWithPrismaGroupdevicesEqualsParam) groupdevicesField() {}

func (devicesWithPrismaGroupdevicesSetParam) settable()  {}
func (devicesWithPrismaGroupdevicesEqualsParam) equals() {}

type devicesWithPrismaGroupdevicesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaGroupdevicesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaGroupdevicesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaGroupdevicesEqualsUniqueParam) devicesModel()      {}
func (p devicesWithPrismaGroupdevicesEqualsUniqueParam) groupdevicesField() {}

func (devicesWithPrismaGroupdevicesEqualsUniqueParam) unique() {}
func (devicesWithPrismaGroupdevicesEqualsUniqueParam) equals() {}

type DevicesWithPrismaOrgdevicesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	devicesModel()
	orgdevicesField()
}

type DevicesWithPrismaOrgdevicesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	orgdevicesField()
}

type devicesWithPrismaOrgdevicesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaOrgdevicesSetParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaOrgdevicesSetParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaOrgdevicesSetParam) devicesModel() {}

func (p devicesWithPrismaOrgdevicesSetParam) orgdevicesField() {}

type DevicesWithPrismaOrgdevicesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	devicesModel()
	orgdevicesField()
}

type devicesWithPrismaOrgdevicesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaOrgdevicesEqualsParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaOrgdevicesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaOrgdevicesEqualsParam) devicesModel() {}

func (p devicesWithPrismaOrgdevicesEqualsParam) orgdevicesField() {}

func (devicesWithPrismaOrgdevicesSetParam) settable()  {}
func (devicesWithPrismaOrgdevicesEqualsParam) equals() {}

type devicesWithPrismaOrgdevicesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p devicesWithPrismaOrgdevicesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p devicesWithPrismaOrgdevicesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p devicesWithPrismaOrgdevicesEqualsUniqueParam) devicesModel()    {}
func (p devicesWithPrismaOrgdevicesEqualsUniqueParam) orgdevicesField() {}

func (devicesWithPrismaOrgdevicesEqualsUniqueParam) unique() {}
func (devicesWithPrismaOrgdevicesEqualsUniqueParam) equals() {}

type groupdevicesActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var groupdevicesOutput = []builder.Output{
	{Name: "orgid"},
	{Name: "groupid"},
	{Name: "deviceid"},
	{Name: "isexist"},
	{Name: "updatedat"},
	{Name: "updatedby"},
}

type GroupdevicesRelationWith interface {
	getQuery() builder.Query
	with()
	groupdevicesRelation()
}

type GroupdevicesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
}

type groupdevicesDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesDefaultParam) field() builder.Field {
	return p.data
}

func (p groupdevicesDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesDefaultParam) groupdevicesModel() {}

type GroupdevicesOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
}

type groupdevicesOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesOrderByParam) field() builder.Field {
	return p.data
}

func (p groupdevicesOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesOrderByParam) groupdevicesModel() {}

type GroupdevicesCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	isCursor()
}

type groupdevicesCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesCursorParam) field() builder.Field {
	return p.data
}

func (p groupdevicesCursorParam) isCursor() {}

func (p groupdevicesCursorParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesCursorParam) groupdevicesModel() {}

type GroupdevicesParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	groupdevicesModel()
}

type groupdevicesParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesParamUnique) groupdevicesModel() {}

func (groupdevicesParamUnique) unique() {}

func (p groupdevicesParamUnique) field() builder.Field {
	return p.data
}

func (p groupdevicesParamUnique) getQuery() builder.Query {
	return p.query
}

type GroupdevicesEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupdevicesModel()
}

type groupdevicesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesEqualsParam) groupdevicesModel() {}

func (groupdevicesEqualsParam) equals() {}

func (p groupdevicesEqualsParam) field() builder.Field {
	return p.data
}

func (p groupdevicesEqualsParam) getQuery() builder.Query {
	return p.query
}

type GroupdevicesEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	groupdevicesModel()
}

type groupdevicesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesEqualsUniqueParam) groupdevicesModel() {}

func (groupdevicesEqualsUniqueParam) unique() {}
func (groupdevicesEqualsUniqueParam) equals() {}

func (p groupdevicesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupdevicesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type GroupdevicesSetParam interface {
	field() builder.Field
	settable()
	groupdevicesModel()
}

type groupdevicesSetParam struct {
	data builder.Field
}

func (groupdevicesSetParam) settable() {}

func (p groupdevicesSetParam) field() builder.Field {
	return p.data
}

func (p groupdevicesSetParam) groupdevicesModel() {}

type GroupdevicesWithPrismaOrgidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupdevicesModel()
	orgidField()
}

type GroupdevicesWithPrismaOrgidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	orgidField()
}

type groupdevicesWithPrismaOrgidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaOrgidSetParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaOrgidSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaOrgidSetParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaOrgidSetParam) orgidField() {}

type GroupdevicesWithPrismaOrgidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	orgidField()
}

type groupdevicesWithPrismaOrgidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaOrgidEqualsParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaOrgidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaOrgidEqualsParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaOrgidEqualsParam) orgidField() {}

func (groupdevicesWithPrismaOrgidSetParam) settable()  {}
func (groupdevicesWithPrismaOrgidEqualsParam) equals() {}

type groupdevicesWithPrismaOrgidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaOrgidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaOrgidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaOrgidEqualsUniqueParam) groupdevicesModel() {}
func (p groupdevicesWithPrismaOrgidEqualsUniqueParam) orgidField()        {}

func (groupdevicesWithPrismaOrgidEqualsUniqueParam) unique() {}
func (groupdevicesWithPrismaOrgidEqualsUniqueParam) equals() {}

type GroupdevicesWithPrismaGroupidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupdevicesModel()
	groupidField()
}

type GroupdevicesWithPrismaGroupidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	groupidField()
}

type groupdevicesWithPrismaGroupidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaGroupidSetParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaGroupidSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaGroupidSetParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaGroupidSetParam) groupidField() {}

type GroupdevicesWithPrismaGroupidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	groupidField()
}

type groupdevicesWithPrismaGroupidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaGroupidEqualsParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaGroupidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaGroupidEqualsParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaGroupidEqualsParam) groupidField() {}

func (groupdevicesWithPrismaGroupidSetParam) settable()  {}
func (groupdevicesWithPrismaGroupidEqualsParam) equals() {}

type groupdevicesWithPrismaGroupidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaGroupidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaGroupidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaGroupidEqualsUniqueParam) groupdevicesModel() {}
func (p groupdevicesWithPrismaGroupidEqualsUniqueParam) groupidField()      {}

func (groupdevicesWithPrismaGroupidEqualsUniqueParam) unique() {}
func (groupdevicesWithPrismaGroupidEqualsUniqueParam) equals() {}

type GroupdevicesWithPrismaDeviceidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupdevicesModel()
	deviceidField()
}

type GroupdevicesWithPrismaDeviceidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	deviceidField()
}

type groupdevicesWithPrismaDeviceidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaDeviceidSetParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaDeviceidSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaDeviceidSetParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaDeviceidSetParam) deviceidField() {}

type GroupdevicesWithPrismaDeviceidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	deviceidField()
}

type groupdevicesWithPrismaDeviceidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaDeviceidEqualsParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaDeviceidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaDeviceidEqualsParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaDeviceidEqualsParam) deviceidField() {}

func (groupdevicesWithPrismaDeviceidSetParam) settable()  {}
func (groupdevicesWithPrismaDeviceidEqualsParam) equals() {}

type groupdevicesWithPrismaDeviceidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaDeviceidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaDeviceidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaDeviceidEqualsUniqueParam) groupdevicesModel() {}
func (p groupdevicesWithPrismaDeviceidEqualsUniqueParam) deviceidField()     {}

func (groupdevicesWithPrismaDeviceidEqualsUniqueParam) unique() {}
func (groupdevicesWithPrismaDeviceidEqualsUniqueParam) equals() {}

type GroupdevicesWithPrismaIsexistEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupdevicesModel()
	isexistField()
}

type GroupdevicesWithPrismaIsexistSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	isexistField()
}

type groupdevicesWithPrismaIsexistSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaIsexistSetParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaIsexistSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaIsexistSetParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaIsexistSetParam) isexistField() {}

type GroupdevicesWithPrismaIsexistWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	isexistField()
}

type groupdevicesWithPrismaIsexistEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaIsexistEqualsParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaIsexistEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaIsexistEqualsParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaIsexistEqualsParam) isexistField() {}

func (groupdevicesWithPrismaIsexistSetParam) settable()  {}
func (groupdevicesWithPrismaIsexistEqualsParam) equals() {}

type groupdevicesWithPrismaIsexistEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaIsexistEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaIsexistEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaIsexistEqualsUniqueParam) groupdevicesModel() {}
func (p groupdevicesWithPrismaIsexistEqualsUniqueParam) isexistField()      {}

func (groupdevicesWithPrismaIsexistEqualsUniqueParam) unique() {}
func (groupdevicesWithPrismaIsexistEqualsUniqueParam) equals() {}

type GroupdevicesWithPrismaUpdatedatEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupdevicesModel()
	updatedatField()
}

type GroupdevicesWithPrismaUpdatedatSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	updatedatField()
}

type groupdevicesWithPrismaUpdatedatSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaUpdatedatSetParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaUpdatedatSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaUpdatedatSetParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaUpdatedatSetParam) updatedatField() {}

type GroupdevicesWithPrismaUpdatedatWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	updatedatField()
}

type groupdevicesWithPrismaUpdatedatEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaUpdatedatEqualsParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaUpdatedatEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaUpdatedatEqualsParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaUpdatedatEqualsParam) updatedatField() {}

func (groupdevicesWithPrismaUpdatedatSetParam) settable()  {}
func (groupdevicesWithPrismaUpdatedatEqualsParam) equals() {}

type groupdevicesWithPrismaUpdatedatEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaUpdatedatEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaUpdatedatEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaUpdatedatEqualsUniqueParam) groupdevicesModel() {}
func (p groupdevicesWithPrismaUpdatedatEqualsUniqueParam) updatedatField()    {}

func (groupdevicesWithPrismaUpdatedatEqualsUniqueParam) unique() {}
func (groupdevicesWithPrismaUpdatedatEqualsUniqueParam) equals() {}

type GroupdevicesWithPrismaUpdatedbyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupdevicesModel()
	updatedbyField()
}

type GroupdevicesWithPrismaUpdatedbySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	updatedbyField()
}

type groupdevicesWithPrismaUpdatedbySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaUpdatedbySetParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaUpdatedbySetParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaUpdatedbySetParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaUpdatedbySetParam) updatedbyField() {}

type GroupdevicesWithPrismaUpdatedbyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	updatedbyField()
}

type groupdevicesWithPrismaUpdatedbyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaUpdatedbyEqualsParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaUpdatedbyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaUpdatedbyEqualsParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaUpdatedbyEqualsParam) updatedbyField() {}

func (groupdevicesWithPrismaUpdatedbySetParam) settable()  {}
func (groupdevicesWithPrismaUpdatedbyEqualsParam) equals() {}

type groupdevicesWithPrismaUpdatedbyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaUpdatedbyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaUpdatedbyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaUpdatedbyEqualsUniqueParam) groupdevicesModel() {}
func (p groupdevicesWithPrismaUpdatedbyEqualsUniqueParam) updatedbyField()    {}

func (groupdevicesWithPrismaUpdatedbyEqualsUniqueParam) unique() {}
func (groupdevicesWithPrismaUpdatedbyEqualsUniqueParam) equals() {}

type GroupdevicesWithPrismaDevicesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupdevicesModel()
	devicesField()
}

type GroupdevicesWithPrismaDevicesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	devicesField()
}

type groupdevicesWithPrismaDevicesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaDevicesSetParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaDevicesSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaDevicesSetParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaDevicesSetParam) devicesField() {}

type GroupdevicesWithPrismaDevicesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	devicesField()
}

type groupdevicesWithPrismaDevicesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaDevicesEqualsParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaDevicesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaDevicesEqualsParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaDevicesEqualsParam) devicesField() {}

func (groupdevicesWithPrismaDevicesSetParam) settable()  {}
func (groupdevicesWithPrismaDevicesEqualsParam) equals() {}

type groupdevicesWithPrismaDevicesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaDevicesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaDevicesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaDevicesEqualsUniqueParam) groupdevicesModel() {}
func (p groupdevicesWithPrismaDevicesEqualsUniqueParam) devicesField()      {}

func (groupdevicesWithPrismaDevicesEqualsUniqueParam) unique() {}
func (groupdevicesWithPrismaDevicesEqualsUniqueParam) equals() {}

type GroupdevicesWithPrismaGroupsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupdevicesModel()
	groupsField()
}

type GroupdevicesWithPrismaGroupsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	groupsField()
}

type groupdevicesWithPrismaGroupsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaGroupsSetParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaGroupsSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaGroupsSetParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaGroupsSetParam) groupsField() {}

type GroupdevicesWithPrismaGroupsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	groupsField()
}

type groupdevicesWithPrismaGroupsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaGroupsEqualsParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaGroupsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaGroupsEqualsParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaGroupsEqualsParam) groupsField() {}

func (groupdevicesWithPrismaGroupsSetParam) settable()  {}
func (groupdevicesWithPrismaGroupsEqualsParam) equals() {}

type groupdevicesWithPrismaGroupsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaGroupsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaGroupsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaGroupsEqualsUniqueParam) groupdevicesModel() {}
func (p groupdevicesWithPrismaGroupsEqualsUniqueParam) groupsField()       {}

func (groupdevicesWithPrismaGroupsEqualsUniqueParam) unique() {}
func (groupdevicesWithPrismaGroupsEqualsUniqueParam) equals() {}

type GroupdevicesWithPrismaOrgsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupdevicesModel()
	orgsField()
}

type GroupdevicesWithPrismaOrgsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	orgsField()
}

type groupdevicesWithPrismaOrgsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaOrgsSetParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaOrgsSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaOrgsSetParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaOrgsSetParam) orgsField() {}

type GroupdevicesWithPrismaOrgsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupdevicesModel()
	orgsField()
}

type groupdevicesWithPrismaOrgsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaOrgsEqualsParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaOrgsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaOrgsEqualsParam) groupdevicesModel() {}

func (p groupdevicesWithPrismaOrgsEqualsParam) orgsField() {}

func (groupdevicesWithPrismaOrgsSetParam) settable()  {}
func (groupdevicesWithPrismaOrgsEqualsParam) equals() {}

type groupdevicesWithPrismaOrgsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupdevicesWithPrismaOrgsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupdevicesWithPrismaOrgsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupdevicesWithPrismaOrgsEqualsUniqueParam) groupdevicesModel() {}
func (p groupdevicesWithPrismaOrgsEqualsUniqueParam) orgsField()         {}

func (groupdevicesWithPrismaOrgsEqualsUniqueParam) unique() {}
func (groupdevicesWithPrismaOrgsEqualsUniqueParam) equals() {}

type groupsActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var groupsOutput = []builder.Output{
	{Name: "orgid"},
	{Name: "groupid"},
	{Name: "groupname"},
	{Name: "isdeleted"},
	{Name: "groupmeta"},
	{Name: "createdat"},
	{Name: "createdby"},
	{Name: "updatedat"},
	{Name: "updatedby"},
}

type GroupsRelationWith interface {
	getQuery() builder.Query
	with()
	groupsRelation()
}

type GroupsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
}

type groupsDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsDefaultParam) field() builder.Field {
	return p.data
}

func (p groupsDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p groupsDefaultParam) groupsModel() {}

type GroupsOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
}

type groupsOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsOrderByParam) field() builder.Field {
	return p.data
}

func (p groupsOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p groupsOrderByParam) groupsModel() {}

type GroupsCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	isCursor()
}

type groupsCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsCursorParam) field() builder.Field {
	return p.data
}

func (p groupsCursorParam) isCursor() {}

func (p groupsCursorParam) getQuery() builder.Query {
	return p.query
}

func (p groupsCursorParam) groupsModel() {}

type GroupsParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	groupsModel()
}

type groupsParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p groupsParamUnique) groupsModel() {}

func (groupsParamUnique) unique() {}

func (p groupsParamUnique) field() builder.Field {
	return p.data
}

func (p groupsParamUnique) getQuery() builder.Query {
	return p.query
}

type GroupsEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
}

type groupsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsEqualsParam) groupsModel() {}

func (groupsEqualsParam) equals() {}

func (p groupsEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsEqualsParam) getQuery() builder.Query {
	return p.query
}

type GroupsEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	groupsModel()
}

type groupsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsEqualsUniqueParam) groupsModel() {}

func (groupsEqualsUniqueParam) unique() {}
func (groupsEqualsUniqueParam) equals() {}

func (p groupsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type GroupsSetParam interface {
	field() builder.Field
	settable()
	groupsModel()
}

type groupsSetParam struct {
	data builder.Field
}

func (groupsSetParam) settable() {}

func (p groupsSetParam) field() builder.Field {
	return p.data
}

func (p groupsSetParam) groupsModel() {}

type GroupsWithPrismaOrgidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	orgidField()
}

type GroupsWithPrismaOrgidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	orgidField()
}

type groupsWithPrismaOrgidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaOrgidSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaOrgidSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaOrgidSetParam) groupsModel() {}

func (p groupsWithPrismaOrgidSetParam) orgidField() {}

type GroupsWithPrismaOrgidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	orgidField()
}

type groupsWithPrismaOrgidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaOrgidEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaOrgidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaOrgidEqualsParam) groupsModel() {}

func (p groupsWithPrismaOrgidEqualsParam) orgidField() {}

func (groupsWithPrismaOrgidSetParam) settable()  {}
func (groupsWithPrismaOrgidEqualsParam) equals() {}

type groupsWithPrismaOrgidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaOrgidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaOrgidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaOrgidEqualsUniqueParam) groupsModel() {}
func (p groupsWithPrismaOrgidEqualsUniqueParam) orgidField()  {}

func (groupsWithPrismaOrgidEqualsUniqueParam) unique() {}
func (groupsWithPrismaOrgidEqualsUniqueParam) equals() {}

type GroupsWithPrismaGroupidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	groupidField()
}

type GroupsWithPrismaGroupidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	groupidField()
}

type groupsWithPrismaGroupidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupidSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupidSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupidSetParam) groupsModel() {}

func (p groupsWithPrismaGroupidSetParam) groupidField() {}

type GroupsWithPrismaGroupidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	groupidField()
}

type groupsWithPrismaGroupidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupidEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupidEqualsParam) groupsModel() {}

func (p groupsWithPrismaGroupidEqualsParam) groupidField() {}

func (groupsWithPrismaGroupidSetParam) settable()  {}
func (groupsWithPrismaGroupidEqualsParam) equals() {}

type groupsWithPrismaGroupidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupidEqualsUniqueParam) groupsModel()  {}
func (p groupsWithPrismaGroupidEqualsUniqueParam) groupidField() {}

func (groupsWithPrismaGroupidEqualsUniqueParam) unique() {}
func (groupsWithPrismaGroupidEqualsUniqueParam) equals() {}

type GroupsWithPrismaGroupnameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	groupnameField()
}

type GroupsWithPrismaGroupnameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	groupnameField()
}

type groupsWithPrismaGroupnameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupnameSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupnameSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupnameSetParam) groupsModel() {}

func (p groupsWithPrismaGroupnameSetParam) groupnameField() {}

type GroupsWithPrismaGroupnameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	groupnameField()
}

type groupsWithPrismaGroupnameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupnameEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupnameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupnameEqualsParam) groupsModel() {}

func (p groupsWithPrismaGroupnameEqualsParam) groupnameField() {}

func (groupsWithPrismaGroupnameSetParam) settable()  {}
func (groupsWithPrismaGroupnameEqualsParam) equals() {}

type groupsWithPrismaGroupnameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupnameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupnameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupnameEqualsUniqueParam) groupsModel()    {}
func (p groupsWithPrismaGroupnameEqualsUniqueParam) groupnameField() {}

func (groupsWithPrismaGroupnameEqualsUniqueParam) unique() {}
func (groupsWithPrismaGroupnameEqualsUniqueParam) equals() {}

type GroupsWithPrismaIsdeletedEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	isdeletedField()
}

type GroupsWithPrismaIsdeletedSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	isdeletedField()
}

type groupsWithPrismaIsdeletedSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaIsdeletedSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaIsdeletedSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaIsdeletedSetParam) groupsModel() {}

func (p groupsWithPrismaIsdeletedSetParam) isdeletedField() {}

type GroupsWithPrismaIsdeletedWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	isdeletedField()
}

type groupsWithPrismaIsdeletedEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaIsdeletedEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaIsdeletedEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaIsdeletedEqualsParam) groupsModel() {}

func (p groupsWithPrismaIsdeletedEqualsParam) isdeletedField() {}

func (groupsWithPrismaIsdeletedSetParam) settable()  {}
func (groupsWithPrismaIsdeletedEqualsParam) equals() {}

type groupsWithPrismaIsdeletedEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaIsdeletedEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaIsdeletedEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaIsdeletedEqualsUniqueParam) groupsModel()    {}
func (p groupsWithPrismaIsdeletedEqualsUniqueParam) isdeletedField() {}

func (groupsWithPrismaIsdeletedEqualsUniqueParam) unique() {}
func (groupsWithPrismaIsdeletedEqualsUniqueParam) equals() {}

type GroupsWithPrismaGroupmetaEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	groupmetaField()
}

type GroupsWithPrismaGroupmetaSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	groupmetaField()
}

type groupsWithPrismaGroupmetaSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupmetaSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupmetaSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupmetaSetParam) groupsModel() {}

func (p groupsWithPrismaGroupmetaSetParam) groupmetaField() {}

type GroupsWithPrismaGroupmetaWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	groupmetaField()
}

type groupsWithPrismaGroupmetaEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupmetaEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupmetaEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupmetaEqualsParam) groupsModel() {}

func (p groupsWithPrismaGroupmetaEqualsParam) groupmetaField() {}

func (groupsWithPrismaGroupmetaSetParam) settable()  {}
func (groupsWithPrismaGroupmetaEqualsParam) equals() {}

type groupsWithPrismaGroupmetaEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupmetaEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupmetaEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupmetaEqualsUniqueParam) groupsModel()    {}
func (p groupsWithPrismaGroupmetaEqualsUniqueParam) groupmetaField() {}

func (groupsWithPrismaGroupmetaEqualsUniqueParam) unique() {}
func (groupsWithPrismaGroupmetaEqualsUniqueParam) equals() {}

type GroupsWithPrismaCreatedatEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	createdatField()
}

type GroupsWithPrismaCreatedatSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	createdatField()
}

type groupsWithPrismaCreatedatSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaCreatedatSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaCreatedatSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaCreatedatSetParam) groupsModel() {}

func (p groupsWithPrismaCreatedatSetParam) createdatField() {}

type GroupsWithPrismaCreatedatWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	createdatField()
}

type groupsWithPrismaCreatedatEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaCreatedatEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaCreatedatEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaCreatedatEqualsParam) groupsModel() {}

func (p groupsWithPrismaCreatedatEqualsParam) createdatField() {}

func (groupsWithPrismaCreatedatSetParam) settable()  {}
func (groupsWithPrismaCreatedatEqualsParam) equals() {}

type groupsWithPrismaCreatedatEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaCreatedatEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaCreatedatEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaCreatedatEqualsUniqueParam) groupsModel()    {}
func (p groupsWithPrismaCreatedatEqualsUniqueParam) createdatField() {}

func (groupsWithPrismaCreatedatEqualsUniqueParam) unique() {}
func (groupsWithPrismaCreatedatEqualsUniqueParam) equals() {}

type GroupsWithPrismaCreatedbyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	createdbyField()
}

type GroupsWithPrismaCreatedbySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	createdbyField()
}

type groupsWithPrismaCreatedbySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaCreatedbySetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaCreatedbySetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaCreatedbySetParam) groupsModel() {}

func (p groupsWithPrismaCreatedbySetParam) createdbyField() {}

type GroupsWithPrismaCreatedbyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	createdbyField()
}

type groupsWithPrismaCreatedbyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaCreatedbyEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaCreatedbyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaCreatedbyEqualsParam) groupsModel() {}

func (p groupsWithPrismaCreatedbyEqualsParam) createdbyField() {}

func (groupsWithPrismaCreatedbySetParam) settable()  {}
func (groupsWithPrismaCreatedbyEqualsParam) equals() {}

type groupsWithPrismaCreatedbyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaCreatedbyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaCreatedbyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaCreatedbyEqualsUniqueParam) groupsModel()    {}
func (p groupsWithPrismaCreatedbyEqualsUniqueParam) createdbyField() {}

func (groupsWithPrismaCreatedbyEqualsUniqueParam) unique() {}
func (groupsWithPrismaCreatedbyEqualsUniqueParam) equals() {}

type GroupsWithPrismaUpdatedatEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	updatedatField()
}

type GroupsWithPrismaUpdatedatSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	updatedatField()
}

type groupsWithPrismaUpdatedatSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaUpdatedatSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaUpdatedatSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaUpdatedatSetParam) groupsModel() {}

func (p groupsWithPrismaUpdatedatSetParam) updatedatField() {}

type GroupsWithPrismaUpdatedatWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	updatedatField()
}

type groupsWithPrismaUpdatedatEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaUpdatedatEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaUpdatedatEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaUpdatedatEqualsParam) groupsModel() {}

func (p groupsWithPrismaUpdatedatEqualsParam) updatedatField() {}

func (groupsWithPrismaUpdatedatSetParam) settable()  {}
func (groupsWithPrismaUpdatedatEqualsParam) equals() {}

type groupsWithPrismaUpdatedatEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaUpdatedatEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaUpdatedatEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaUpdatedatEqualsUniqueParam) groupsModel()    {}
func (p groupsWithPrismaUpdatedatEqualsUniqueParam) updatedatField() {}

func (groupsWithPrismaUpdatedatEqualsUniqueParam) unique() {}
func (groupsWithPrismaUpdatedatEqualsUniqueParam) equals() {}

type GroupsWithPrismaUpdatedbyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	updatedbyField()
}

type GroupsWithPrismaUpdatedbySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	updatedbyField()
}

type groupsWithPrismaUpdatedbySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaUpdatedbySetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaUpdatedbySetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaUpdatedbySetParam) groupsModel() {}

func (p groupsWithPrismaUpdatedbySetParam) updatedbyField() {}

type GroupsWithPrismaUpdatedbyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	updatedbyField()
}

type groupsWithPrismaUpdatedbyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaUpdatedbyEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaUpdatedbyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaUpdatedbyEqualsParam) groupsModel() {}

func (p groupsWithPrismaUpdatedbyEqualsParam) updatedbyField() {}

func (groupsWithPrismaUpdatedbySetParam) settable()  {}
func (groupsWithPrismaUpdatedbyEqualsParam) equals() {}

type groupsWithPrismaUpdatedbyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaUpdatedbyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaUpdatedbyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaUpdatedbyEqualsUniqueParam) groupsModel()    {}
func (p groupsWithPrismaUpdatedbyEqualsUniqueParam) updatedbyField() {}

func (groupsWithPrismaUpdatedbyEqualsUniqueParam) unique() {}
func (groupsWithPrismaUpdatedbyEqualsUniqueParam) equals() {}

type GroupsWithPrismaGroupdevicesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	groupdevicesField()
}

type GroupsWithPrismaGroupdevicesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	groupdevicesField()
}

type groupsWithPrismaGroupdevicesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupdevicesSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupdevicesSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupdevicesSetParam) groupsModel() {}

func (p groupsWithPrismaGroupdevicesSetParam) groupdevicesField() {}

type GroupsWithPrismaGroupdevicesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	groupdevicesField()
}

type groupsWithPrismaGroupdevicesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupdevicesEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupdevicesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupdevicesEqualsParam) groupsModel() {}

func (p groupsWithPrismaGroupdevicesEqualsParam) groupdevicesField() {}

func (groupsWithPrismaGroupdevicesSetParam) settable()  {}
func (groupsWithPrismaGroupdevicesEqualsParam) equals() {}

type groupsWithPrismaGroupdevicesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupdevicesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupdevicesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupdevicesEqualsUniqueParam) groupsModel()       {}
func (p groupsWithPrismaGroupdevicesEqualsUniqueParam) groupdevicesField() {}

func (groupsWithPrismaGroupdevicesEqualsUniqueParam) unique() {}
func (groupsWithPrismaGroupdevicesEqualsUniqueParam) equals() {}

type GroupsWithPrismaOrgsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	orgsField()
}

type GroupsWithPrismaOrgsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	orgsField()
}

type groupsWithPrismaOrgsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaOrgsSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaOrgsSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaOrgsSetParam) groupsModel() {}

func (p groupsWithPrismaOrgsSetParam) orgsField() {}

type GroupsWithPrismaOrgsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	orgsField()
}

type groupsWithPrismaOrgsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaOrgsEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaOrgsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaOrgsEqualsParam) groupsModel() {}

func (p groupsWithPrismaOrgsEqualsParam) orgsField() {}

func (groupsWithPrismaOrgsSetParam) settable()  {}
func (groupsWithPrismaOrgsEqualsParam) equals() {}

type groupsWithPrismaOrgsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaOrgsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaOrgsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaOrgsEqualsUniqueParam) groupsModel() {}
func (p groupsWithPrismaOrgsEqualsUniqueParam) orgsField()   {}

func (groupsWithPrismaOrgsEqualsUniqueParam) unique() {}
func (groupsWithPrismaOrgsEqualsUniqueParam) equals() {}

type GroupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	grouptreeGrouptreeGroupidTogroupsField()
}

type GroupsWithPrismaGrouptreeGrouptreeGroupidTogroupsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	grouptreeGrouptreeGroupidTogroupsField()
}

type groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsSetParam) groupsModel() {}

func (p groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsSetParam) grouptreeGrouptreeGroupidTogroupsField() {
}

type GroupsWithPrismaGrouptreeGrouptreeGroupidTogroupsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	grouptreeGrouptreeGroupidTogroupsField()
}

type groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsParam) groupsModel() {}

func (p groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsParam) grouptreeGrouptreeGroupidTogroupsField() {
}

func (groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsSetParam) settable()  {}
func (groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsParam) equals() {}

type groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsUniqueParam) groupsModel() {}
func (p groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsUniqueParam) grouptreeGrouptreeGroupidTogroupsField() {
}

func (groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsUniqueParam) unique() {}
func (groupsWithPrismaGrouptreeGrouptreeGroupidTogroupsEqualsUniqueParam) equals() {}

type GroupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	grouptreeGrouptreePgroupidTogroupsField()
}

type GroupsWithPrismaGrouptreeGrouptreePgroupidTogroupsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	grouptreeGrouptreePgroupidTogroupsField()
}

type groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsSetParam) groupsModel() {}

func (p groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsSetParam) grouptreeGrouptreePgroupidTogroupsField() {
}

type GroupsWithPrismaGrouptreeGrouptreePgroupidTogroupsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	grouptreeGrouptreePgroupidTogroupsField()
}

type groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsParam) groupsModel() {}

func (p groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsParam) grouptreeGrouptreePgroupidTogroupsField() {
}

func (groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsSetParam) settable()  {}
func (groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsParam) equals() {}

type groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsUniqueParam) groupsModel() {}
func (p groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsUniqueParam) grouptreeGrouptreePgroupidTogroupsField() {
}

func (groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsUniqueParam) unique() {}
func (groupsWithPrismaGrouptreeGrouptreePgroupidTogroupsEqualsUniqueParam) equals() {}

type GroupsWithPrismaGroupuserpermsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	groupuserpermsField()
}

type GroupsWithPrismaGroupuserpermsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	groupuserpermsField()
}

type groupsWithPrismaGroupuserpermsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupuserpermsSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupuserpermsSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupuserpermsSetParam) groupsModel() {}

func (p groupsWithPrismaGroupuserpermsSetParam) groupuserpermsField() {}

type GroupsWithPrismaGroupuserpermsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	groupuserpermsField()
}

type groupsWithPrismaGroupuserpermsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupuserpermsEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupuserpermsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupuserpermsEqualsParam) groupsModel() {}

func (p groupsWithPrismaGroupuserpermsEqualsParam) groupuserpermsField() {}

func (groupsWithPrismaGroupuserpermsSetParam) settable()  {}
func (groupsWithPrismaGroupuserpermsEqualsParam) equals() {}

type groupsWithPrismaGroupuserpermsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaGroupuserpermsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaGroupuserpermsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaGroupuserpermsEqualsUniqueParam) groupsModel()         {}
func (p groupsWithPrismaGroupuserpermsEqualsUniqueParam) groupuserpermsField() {}

func (groupsWithPrismaGroupuserpermsEqualsUniqueParam) unique() {}
func (groupsWithPrismaGroupuserpermsEqualsUniqueParam) equals() {}

type GroupsWithPrismaOrgrgroupEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	orgrgroupField()
}

type GroupsWithPrismaOrgrgroupSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	orgrgroupField()
}

type groupsWithPrismaOrgrgroupSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaOrgrgroupSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaOrgrgroupSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaOrgrgroupSetParam) groupsModel() {}

func (p groupsWithPrismaOrgrgroupSetParam) orgrgroupField() {}

type GroupsWithPrismaOrgrgroupWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	orgrgroupField()
}

type groupsWithPrismaOrgrgroupEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaOrgrgroupEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaOrgrgroupEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaOrgrgroupEqualsParam) groupsModel() {}

func (p groupsWithPrismaOrgrgroupEqualsParam) orgrgroupField() {}

func (groupsWithPrismaOrgrgroupSetParam) settable()  {}
func (groupsWithPrismaOrgrgroupEqualsParam) equals() {}

type groupsWithPrismaOrgrgroupEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaOrgrgroupEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaOrgrgroupEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaOrgrgroupEqualsUniqueParam) groupsModel()    {}
func (p groupsWithPrismaOrgrgroupEqualsUniqueParam) orgrgroupField() {}

func (groupsWithPrismaOrgrgroupEqualsUniqueParam) unique() {}
func (groupsWithPrismaOrgrgroupEqualsUniqueParam) equals() {}

type GroupsWithPrismaUsergroupEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupsModel()
	usergroupField()
}

type GroupsWithPrismaUsergroupSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	usergroupField()
}

type groupsWithPrismaUsergroupSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaUsergroupSetParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaUsergroupSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaUsergroupSetParam) groupsModel() {}

func (p groupsWithPrismaUsergroupSetParam) usergroupField() {}

type GroupsWithPrismaUsergroupWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupsModel()
	usergroupField()
}

type groupsWithPrismaUsergroupEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaUsergroupEqualsParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaUsergroupEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaUsergroupEqualsParam) groupsModel() {}

func (p groupsWithPrismaUsergroupEqualsParam) usergroupField() {}

func (groupsWithPrismaUsergroupSetParam) settable()  {}
func (groupsWithPrismaUsergroupEqualsParam) equals() {}

type groupsWithPrismaUsergroupEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupsWithPrismaUsergroupEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupsWithPrismaUsergroupEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupsWithPrismaUsergroupEqualsUniqueParam) groupsModel()    {}
func (p groupsWithPrismaUsergroupEqualsUniqueParam) usergroupField() {}

func (groupsWithPrismaUsergroupEqualsUniqueParam) unique() {}
func (groupsWithPrismaUsergroupEqualsUniqueParam) equals() {}

type grouptreeActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var grouptreeOutput = []builder.Output{
	{Name: "orgid"},
	{Name: "pgroupid"},
	{Name: "groupid"},
	{Name: "name"},
}

type GrouptreeRelationWith interface {
	getQuery() builder.Query
	with()
	grouptreeRelation()
}

type GrouptreeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
}

type grouptreeDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeDefaultParam) field() builder.Field {
	return p.data
}

func (p grouptreeDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeDefaultParam) grouptreeModel() {}

type GrouptreeOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
}

type grouptreeOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeOrderByParam) field() builder.Field {
	return p.data
}

func (p grouptreeOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeOrderByParam) grouptreeModel() {}

type GrouptreeCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	isCursor()
}

type grouptreeCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeCursorParam) field() builder.Field {
	return p.data
}

func (p grouptreeCursorParam) isCursor() {}

func (p grouptreeCursorParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeCursorParam) grouptreeModel() {}

type GrouptreeParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	grouptreeModel()
}

type grouptreeParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeParamUnique) grouptreeModel() {}

func (grouptreeParamUnique) unique() {}

func (p grouptreeParamUnique) field() builder.Field {
	return p.data
}

func (p grouptreeParamUnique) getQuery() builder.Query {
	return p.query
}

type GrouptreeEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	grouptreeModel()
}

type grouptreeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeEqualsParam) grouptreeModel() {}

func (grouptreeEqualsParam) equals() {}

func (p grouptreeEqualsParam) field() builder.Field {
	return p.data
}

func (p grouptreeEqualsParam) getQuery() builder.Query {
	return p.query
}

type GrouptreeEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	grouptreeModel()
}

type grouptreeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeEqualsUniqueParam) grouptreeModel() {}

func (grouptreeEqualsUniqueParam) unique() {}
func (grouptreeEqualsUniqueParam) equals() {}

func (p grouptreeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p grouptreeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type GrouptreeSetParam interface {
	field() builder.Field
	settable()
	grouptreeModel()
}

type grouptreeSetParam struct {
	data builder.Field
}

func (grouptreeSetParam) settable() {}

func (p grouptreeSetParam) field() builder.Field {
	return p.data
}

func (p grouptreeSetParam) grouptreeModel() {}

type GrouptreeWithPrismaOrgidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	grouptreeModel()
	orgidField()
}

type GrouptreeWithPrismaOrgidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	orgidField()
}

type grouptreeWithPrismaOrgidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaOrgidSetParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaOrgidSetParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaOrgidSetParam) grouptreeModel() {}

func (p grouptreeWithPrismaOrgidSetParam) orgidField() {}

type GrouptreeWithPrismaOrgidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	orgidField()
}

type grouptreeWithPrismaOrgidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaOrgidEqualsParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaOrgidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaOrgidEqualsParam) grouptreeModel() {}

func (p grouptreeWithPrismaOrgidEqualsParam) orgidField() {}

func (grouptreeWithPrismaOrgidSetParam) settable()  {}
func (grouptreeWithPrismaOrgidEqualsParam) equals() {}

type grouptreeWithPrismaOrgidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaOrgidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaOrgidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaOrgidEqualsUniqueParam) grouptreeModel() {}
func (p grouptreeWithPrismaOrgidEqualsUniqueParam) orgidField()     {}

func (grouptreeWithPrismaOrgidEqualsUniqueParam) unique() {}
func (grouptreeWithPrismaOrgidEqualsUniqueParam) equals() {}

type GrouptreeWithPrismaPgroupidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	grouptreeModel()
	pgroupidField()
}

type GrouptreeWithPrismaPgroupidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	pgroupidField()
}

type grouptreeWithPrismaPgroupidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaPgroupidSetParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaPgroupidSetParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaPgroupidSetParam) grouptreeModel() {}

func (p grouptreeWithPrismaPgroupidSetParam) pgroupidField() {}

type GrouptreeWithPrismaPgroupidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	pgroupidField()
}

type grouptreeWithPrismaPgroupidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaPgroupidEqualsParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaPgroupidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaPgroupidEqualsParam) grouptreeModel() {}

func (p grouptreeWithPrismaPgroupidEqualsParam) pgroupidField() {}

func (grouptreeWithPrismaPgroupidSetParam) settable()  {}
func (grouptreeWithPrismaPgroupidEqualsParam) equals() {}

type grouptreeWithPrismaPgroupidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaPgroupidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaPgroupidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaPgroupidEqualsUniqueParam) grouptreeModel() {}
func (p grouptreeWithPrismaPgroupidEqualsUniqueParam) pgroupidField()  {}

func (grouptreeWithPrismaPgroupidEqualsUniqueParam) unique() {}
func (grouptreeWithPrismaPgroupidEqualsUniqueParam) equals() {}

type GrouptreeWithPrismaGroupidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	grouptreeModel()
	groupidField()
}

type GrouptreeWithPrismaGroupidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	groupidField()
}

type grouptreeWithPrismaGroupidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaGroupidSetParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaGroupidSetParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaGroupidSetParam) grouptreeModel() {}

func (p grouptreeWithPrismaGroupidSetParam) groupidField() {}

type GrouptreeWithPrismaGroupidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	groupidField()
}

type grouptreeWithPrismaGroupidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaGroupidEqualsParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaGroupidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaGroupidEqualsParam) grouptreeModel() {}

func (p grouptreeWithPrismaGroupidEqualsParam) groupidField() {}

func (grouptreeWithPrismaGroupidSetParam) settable()  {}
func (grouptreeWithPrismaGroupidEqualsParam) equals() {}

type grouptreeWithPrismaGroupidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaGroupidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaGroupidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaGroupidEqualsUniqueParam) grouptreeModel() {}
func (p grouptreeWithPrismaGroupidEqualsUniqueParam) groupidField()   {}

func (grouptreeWithPrismaGroupidEqualsUniqueParam) unique() {}
func (grouptreeWithPrismaGroupidEqualsUniqueParam) equals() {}

type GrouptreeWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	grouptreeModel()
	nameField()
}

type GrouptreeWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	nameField()
}

type grouptreeWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaNameSetParam) grouptreeModel() {}

func (p grouptreeWithPrismaNameSetParam) nameField() {}

type GrouptreeWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	nameField()
}

type grouptreeWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaNameEqualsParam) grouptreeModel() {}

func (p grouptreeWithPrismaNameEqualsParam) nameField() {}

func (grouptreeWithPrismaNameSetParam) settable()  {}
func (grouptreeWithPrismaNameEqualsParam) equals() {}

type grouptreeWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaNameEqualsUniqueParam) grouptreeModel() {}
func (p grouptreeWithPrismaNameEqualsUniqueParam) nameField()      {}

func (grouptreeWithPrismaNameEqualsUniqueParam) unique() {}
func (grouptreeWithPrismaNameEqualsUniqueParam) equals() {}

type GrouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	grouptreeModel()
	groupsGrouptreeGroupidTogroupsField()
}

type GrouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	groupsGrouptreeGroupidTogroupsField()
}

type grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam) grouptreeModel() {}

func (p grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam) groupsGrouptreeGroupidTogroupsField() {
}

type GrouptreeWithPrismaGroupsGrouptreeGroupidTogroupsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	groupsGrouptreeGroupidTogroupsField()
}

type grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsParam) grouptreeModel() {}

func (p grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsParam) groupsGrouptreeGroupidTogroupsField() {
}

func (grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam) settable()  {}
func (grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsParam) equals() {}

type grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsUniqueParam) grouptreeModel() {}
func (p grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsUniqueParam) groupsGrouptreeGroupidTogroupsField() {
}

func (grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsUniqueParam) unique() {}
func (grouptreeWithPrismaGroupsGrouptreeGroupidTogroupsEqualsUniqueParam) equals() {}

type GrouptreeWithPrismaOrgsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	grouptreeModel()
	orgsField()
}

type GrouptreeWithPrismaOrgsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	orgsField()
}

type grouptreeWithPrismaOrgsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaOrgsSetParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaOrgsSetParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaOrgsSetParam) grouptreeModel() {}

func (p grouptreeWithPrismaOrgsSetParam) orgsField() {}

type GrouptreeWithPrismaOrgsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	orgsField()
}

type grouptreeWithPrismaOrgsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaOrgsEqualsParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaOrgsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaOrgsEqualsParam) grouptreeModel() {}

func (p grouptreeWithPrismaOrgsEqualsParam) orgsField() {}

func (grouptreeWithPrismaOrgsSetParam) settable()  {}
func (grouptreeWithPrismaOrgsEqualsParam) equals() {}

type grouptreeWithPrismaOrgsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaOrgsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaOrgsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaOrgsEqualsUniqueParam) grouptreeModel() {}
func (p grouptreeWithPrismaOrgsEqualsUniqueParam) orgsField()      {}

func (grouptreeWithPrismaOrgsEqualsUniqueParam) unique() {}
func (grouptreeWithPrismaOrgsEqualsUniqueParam) equals() {}

type GrouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	grouptreeModel()
	groupsGrouptreePgroupidTogroupsField()
}

type GrouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	groupsGrouptreePgroupidTogroupsField()
}

type grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam) grouptreeModel() {}

func (p grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam) groupsGrouptreePgroupidTogroupsField() {
}

type GrouptreeWithPrismaGroupsGrouptreePgroupidTogroupsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	grouptreeModel()
	groupsGrouptreePgroupidTogroupsField()
}

type grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsParam) grouptreeModel() {}

func (p grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsParam) groupsGrouptreePgroupidTogroupsField() {
}

func (grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam) settable()  {}
func (grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsParam) equals() {}

type grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsUniqueParam) grouptreeModel() {}
func (p grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsUniqueParam) groupsGrouptreePgroupidTogroupsField() {
}

func (grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsUniqueParam) unique() {}
func (grouptreeWithPrismaGroupsGrouptreePgroupidTogroupsEqualsUniqueParam) equals() {}

type groupuserpermsActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var groupuserpermsOutput = []builder.Output{
	{Name: "orgid"},
	{Name: "groupid"},
	{Name: "userid"},
	{Name: "permid"},
}

type GroupuserpermsRelationWith interface {
	getQuery() builder.Query
	with()
	groupuserpermsRelation()
}

type GroupuserpermsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
}

type groupuserpermsDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsDefaultParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsDefaultParam) groupuserpermsModel() {}

type GroupuserpermsOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
}

type groupuserpermsOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsOrderByParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsOrderByParam) groupuserpermsModel() {}

type GroupuserpermsCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	isCursor()
}

type groupuserpermsCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsCursorParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsCursorParam) isCursor() {}

func (p groupuserpermsCursorParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsCursorParam) groupuserpermsModel() {}

type GroupuserpermsParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	groupuserpermsModel()
}

type groupuserpermsParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsParamUnique) groupuserpermsModel() {}

func (groupuserpermsParamUnique) unique() {}

func (p groupuserpermsParamUnique) field() builder.Field {
	return p.data
}

func (p groupuserpermsParamUnique) getQuery() builder.Query {
	return p.query
}

type GroupuserpermsEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupuserpermsModel()
}

type groupuserpermsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsEqualsParam) groupuserpermsModel() {}

func (groupuserpermsEqualsParam) equals() {}

func (p groupuserpermsEqualsParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsEqualsParam) getQuery() builder.Query {
	return p.query
}

type GroupuserpermsEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	groupuserpermsModel()
}

type groupuserpermsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsEqualsUniqueParam) groupuserpermsModel() {}

func (groupuserpermsEqualsUniqueParam) unique() {}
func (groupuserpermsEqualsUniqueParam) equals() {}

func (p groupuserpermsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type GroupuserpermsSetParam interface {
	field() builder.Field
	settable()
	groupuserpermsModel()
}

type groupuserpermsSetParam struct {
	data builder.Field
}

func (groupuserpermsSetParam) settable() {}

func (p groupuserpermsSetParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsSetParam) groupuserpermsModel() {}

type GroupuserpermsWithPrismaOrgidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupuserpermsModel()
	orgidField()
}

type GroupuserpermsWithPrismaOrgidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	orgidField()
}

type groupuserpermsWithPrismaOrgidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaOrgidSetParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaOrgidSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaOrgidSetParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaOrgidSetParam) orgidField() {}

type GroupuserpermsWithPrismaOrgidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	orgidField()
}

type groupuserpermsWithPrismaOrgidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaOrgidEqualsParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaOrgidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaOrgidEqualsParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaOrgidEqualsParam) orgidField() {}

func (groupuserpermsWithPrismaOrgidSetParam) settable()  {}
func (groupuserpermsWithPrismaOrgidEqualsParam) equals() {}

type groupuserpermsWithPrismaOrgidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaOrgidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaOrgidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaOrgidEqualsUniqueParam) groupuserpermsModel() {}
func (p groupuserpermsWithPrismaOrgidEqualsUniqueParam) orgidField()          {}

func (groupuserpermsWithPrismaOrgidEqualsUniqueParam) unique() {}
func (groupuserpermsWithPrismaOrgidEqualsUniqueParam) equals() {}

type GroupuserpermsWithPrismaGroupidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupuserpermsModel()
	groupidField()
}

type GroupuserpermsWithPrismaGroupidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	groupidField()
}

type groupuserpermsWithPrismaGroupidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaGroupidSetParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaGroupidSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaGroupidSetParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaGroupidSetParam) groupidField() {}

type GroupuserpermsWithPrismaGroupidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	groupidField()
}

type groupuserpermsWithPrismaGroupidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaGroupidEqualsParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaGroupidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaGroupidEqualsParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaGroupidEqualsParam) groupidField() {}

func (groupuserpermsWithPrismaGroupidSetParam) settable()  {}
func (groupuserpermsWithPrismaGroupidEqualsParam) equals() {}

type groupuserpermsWithPrismaGroupidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaGroupidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaGroupidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaGroupidEqualsUniqueParam) groupuserpermsModel() {}
func (p groupuserpermsWithPrismaGroupidEqualsUniqueParam) groupidField()        {}

func (groupuserpermsWithPrismaGroupidEqualsUniqueParam) unique() {}
func (groupuserpermsWithPrismaGroupidEqualsUniqueParam) equals() {}

type GroupuserpermsWithPrismaUseridEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupuserpermsModel()
	useridField()
}

type GroupuserpermsWithPrismaUseridSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	useridField()
}

type groupuserpermsWithPrismaUseridSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaUseridSetParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaUseridSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaUseridSetParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaUseridSetParam) useridField() {}

type GroupuserpermsWithPrismaUseridWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	useridField()
}

type groupuserpermsWithPrismaUseridEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaUseridEqualsParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaUseridEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaUseridEqualsParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaUseridEqualsParam) useridField() {}

func (groupuserpermsWithPrismaUseridSetParam) settable()  {}
func (groupuserpermsWithPrismaUseridEqualsParam) equals() {}

type groupuserpermsWithPrismaUseridEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaUseridEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaUseridEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaUseridEqualsUniqueParam) groupuserpermsModel() {}
func (p groupuserpermsWithPrismaUseridEqualsUniqueParam) useridField()         {}

func (groupuserpermsWithPrismaUseridEqualsUniqueParam) unique() {}
func (groupuserpermsWithPrismaUseridEqualsUniqueParam) equals() {}

type GroupuserpermsWithPrismaPermidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupuserpermsModel()
	permidField()
}

type GroupuserpermsWithPrismaPermidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	permidField()
}

type groupuserpermsWithPrismaPermidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaPermidSetParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaPermidSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaPermidSetParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaPermidSetParam) permidField() {}

type GroupuserpermsWithPrismaPermidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	permidField()
}

type groupuserpermsWithPrismaPermidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaPermidEqualsParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaPermidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaPermidEqualsParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaPermidEqualsParam) permidField() {}

func (groupuserpermsWithPrismaPermidSetParam) settable()  {}
func (groupuserpermsWithPrismaPermidEqualsParam) equals() {}

type groupuserpermsWithPrismaPermidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaPermidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaPermidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaPermidEqualsUniqueParam) groupuserpermsModel() {}
func (p groupuserpermsWithPrismaPermidEqualsUniqueParam) permidField()         {}

func (groupuserpermsWithPrismaPermidEqualsUniqueParam) unique() {}
func (groupuserpermsWithPrismaPermidEqualsUniqueParam) equals() {}

type GroupuserpermsWithPrismaGroupsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupuserpermsModel()
	groupsField()
}

type GroupuserpermsWithPrismaGroupsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	groupsField()
}

type groupuserpermsWithPrismaGroupsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaGroupsSetParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaGroupsSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaGroupsSetParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaGroupsSetParam) groupsField() {}

type GroupuserpermsWithPrismaGroupsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	groupsField()
}

type groupuserpermsWithPrismaGroupsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaGroupsEqualsParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaGroupsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaGroupsEqualsParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaGroupsEqualsParam) groupsField() {}

func (groupuserpermsWithPrismaGroupsSetParam) settable()  {}
func (groupuserpermsWithPrismaGroupsEqualsParam) equals() {}

type groupuserpermsWithPrismaGroupsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaGroupsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaGroupsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaGroupsEqualsUniqueParam) groupuserpermsModel() {}
func (p groupuserpermsWithPrismaGroupsEqualsUniqueParam) groupsField()         {}

func (groupuserpermsWithPrismaGroupsEqualsUniqueParam) unique() {}
func (groupuserpermsWithPrismaGroupsEqualsUniqueParam) equals() {}

type GroupuserpermsWithPrismaOrgsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupuserpermsModel()
	orgsField()
}

type GroupuserpermsWithPrismaOrgsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	orgsField()
}

type groupuserpermsWithPrismaOrgsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaOrgsSetParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaOrgsSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaOrgsSetParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaOrgsSetParam) orgsField() {}

type GroupuserpermsWithPrismaOrgsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	orgsField()
}

type groupuserpermsWithPrismaOrgsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaOrgsEqualsParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaOrgsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaOrgsEqualsParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaOrgsEqualsParam) orgsField() {}

func (groupuserpermsWithPrismaOrgsSetParam) settable()  {}
func (groupuserpermsWithPrismaOrgsEqualsParam) equals() {}

type groupuserpermsWithPrismaOrgsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaOrgsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaOrgsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaOrgsEqualsUniqueParam) groupuserpermsModel() {}
func (p groupuserpermsWithPrismaOrgsEqualsUniqueParam) orgsField()           {}

func (groupuserpermsWithPrismaOrgsEqualsUniqueParam) unique() {}
func (groupuserpermsWithPrismaOrgsEqualsUniqueParam) equals() {}

type GroupuserpermsWithPrismaUsersEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	groupuserpermsModel()
	usersField()
}

type GroupuserpermsWithPrismaUsersSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	usersField()
}

type groupuserpermsWithPrismaUsersSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaUsersSetParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaUsersSetParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaUsersSetParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaUsersSetParam) usersField() {}

type GroupuserpermsWithPrismaUsersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	groupuserpermsModel()
	usersField()
}

type groupuserpermsWithPrismaUsersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaUsersEqualsParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaUsersEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaUsersEqualsParam) groupuserpermsModel() {}

func (p groupuserpermsWithPrismaUsersEqualsParam) usersField() {}

func (groupuserpermsWithPrismaUsersSetParam) settable()  {}
func (groupuserpermsWithPrismaUsersEqualsParam) equals() {}

type groupuserpermsWithPrismaUsersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p groupuserpermsWithPrismaUsersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p groupuserpermsWithPrismaUsersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p groupuserpermsWithPrismaUsersEqualsUniqueParam) groupuserpermsModel() {}
func (p groupuserpermsWithPrismaUsersEqualsUniqueParam) usersField()          {}

func (groupuserpermsWithPrismaUsersEqualsUniqueParam) unique() {}
func (groupuserpermsWithPrismaUsersEqualsUniqueParam) equals() {}

type orgdevicesActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var orgdevicesOutput = []builder.Output{
	{Name: "orgid"},
	{Name: "deviceid"},
	{Name: "orgdevicemeta"},
	{Name: "updatedat"},
	{Name: "updatedby"},
}

type OrgdevicesRelationWith interface {
	getQuery() builder.Query
	with()
	orgdevicesRelation()
}

type OrgdevicesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
}

type orgdevicesDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesDefaultParam) field() builder.Field {
	return p.data
}

func (p orgdevicesDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesDefaultParam) orgdevicesModel() {}

type OrgdevicesOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
}

type orgdevicesOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesOrderByParam) field() builder.Field {
	return p.data
}

func (p orgdevicesOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesOrderByParam) orgdevicesModel() {}

type OrgdevicesCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	isCursor()
}

type orgdevicesCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesCursorParam) field() builder.Field {
	return p.data
}

func (p orgdevicesCursorParam) isCursor() {}

func (p orgdevicesCursorParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesCursorParam) orgdevicesModel() {}

type OrgdevicesParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	orgdevicesModel()
}

type orgdevicesParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesParamUnique) orgdevicesModel() {}

func (orgdevicesParamUnique) unique() {}

func (p orgdevicesParamUnique) field() builder.Field {
	return p.data
}

func (p orgdevicesParamUnique) getQuery() builder.Query {
	return p.query
}

type OrgdevicesEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgdevicesModel()
}

type orgdevicesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesEqualsParam) orgdevicesModel() {}

func (orgdevicesEqualsParam) equals() {}

func (p orgdevicesEqualsParam) field() builder.Field {
	return p.data
}

func (p orgdevicesEqualsParam) getQuery() builder.Query {
	return p.query
}

type OrgdevicesEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	orgdevicesModel()
}

type orgdevicesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesEqualsUniqueParam) orgdevicesModel() {}

func (orgdevicesEqualsUniqueParam) unique() {}
func (orgdevicesEqualsUniqueParam) equals() {}

func (p orgdevicesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgdevicesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type OrgdevicesSetParam interface {
	field() builder.Field
	settable()
	orgdevicesModel()
}

type orgdevicesSetParam struct {
	data builder.Field
}

func (orgdevicesSetParam) settable() {}

func (p orgdevicesSetParam) field() builder.Field {
	return p.data
}

func (p orgdevicesSetParam) orgdevicesModel() {}

type OrgdevicesWithPrismaOrgidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgdevicesModel()
	orgidField()
}

type OrgdevicesWithPrismaOrgidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	orgidField()
}

type orgdevicesWithPrismaOrgidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaOrgidSetParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaOrgidSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaOrgidSetParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaOrgidSetParam) orgidField() {}

type OrgdevicesWithPrismaOrgidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	orgidField()
}

type orgdevicesWithPrismaOrgidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaOrgidEqualsParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaOrgidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaOrgidEqualsParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaOrgidEqualsParam) orgidField() {}

func (orgdevicesWithPrismaOrgidSetParam) settable()  {}
func (orgdevicesWithPrismaOrgidEqualsParam) equals() {}

type orgdevicesWithPrismaOrgidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaOrgidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaOrgidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaOrgidEqualsUniqueParam) orgdevicesModel() {}
func (p orgdevicesWithPrismaOrgidEqualsUniqueParam) orgidField()      {}

func (orgdevicesWithPrismaOrgidEqualsUniqueParam) unique() {}
func (orgdevicesWithPrismaOrgidEqualsUniqueParam) equals() {}

type OrgdevicesWithPrismaDeviceidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgdevicesModel()
	deviceidField()
}

type OrgdevicesWithPrismaDeviceidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	deviceidField()
}

type orgdevicesWithPrismaDeviceidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaDeviceidSetParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaDeviceidSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaDeviceidSetParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaDeviceidSetParam) deviceidField() {}

type OrgdevicesWithPrismaDeviceidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	deviceidField()
}

type orgdevicesWithPrismaDeviceidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaDeviceidEqualsParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaDeviceidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaDeviceidEqualsParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaDeviceidEqualsParam) deviceidField() {}

func (orgdevicesWithPrismaDeviceidSetParam) settable()  {}
func (orgdevicesWithPrismaDeviceidEqualsParam) equals() {}

type orgdevicesWithPrismaDeviceidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaDeviceidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaDeviceidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaDeviceidEqualsUniqueParam) orgdevicesModel() {}
func (p orgdevicesWithPrismaDeviceidEqualsUniqueParam) deviceidField()   {}

func (orgdevicesWithPrismaDeviceidEqualsUniqueParam) unique() {}
func (orgdevicesWithPrismaDeviceidEqualsUniqueParam) equals() {}

type OrgdevicesWithPrismaOrgdevicemetaEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgdevicesModel()
	orgdevicemetaField()
}

type OrgdevicesWithPrismaOrgdevicemetaSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	orgdevicemetaField()
}

type orgdevicesWithPrismaOrgdevicemetaSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaOrgdevicemetaSetParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaOrgdevicemetaSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaOrgdevicemetaSetParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaOrgdevicemetaSetParam) orgdevicemetaField() {}

type OrgdevicesWithPrismaOrgdevicemetaWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	orgdevicemetaField()
}

type orgdevicesWithPrismaOrgdevicemetaEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaOrgdevicemetaEqualsParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaOrgdevicemetaEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaOrgdevicemetaEqualsParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaOrgdevicemetaEqualsParam) orgdevicemetaField() {}

func (orgdevicesWithPrismaOrgdevicemetaSetParam) settable()  {}
func (orgdevicesWithPrismaOrgdevicemetaEqualsParam) equals() {}

type orgdevicesWithPrismaOrgdevicemetaEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaOrgdevicemetaEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaOrgdevicemetaEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaOrgdevicemetaEqualsUniqueParam) orgdevicesModel()    {}
func (p orgdevicesWithPrismaOrgdevicemetaEqualsUniqueParam) orgdevicemetaField() {}

func (orgdevicesWithPrismaOrgdevicemetaEqualsUniqueParam) unique() {}
func (orgdevicesWithPrismaOrgdevicemetaEqualsUniqueParam) equals() {}

type OrgdevicesWithPrismaUpdatedatEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgdevicesModel()
	updatedatField()
}

type OrgdevicesWithPrismaUpdatedatSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	updatedatField()
}

type orgdevicesWithPrismaUpdatedatSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaUpdatedatSetParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaUpdatedatSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaUpdatedatSetParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaUpdatedatSetParam) updatedatField() {}

type OrgdevicesWithPrismaUpdatedatWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	updatedatField()
}

type orgdevicesWithPrismaUpdatedatEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaUpdatedatEqualsParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaUpdatedatEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaUpdatedatEqualsParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaUpdatedatEqualsParam) updatedatField() {}

func (orgdevicesWithPrismaUpdatedatSetParam) settable()  {}
func (orgdevicesWithPrismaUpdatedatEqualsParam) equals() {}

type orgdevicesWithPrismaUpdatedatEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaUpdatedatEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaUpdatedatEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaUpdatedatEqualsUniqueParam) orgdevicesModel() {}
func (p orgdevicesWithPrismaUpdatedatEqualsUniqueParam) updatedatField()  {}

func (orgdevicesWithPrismaUpdatedatEqualsUniqueParam) unique() {}
func (orgdevicesWithPrismaUpdatedatEqualsUniqueParam) equals() {}

type OrgdevicesWithPrismaUpdatedbyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgdevicesModel()
	updatedbyField()
}

type OrgdevicesWithPrismaUpdatedbySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	updatedbyField()
}

type orgdevicesWithPrismaUpdatedbySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaUpdatedbySetParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaUpdatedbySetParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaUpdatedbySetParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaUpdatedbySetParam) updatedbyField() {}

type OrgdevicesWithPrismaUpdatedbyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	updatedbyField()
}

type orgdevicesWithPrismaUpdatedbyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaUpdatedbyEqualsParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaUpdatedbyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaUpdatedbyEqualsParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaUpdatedbyEqualsParam) updatedbyField() {}

func (orgdevicesWithPrismaUpdatedbySetParam) settable()  {}
func (orgdevicesWithPrismaUpdatedbyEqualsParam) equals() {}

type orgdevicesWithPrismaUpdatedbyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaUpdatedbyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaUpdatedbyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaUpdatedbyEqualsUniqueParam) orgdevicesModel() {}
func (p orgdevicesWithPrismaUpdatedbyEqualsUniqueParam) updatedbyField()  {}

func (orgdevicesWithPrismaUpdatedbyEqualsUniqueParam) unique() {}
func (orgdevicesWithPrismaUpdatedbyEqualsUniqueParam) equals() {}

type OrgdevicesWithPrismaDevicesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgdevicesModel()
	devicesField()
}

type OrgdevicesWithPrismaDevicesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	devicesField()
}

type orgdevicesWithPrismaDevicesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaDevicesSetParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaDevicesSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaDevicesSetParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaDevicesSetParam) devicesField() {}

type OrgdevicesWithPrismaDevicesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	devicesField()
}

type orgdevicesWithPrismaDevicesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaDevicesEqualsParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaDevicesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaDevicesEqualsParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaDevicesEqualsParam) devicesField() {}

func (orgdevicesWithPrismaDevicesSetParam) settable()  {}
func (orgdevicesWithPrismaDevicesEqualsParam) equals() {}

type orgdevicesWithPrismaDevicesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaDevicesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaDevicesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaDevicesEqualsUniqueParam) orgdevicesModel() {}
func (p orgdevicesWithPrismaDevicesEqualsUniqueParam) devicesField()    {}

func (orgdevicesWithPrismaDevicesEqualsUniqueParam) unique() {}
func (orgdevicesWithPrismaDevicesEqualsUniqueParam) equals() {}

type OrgdevicesWithPrismaOrgsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgdevicesModel()
	orgsField()
}

type OrgdevicesWithPrismaOrgsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	orgsField()
}

type orgdevicesWithPrismaOrgsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaOrgsSetParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaOrgsSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaOrgsSetParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaOrgsSetParam) orgsField() {}

type OrgdevicesWithPrismaOrgsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgdevicesModel()
	orgsField()
}

type orgdevicesWithPrismaOrgsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaOrgsEqualsParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaOrgsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaOrgsEqualsParam) orgdevicesModel() {}

func (p orgdevicesWithPrismaOrgsEqualsParam) orgsField() {}

func (orgdevicesWithPrismaOrgsSetParam) settable()  {}
func (orgdevicesWithPrismaOrgsEqualsParam) equals() {}

type orgdevicesWithPrismaOrgsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgdevicesWithPrismaOrgsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgdevicesWithPrismaOrgsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgdevicesWithPrismaOrgsEqualsUniqueParam) orgdevicesModel() {}
func (p orgdevicesWithPrismaOrgsEqualsUniqueParam) orgsField()       {}

func (orgdevicesWithPrismaOrgsEqualsUniqueParam) unique() {}
func (orgdevicesWithPrismaOrgsEqualsUniqueParam) equals() {}

type orgrgroupActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var orgrgroupOutput = []builder.Output{
	{Name: "orgid"},
	{Name: "rootgroupid"},
}

type OrgrgroupRelationWith interface {
	getQuery() builder.Query
	with()
	orgrgroupRelation()
}

type OrgrgroupWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgrgroupModel()
}

type orgrgroupDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupDefaultParam) field() builder.Field {
	return p.data
}

func (p orgrgroupDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupDefaultParam) orgrgroupModel() {}

type OrgrgroupOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgrgroupModel()
}

type orgrgroupOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupOrderByParam) field() builder.Field {
	return p.data
}

func (p orgrgroupOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupOrderByParam) orgrgroupModel() {}

type OrgrgroupCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgrgroupModel()
	isCursor()
}

type orgrgroupCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupCursorParam) field() builder.Field {
	return p.data
}

func (p orgrgroupCursorParam) isCursor() {}

func (p orgrgroupCursorParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupCursorParam) orgrgroupModel() {}

type OrgrgroupParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	orgrgroupModel()
}

type orgrgroupParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupParamUnique) orgrgroupModel() {}

func (orgrgroupParamUnique) unique() {}

func (p orgrgroupParamUnique) field() builder.Field {
	return p.data
}

func (p orgrgroupParamUnique) getQuery() builder.Query {
	return p.query
}

type OrgrgroupEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgrgroupModel()
}

type orgrgroupEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupEqualsParam) orgrgroupModel() {}

func (orgrgroupEqualsParam) equals() {}

func (p orgrgroupEqualsParam) field() builder.Field {
	return p.data
}

func (p orgrgroupEqualsParam) getQuery() builder.Query {
	return p.query
}

type OrgrgroupEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	orgrgroupModel()
}

type orgrgroupEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupEqualsUniqueParam) orgrgroupModel() {}

func (orgrgroupEqualsUniqueParam) unique() {}
func (orgrgroupEqualsUniqueParam) equals() {}

func (p orgrgroupEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgrgroupEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type OrgrgroupSetParam interface {
	field() builder.Field
	settable()
	orgrgroupModel()
}

type orgrgroupSetParam struct {
	data builder.Field
}

func (orgrgroupSetParam) settable() {}

func (p orgrgroupSetParam) field() builder.Field {
	return p.data
}

func (p orgrgroupSetParam) orgrgroupModel() {}

type OrgrgroupWithPrismaOrgidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgrgroupModel()
	orgidField()
}

type OrgrgroupWithPrismaOrgidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgrgroupModel()
	orgidField()
}

type orgrgroupWithPrismaOrgidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupWithPrismaOrgidSetParam) field() builder.Field {
	return p.data
}

func (p orgrgroupWithPrismaOrgidSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupWithPrismaOrgidSetParam) orgrgroupModel() {}

func (p orgrgroupWithPrismaOrgidSetParam) orgidField() {}

type OrgrgroupWithPrismaOrgidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgrgroupModel()
	orgidField()
}

type orgrgroupWithPrismaOrgidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupWithPrismaOrgidEqualsParam) field() builder.Field {
	return p.data
}

func (p orgrgroupWithPrismaOrgidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupWithPrismaOrgidEqualsParam) orgrgroupModel() {}

func (p orgrgroupWithPrismaOrgidEqualsParam) orgidField() {}

func (orgrgroupWithPrismaOrgidSetParam) settable()  {}
func (orgrgroupWithPrismaOrgidEqualsParam) equals() {}

type orgrgroupWithPrismaOrgidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupWithPrismaOrgidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgrgroupWithPrismaOrgidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupWithPrismaOrgidEqualsUniqueParam) orgrgroupModel() {}
func (p orgrgroupWithPrismaOrgidEqualsUniqueParam) orgidField()     {}

func (orgrgroupWithPrismaOrgidEqualsUniqueParam) unique() {}
func (orgrgroupWithPrismaOrgidEqualsUniqueParam) equals() {}

type OrgrgroupWithPrismaRootgroupidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgrgroupModel()
	rootgroupidField()
}

type OrgrgroupWithPrismaRootgroupidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgrgroupModel()
	rootgroupidField()
}

type orgrgroupWithPrismaRootgroupidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupWithPrismaRootgroupidSetParam) field() builder.Field {
	return p.data
}

func (p orgrgroupWithPrismaRootgroupidSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupWithPrismaRootgroupidSetParam) orgrgroupModel() {}

func (p orgrgroupWithPrismaRootgroupidSetParam) rootgroupidField() {}

type OrgrgroupWithPrismaRootgroupidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgrgroupModel()
	rootgroupidField()
}

type orgrgroupWithPrismaRootgroupidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupWithPrismaRootgroupidEqualsParam) field() builder.Field {
	return p.data
}

func (p orgrgroupWithPrismaRootgroupidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupWithPrismaRootgroupidEqualsParam) orgrgroupModel() {}

func (p orgrgroupWithPrismaRootgroupidEqualsParam) rootgroupidField() {}

func (orgrgroupWithPrismaRootgroupidSetParam) settable()  {}
func (orgrgroupWithPrismaRootgroupidEqualsParam) equals() {}

type orgrgroupWithPrismaRootgroupidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupWithPrismaRootgroupidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgrgroupWithPrismaRootgroupidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupWithPrismaRootgroupidEqualsUniqueParam) orgrgroupModel()   {}
func (p orgrgroupWithPrismaRootgroupidEqualsUniqueParam) rootgroupidField() {}

func (orgrgroupWithPrismaRootgroupidEqualsUniqueParam) unique() {}
func (orgrgroupWithPrismaRootgroupidEqualsUniqueParam) equals() {}

type OrgrgroupWithPrismaOrgsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgrgroupModel()
	orgsField()
}

type OrgrgroupWithPrismaOrgsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgrgroupModel()
	orgsField()
}

type orgrgroupWithPrismaOrgsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupWithPrismaOrgsSetParam) field() builder.Field {
	return p.data
}

func (p orgrgroupWithPrismaOrgsSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupWithPrismaOrgsSetParam) orgrgroupModel() {}

func (p orgrgroupWithPrismaOrgsSetParam) orgsField() {}

type OrgrgroupWithPrismaOrgsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgrgroupModel()
	orgsField()
}

type orgrgroupWithPrismaOrgsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupWithPrismaOrgsEqualsParam) field() builder.Field {
	return p.data
}

func (p orgrgroupWithPrismaOrgsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupWithPrismaOrgsEqualsParam) orgrgroupModel() {}

func (p orgrgroupWithPrismaOrgsEqualsParam) orgsField() {}

func (orgrgroupWithPrismaOrgsSetParam) settable()  {}
func (orgrgroupWithPrismaOrgsEqualsParam) equals() {}

type orgrgroupWithPrismaOrgsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupWithPrismaOrgsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgrgroupWithPrismaOrgsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupWithPrismaOrgsEqualsUniqueParam) orgrgroupModel() {}
func (p orgrgroupWithPrismaOrgsEqualsUniqueParam) orgsField()      {}

func (orgrgroupWithPrismaOrgsEqualsUniqueParam) unique() {}
func (orgrgroupWithPrismaOrgsEqualsUniqueParam) equals() {}

type OrgrgroupWithPrismaGroupsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgrgroupModel()
	groupsField()
}

type OrgrgroupWithPrismaGroupsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgrgroupModel()
	groupsField()
}

type orgrgroupWithPrismaGroupsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupWithPrismaGroupsSetParam) field() builder.Field {
	return p.data
}

func (p orgrgroupWithPrismaGroupsSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupWithPrismaGroupsSetParam) orgrgroupModel() {}

func (p orgrgroupWithPrismaGroupsSetParam) groupsField() {}

type OrgrgroupWithPrismaGroupsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgrgroupModel()
	groupsField()
}

type orgrgroupWithPrismaGroupsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupWithPrismaGroupsEqualsParam) field() builder.Field {
	return p.data
}

func (p orgrgroupWithPrismaGroupsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupWithPrismaGroupsEqualsParam) orgrgroupModel() {}

func (p orgrgroupWithPrismaGroupsEqualsParam) groupsField() {}

func (orgrgroupWithPrismaGroupsSetParam) settable()  {}
func (orgrgroupWithPrismaGroupsEqualsParam) equals() {}

type orgrgroupWithPrismaGroupsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgrgroupWithPrismaGroupsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgrgroupWithPrismaGroupsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgrgroupWithPrismaGroupsEqualsUniqueParam) orgrgroupModel() {}
func (p orgrgroupWithPrismaGroupsEqualsUniqueParam) groupsField()    {}

func (orgrgroupWithPrismaGroupsEqualsUniqueParam) unique() {}
func (orgrgroupWithPrismaGroupsEqualsUniqueParam) equals() {}

type orgsActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var orgsOutput = []builder.Output{
	{Name: "orgid"},
	{Name: "orgname"},
	{Name: "orgmeta"},
	{Name: "isenabled"},
	{Name: "createdby"},
	{Name: "updatedby"},
	{Name: "createdat"},
	{Name: "updatedat"},
}

type OrgsRelationWith interface {
	getQuery() builder.Query
	with()
	orgsRelation()
}

type OrgsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
}

type orgsDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsDefaultParam) field() builder.Field {
	return p.data
}

func (p orgsDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p orgsDefaultParam) orgsModel() {}

type OrgsOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
}

type orgsOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsOrderByParam) field() builder.Field {
	return p.data
}

func (p orgsOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p orgsOrderByParam) orgsModel() {}

type OrgsCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	isCursor()
}

type orgsCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsCursorParam) field() builder.Field {
	return p.data
}

func (p orgsCursorParam) isCursor() {}

func (p orgsCursorParam) getQuery() builder.Query {
	return p.query
}

func (p orgsCursorParam) orgsModel() {}

type OrgsParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	orgsModel()
}

type orgsParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p orgsParamUnique) orgsModel() {}

func (orgsParamUnique) unique() {}

func (p orgsParamUnique) field() builder.Field {
	return p.data
}

func (p orgsParamUnique) getQuery() builder.Query {
	return p.query
}

type OrgsEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
}

type orgsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsEqualsParam) orgsModel() {}

func (orgsEqualsParam) equals() {}

func (p orgsEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsEqualsParam) getQuery() builder.Query {
	return p.query
}

type OrgsEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	orgsModel()
}

type orgsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsEqualsUniqueParam) orgsModel() {}

func (orgsEqualsUniqueParam) unique() {}
func (orgsEqualsUniqueParam) equals() {}

func (p orgsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type OrgsSetParam interface {
	field() builder.Field
	settable()
	orgsModel()
}

type orgsSetParam struct {
	data builder.Field
}

func (orgsSetParam) settable() {}

func (p orgsSetParam) field() builder.Field {
	return p.data
}

func (p orgsSetParam) orgsModel() {}

type OrgsWithPrismaOrgidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	orgidField()
}

type OrgsWithPrismaOrgidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	orgidField()
}

type orgsWithPrismaOrgidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgidSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgidSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgidSetParam) orgsModel() {}

func (p orgsWithPrismaOrgidSetParam) orgidField() {}

type OrgsWithPrismaOrgidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	orgidField()
}

type orgsWithPrismaOrgidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgidEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgidEqualsParam) orgsModel() {}

func (p orgsWithPrismaOrgidEqualsParam) orgidField() {}

func (orgsWithPrismaOrgidSetParam) settable()  {}
func (orgsWithPrismaOrgidEqualsParam) equals() {}

type orgsWithPrismaOrgidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgidEqualsUniqueParam) orgsModel()  {}
func (p orgsWithPrismaOrgidEqualsUniqueParam) orgidField() {}

func (orgsWithPrismaOrgidEqualsUniqueParam) unique() {}
func (orgsWithPrismaOrgidEqualsUniqueParam) equals() {}

type OrgsWithPrismaOrgnameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	orgnameField()
}

type OrgsWithPrismaOrgnameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	orgnameField()
}

type orgsWithPrismaOrgnameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgnameSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgnameSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgnameSetParam) orgsModel() {}

func (p orgsWithPrismaOrgnameSetParam) orgnameField() {}

type OrgsWithPrismaOrgnameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	orgnameField()
}

type orgsWithPrismaOrgnameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgnameEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgnameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgnameEqualsParam) orgsModel() {}

func (p orgsWithPrismaOrgnameEqualsParam) orgnameField() {}

func (orgsWithPrismaOrgnameSetParam) settable()  {}
func (orgsWithPrismaOrgnameEqualsParam) equals() {}

type orgsWithPrismaOrgnameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgnameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgnameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgnameEqualsUniqueParam) orgsModel()    {}
func (p orgsWithPrismaOrgnameEqualsUniqueParam) orgnameField() {}

func (orgsWithPrismaOrgnameEqualsUniqueParam) unique() {}
func (orgsWithPrismaOrgnameEqualsUniqueParam) equals() {}

type OrgsWithPrismaOrgmetaEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	orgmetaField()
}

type OrgsWithPrismaOrgmetaSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	orgmetaField()
}

type orgsWithPrismaOrgmetaSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgmetaSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgmetaSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgmetaSetParam) orgsModel() {}

func (p orgsWithPrismaOrgmetaSetParam) orgmetaField() {}

type OrgsWithPrismaOrgmetaWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	orgmetaField()
}

type orgsWithPrismaOrgmetaEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgmetaEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgmetaEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgmetaEqualsParam) orgsModel() {}

func (p orgsWithPrismaOrgmetaEqualsParam) orgmetaField() {}

func (orgsWithPrismaOrgmetaSetParam) settable()  {}
func (orgsWithPrismaOrgmetaEqualsParam) equals() {}

type orgsWithPrismaOrgmetaEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgmetaEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgmetaEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgmetaEqualsUniqueParam) orgsModel()    {}
func (p orgsWithPrismaOrgmetaEqualsUniqueParam) orgmetaField() {}

func (orgsWithPrismaOrgmetaEqualsUniqueParam) unique() {}
func (orgsWithPrismaOrgmetaEqualsUniqueParam) equals() {}

type OrgsWithPrismaIsenabledEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	isenabledField()
}

type OrgsWithPrismaIsenabledSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	isenabledField()
}

type orgsWithPrismaIsenabledSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaIsenabledSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaIsenabledSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaIsenabledSetParam) orgsModel() {}

func (p orgsWithPrismaIsenabledSetParam) isenabledField() {}

type OrgsWithPrismaIsenabledWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	isenabledField()
}

type orgsWithPrismaIsenabledEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaIsenabledEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaIsenabledEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaIsenabledEqualsParam) orgsModel() {}

func (p orgsWithPrismaIsenabledEqualsParam) isenabledField() {}

func (orgsWithPrismaIsenabledSetParam) settable()  {}
func (orgsWithPrismaIsenabledEqualsParam) equals() {}

type orgsWithPrismaIsenabledEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaIsenabledEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaIsenabledEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaIsenabledEqualsUniqueParam) orgsModel()      {}
func (p orgsWithPrismaIsenabledEqualsUniqueParam) isenabledField() {}

func (orgsWithPrismaIsenabledEqualsUniqueParam) unique() {}
func (orgsWithPrismaIsenabledEqualsUniqueParam) equals() {}

type OrgsWithPrismaCreatedbyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	createdbyField()
}

type OrgsWithPrismaCreatedbySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	createdbyField()
}

type orgsWithPrismaCreatedbySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaCreatedbySetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaCreatedbySetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaCreatedbySetParam) orgsModel() {}

func (p orgsWithPrismaCreatedbySetParam) createdbyField() {}

type OrgsWithPrismaCreatedbyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	createdbyField()
}

type orgsWithPrismaCreatedbyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaCreatedbyEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaCreatedbyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaCreatedbyEqualsParam) orgsModel() {}

func (p orgsWithPrismaCreatedbyEqualsParam) createdbyField() {}

func (orgsWithPrismaCreatedbySetParam) settable()  {}
func (orgsWithPrismaCreatedbyEqualsParam) equals() {}

type orgsWithPrismaCreatedbyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaCreatedbyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaCreatedbyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaCreatedbyEqualsUniqueParam) orgsModel()      {}
func (p orgsWithPrismaCreatedbyEqualsUniqueParam) createdbyField() {}

func (orgsWithPrismaCreatedbyEqualsUniqueParam) unique() {}
func (orgsWithPrismaCreatedbyEqualsUniqueParam) equals() {}

type OrgsWithPrismaUpdatedbyEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	updatedbyField()
}

type OrgsWithPrismaUpdatedbySetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	updatedbyField()
}

type orgsWithPrismaUpdatedbySetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaUpdatedbySetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaUpdatedbySetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaUpdatedbySetParam) orgsModel() {}

func (p orgsWithPrismaUpdatedbySetParam) updatedbyField() {}

type OrgsWithPrismaUpdatedbyWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	updatedbyField()
}

type orgsWithPrismaUpdatedbyEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaUpdatedbyEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaUpdatedbyEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaUpdatedbyEqualsParam) orgsModel() {}

func (p orgsWithPrismaUpdatedbyEqualsParam) updatedbyField() {}

func (orgsWithPrismaUpdatedbySetParam) settable()  {}
func (orgsWithPrismaUpdatedbyEqualsParam) equals() {}

type orgsWithPrismaUpdatedbyEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaUpdatedbyEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaUpdatedbyEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaUpdatedbyEqualsUniqueParam) orgsModel()      {}
func (p orgsWithPrismaUpdatedbyEqualsUniqueParam) updatedbyField() {}

func (orgsWithPrismaUpdatedbyEqualsUniqueParam) unique() {}
func (orgsWithPrismaUpdatedbyEqualsUniqueParam) equals() {}

type OrgsWithPrismaCreatedatEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	createdatField()
}

type OrgsWithPrismaCreatedatSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	createdatField()
}

type orgsWithPrismaCreatedatSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaCreatedatSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaCreatedatSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaCreatedatSetParam) orgsModel() {}

func (p orgsWithPrismaCreatedatSetParam) createdatField() {}

type OrgsWithPrismaCreatedatWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	createdatField()
}

type orgsWithPrismaCreatedatEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaCreatedatEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaCreatedatEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaCreatedatEqualsParam) orgsModel() {}

func (p orgsWithPrismaCreatedatEqualsParam) createdatField() {}

func (orgsWithPrismaCreatedatSetParam) settable()  {}
func (orgsWithPrismaCreatedatEqualsParam) equals() {}

type orgsWithPrismaCreatedatEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaCreatedatEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaCreatedatEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaCreatedatEqualsUniqueParam) orgsModel()      {}
func (p orgsWithPrismaCreatedatEqualsUniqueParam) createdatField() {}

func (orgsWithPrismaCreatedatEqualsUniqueParam) unique() {}
func (orgsWithPrismaCreatedatEqualsUniqueParam) equals() {}

type OrgsWithPrismaUpdatedatEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	updatedatField()
}

type OrgsWithPrismaUpdatedatSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	updatedatField()
}

type orgsWithPrismaUpdatedatSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaUpdatedatSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaUpdatedatSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaUpdatedatSetParam) orgsModel() {}

func (p orgsWithPrismaUpdatedatSetParam) updatedatField() {}

type OrgsWithPrismaUpdatedatWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	updatedatField()
}

type orgsWithPrismaUpdatedatEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaUpdatedatEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaUpdatedatEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaUpdatedatEqualsParam) orgsModel() {}

func (p orgsWithPrismaUpdatedatEqualsParam) updatedatField() {}

func (orgsWithPrismaUpdatedatSetParam) settable()  {}
func (orgsWithPrismaUpdatedatEqualsParam) equals() {}

type orgsWithPrismaUpdatedatEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaUpdatedatEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaUpdatedatEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaUpdatedatEqualsUniqueParam) orgsModel()      {}
func (p orgsWithPrismaUpdatedatEqualsUniqueParam) updatedatField() {}

func (orgsWithPrismaUpdatedatEqualsUniqueParam) unique() {}
func (orgsWithPrismaUpdatedatEqualsUniqueParam) equals() {}

type OrgsWithPrismaGroupdevicesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	groupdevicesField()
}

type OrgsWithPrismaGroupdevicesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	groupdevicesField()
}

type orgsWithPrismaGroupdevicesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaGroupdevicesSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaGroupdevicesSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaGroupdevicesSetParam) orgsModel() {}

func (p orgsWithPrismaGroupdevicesSetParam) groupdevicesField() {}

type OrgsWithPrismaGroupdevicesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	groupdevicesField()
}

type orgsWithPrismaGroupdevicesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaGroupdevicesEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaGroupdevicesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaGroupdevicesEqualsParam) orgsModel() {}

func (p orgsWithPrismaGroupdevicesEqualsParam) groupdevicesField() {}

func (orgsWithPrismaGroupdevicesSetParam) settable()  {}
func (orgsWithPrismaGroupdevicesEqualsParam) equals() {}

type orgsWithPrismaGroupdevicesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaGroupdevicesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaGroupdevicesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaGroupdevicesEqualsUniqueParam) orgsModel()         {}
func (p orgsWithPrismaGroupdevicesEqualsUniqueParam) groupdevicesField() {}

func (orgsWithPrismaGroupdevicesEqualsUniqueParam) unique() {}
func (orgsWithPrismaGroupdevicesEqualsUniqueParam) equals() {}

type OrgsWithPrismaGroupsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	groupsField()
}

type OrgsWithPrismaGroupsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	groupsField()
}

type orgsWithPrismaGroupsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaGroupsSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaGroupsSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaGroupsSetParam) orgsModel() {}

func (p orgsWithPrismaGroupsSetParam) groupsField() {}

type OrgsWithPrismaGroupsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	groupsField()
}

type orgsWithPrismaGroupsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaGroupsEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaGroupsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaGroupsEqualsParam) orgsModel() {}

func (p orgsWithPrismaGroupsEqualsParam) groupsField() {}

func (orgsWithPrismaGroupsSetParam) settable()  {}
func (orgsWithPrismaGroupsEqualsParam) equals() {}

type orgsWithPrismaGroupsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaGroupsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaGroupsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaGroupsEqualsUniqueParam) orgsModel()   {}
func (p orgsWithPrismaGroupsEqualsUniqueParam) groupsField() {}

func (orgsWithPrismaGroupsEqualsUniqueParam) unique() {}
func (orgsWithPrismaGroupsEqualsUniqueParam) equals() {}

type OrgsWithPrismaGrouptreeEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	grouptreeField()
}

type OrgsWithPrismaGrouptreeSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	grouptreeField()
}

type orgsWithPrismaGrouptreeSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaGrouptreeSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaGrouptreeSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaGrouptreeSetParam) orgsModel() {}

func (p orgsWithPrismaGrouptreeSetParam) grouptreeField() {}

type OrgsWithPrismaGrouptreeWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	grouptreeField()
}

type orgsWithPrismaGrouptreeEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaGrouptreeEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaGrouptreeEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaGrouptreeEqualsParam) orgsModel() {}

func (p orgsWithPrismaGrouptreeEqualsParam) grouptreeField() {}

func (orgsWithPrismaGrouptreeSetParam) settable()  {}
func (orgsWithPrismaGrouptreeEqualsParam) equals() {}

type orgsWithPrismaGrouptreeEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaGrouptreeEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaGrouptreeEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaGrouptreeEqualsUniqueParam) orgsModel()      {}
func (p orgsWithPrismaGrouptreeEqualsUniqueParam) grouptreeField() {}

func (orgsWithPrismaGrouptreeEqualsUniqueParam) unique() {}
func (orgsWithPrismaGrouptreeEqualsUniqueParam) equals() {}

type OrgsWithPrismaGroupuserpermsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	groupuserpermsField()
}

type OrgsWithPrismaGroupuserpermsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	groupuserpermsField()
}

type orgsWithPrismaGroupuserpermsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaGroupuserpermsSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaGroupuserpermsSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaGroupuserpermsSetParam) orgsModel() {}

func (p orgsWithPrismaGroupuserpermsSetParam) groupuserpermsField() {}

type OrgsWithPrismaGroupuserpermsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	groupuserpermsField()
}

type orgsWithPrismaGroupuserpermsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaGroupuserpermsEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaGroupuserpermsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaGroupuserpermsEqualsParam) orgsModel() {}

func (p orgsWithPrismaGroupuserpermsEqualsParam) groupuserpermsField() {}

func (orgsWithPrismaGroupuserpermsSetParam) settable()  {}
func (orgsWithPrismaGroupuserpermsEqualsParam) equals() {}

type orgsWithPrismaGroupuserpermsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaGroupuserpermsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaGroupuserpermsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaGroupuserpermsEqualsUniqueParam) orgsModel()           {}
func (p orgsWithPrismaGroupuserpermsEqualsUniqueParam) groupuserpermsField() {}

func (orgsWithPrismaGroupuserpermsEqualsUniqueParam) unique() {}
func (orgsWithPrismaGroupuserpermsEqualsUniqueParam) equals() {}

type OrgsWithPrismaOrgdevicesEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	orgdevicesField()
}

type OrgsWithPrismaOrgdevicesSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	orgdevicesField()
}

type orgsWithPrismaOrgdevicesSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgdevicesSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgdevicesSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgdevicesSetParam) orgsModel() {}

func (p orgsWithPrismaOrgdevicesSetParam) orgdevicesField() {}

type OrgsWithPrismaOrgdevicesWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	orgdevicesField()
}

type orgsWithPrismaOrgdevicesEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgdevicesEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgdevicesEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgdevicesEqualsParam) orgsModel() {}

func (p orgsWithPrismaOrgdevicesEqualsParam) orgdevicesField() {}

func (orgsWithPrismaOrgdevicesSetParam) settable()  {}
func (orgsWithPrismaOrgdevicesEqualsParam) equals() {}

type orgsWithPrismaOrgdevicesEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgdevicesEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgdevicesEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgdevicesEqualsUniqueParam) orgsModel()       {}
func (p orgsWithPrismaOrgdevicesEqualsUniqueParam) orgdevicesField() {}

func (orgsWithPrismaOrgdevicesEqualsUniqueParam) unique() {}
func (orgsWithPrismaOrgdevicesEqualsUniqueParam) equals() {}

type OrgsWithPrismaOrgrgroupEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	orgrgroupField()
}

type OrgsWithPrismaOrgrgroupSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	orgrgroupField()
}

type orgsWithPrismaOrgrgroupSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgrgroupSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgrgroupSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgrgroupSetParam) orgsModel() {}

func (p orgsWithPrismaOrgrgroupSetParam) orgrgroupField() {}

type OrgsWithPrismaOrgrgroupWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	orgrgroupField()
}

type orgsWithPrismaOrgrgroupEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgrgroupEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgrgroupEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgrgroupEqualsParam) orgsModel() {}

func (p orgsWithPrismaOrgrgroupEqualsParam) orgrgroupField() {}

func (orgsWithPrismaOrgrgroupSetParam) settable()  {}
func (orgsWithPrismaOrgrgroupEqualsParam) equals() {}

type orgsWithPrismaOrgrgroupEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaOrgrgroupEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaOrgrgroupEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaOrgrgroupEqualsUniqueParam) orgsModel()      {}
func (p orgsWithPrismaOrgrgroupEqualsUniqueParam) orgrgroupField() {}

func (orgsWithPrismaOrgrgroupEqualsUniqueParam) unique() {}
func (orgsWithPrismaOrgrgroupEqualsUniqueParam) equals() {}

type OrgsWithPrismaUsergroupEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	orgsModel()
	usergroupField()
}

type OrgsWithPrismaUsergroupSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	usergroupField()
}

type orgsWithPrismaUsergroupSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaUsergroupSetParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaUsergroupSetParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaUsergroupSetParam) orgsModel() {}

func (p orgsWithPrismaUsergroupSetParam) usergroupField() {}

type OrgsWithPrismaUsergroupWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	orgsModel()
	usergroupField()
}

type orgsWithPrismaUsergroupEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaUsergroupEqualsParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaUsergroupEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaUsergroupEqualsParam) orgsModel() {}

func (p orgsWithPrismaUsergroupEqualsParam) usergroupField() {}

func (orgsWithPrismaUsergroupSetParam) settable()  {}
func (orgsWithPrismaUsergroupEqualsParam) equals() {}

type orgsWithPrismaUsergroupEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p orgsWithPrismaUsergroupEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p orgsWithPrismaUsergroupEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p orgsWithPrismaUsergroupEqualsUniqueParam) orgsModel()      {}
func (p orgsWithPrismaUsergroupEqualsUniqueParam) usergroupField() {}

func (orgsWithPrismaUsergroupEqualsUniqueParam) unique() {}
func (orgsWithPrismaUsergroupEqualsUniqueParam) equals() {}

type usergroupActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var usergroupOutput = []builder.Output{
	{Name: "userid"},
	{Name: "orgid"},
	{Name: "groupid"},
}

type UsergroupRelationWith interface {
	getQuery() builder.Query
	with()
	usergroupRelation()
}

type UsergroupWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
}

type usergroupDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupDefaultParam) field() builder.Field {
	return p.data
}

func (p usergroupDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupDefaultParam) usergroupModel() {}

type UsergroupOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
}

type usergroupOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupOrderByParam) field() builder.Field {
	return p.data
}

func (p usergroupOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupOrderByParam) usergroupModel() {}

type UsergroupCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	isCursor()
}

type usergroupCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupCursorParam) field() builder.Field {
	return p.data
}

func (p usergroupCursorParam) isCursor() {}

func (p usergroupCursorParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupCursorParam) usergroupModel() {}

type UsergroupParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	usergroupModel()
}

type usergroupParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupParamUnique) usergroupModel() {}

func (usergroupParamUnique) unique() {}

func (p usergroupParamUnique) field() builder.Field {
	return p.data
}

func (p usergroupParamUnique) getQuery() builder.Query {
	return p.query
}

type UsergroupEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usergroupModel()
}

type usergroupEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupEqualsParam) usergroupModel() {}

func (usergroupEqualsParam) equals() {}

func (p usergroupEqualsParam) field() builder.Field {
	return p.data
}

func (p usergroupEqualsParam) getQuery() builder.Query {
	return p.query
}

type UsergroupEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	usergroupModel()
}

type usergroupEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupEqualsUniqueParam) usergroupModel() {}

func (usergroupEqualsUniqueParam) unique() {}
func (usergroupEqualsUniqueParam) equals() {}

func (p usergroupEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usergroupEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UsergroupSetParam interface {
	field() builder.Field
	settable()
	usergroupModel()
}

type usergroupSetParam struct {
	data builder.Field
}

func (usergroupSetParam) settable() {}

func (p usergroupSetParam) field() builder.Field {
	return p.data
}

func (p usergroupSetParam) usergroupModel() {}

type UsergroupWithPrismaUseridEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usergroupModel()
	useridField()
}

type UsergroupWithPrismaUseridSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	useridField()
}

type usergroupWithPrismaUseridSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaUseridSetParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaUseridSetParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaUseridSetParam) usergroupModel() {}

func (p usergroupWithPrismaUseridSetParam) useridField() {}

type UsergroupWithPrismaUseridWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	useridField()
}

type usergroupWithPrismaUseridEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaUseridEqualsParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaUseridEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaUseridEqualsParam) usergroupModel() {}

func (p usergroupWithPrismaUseridEqualsParam) useridField() {}

func (usergroupWithPrismaUseridSetParam) settable()  {}
func (usergroupWithPrismaUseridEqualsParam) equals() {}

type usergroupWithPrismaUseridEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaUseridEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaUseridEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaUseridEqualsUniqueParam) usergroupModel() {}
func (p usergroupWithPrismaUseridEqualsUniqueParam) useridField()    {}

func (usergroupWithPrismaUseridEqualsUniqueParam) unique() {}
func (usergroupWithPrismaUseridEqualsUniqueParam) equals() {}

type UsergroupWithPrismaOrgidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usergroupModel()
	orgidField()
}

type UsergroupWithPrismaOrgidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	orgidField()
}

type usergroupWithPrismaOrgidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaOrgidSetParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaOrgidSetParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaOrgidSetParam) usergroupModel() {}

func (p usergroupWithPrismaOrgidSetParam) orgidField() {}

type UsergroupWithPrismaOrgidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	orgidField()
}

type usergroupWithPrismaOrgidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaOrgidEqualsParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaOrgidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaOrgidEqualsParam) usergroupModel() {}

func (p usergroupWithPrismaOrgidEqualsParam) orgidField() {}

func (usergroupWithPrismaOrgidSetParam) settable()  {}
func (usergroupWithPrismaOrgidEqualsParam) equals() {}

type usergroupWithPrismaOrgidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaOrgidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaOrgidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaOrgidEqualsUniqueParam) usergroupModel() {}
func (p usergroupWithPrismaOrgidEqualsUniqueParam) orgidField()     {}

func (usergroupWithPrismaOrgidEqualsUniqueParam) unique() {}
func (usergroupWithPrismaOrgidEqualsUniqueParam) equals() {}

type UsergroupWithPrismaGroupidEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usergroupModel()
	groupidField()
}

type UsergroupWithPrismaGroupidSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	groupidField()
}

type usergroupWithPrismaGroupidSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaGroupidSetParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaGroupidSetParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaGroupidSetParam) usergroupModel() {}

func (p usergroupWithPrismaGroupidSetParam) groupidField() {}

type UsergroupWithPrismaGroupidWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	groupidField()
}

type usergroupWithPrismaGroupidEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaGroupidEqualsParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaGroupidEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaGroupidEqualsParam) usergroupModel() {}

func (p usergroupWithPrismaGroupidEqualsParam) groupidField() {}

func (usergroupWithPrismaGroupidSetParam) settable()  {}
func (usergroupWithPrismaGroupidEqualsParam) equals() {}

type usergroupWithPrismaGroupidEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaGroupidEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaGroupidEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaGroupidEqualsUniqueParam) usergroupModel() {}
func (p usergroupWithPrismaGroupidEqualsUniqueParam) groupidField()   {}

func (usergroupWithPrismaGroupidEqualsUniqueParam) unique() {}
func (usergroupWithPrismaGroupidEqualsUniqueParam) equals() {}

type UsergroupWithPrismaGroupsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usergroupModel()
	groupsField()
}

type UsergroupWithPrismaGroupsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	groupsField()
}

type usergroupWithPrismaGroupsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaGroupsSetParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaGroupsSetParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaGroupsSetParam) usergroupModel() {}

func (p usergroupWithPrismaGroupsSetParam) groupsField() {}

type UsergroupWithPrismaGroupsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	groupsField()
}

type usergroupWithPrismaGroupsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaGroupsEqualsParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaGroupsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaGroupsEqualsParam) usergroupModel() {}

func (p usergroupWithPrismaGroupsEqualsParam) groupsField() {}

func (usergroupWithPrismaGroupsSetParam) settable()  {}
func (usergroupWithPrismaGroupsEqualsParam) equals() {}

type usergroupWithPrismaGroupsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaGroupsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaGroupsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaGroupsEqualsUniqueParam) usergroupModel() {}
func (p usergroupWithPrismaGroupsEqualsUniqueParam) groupsField()    {}

func (usergroupWithPrismaGroupsEqualsUniqueParam) unique() {}
func (usergroupWithPrismaGroupsEqualsUniqueParam) equals() {}

type UsergroupWithPrismaOrgsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usergroupModel()
	orgsField()
}

type UsergroupWithPrismaOrgsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	orgsField()
}

type usergroupWithPrismaOrgsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaOrgsSetParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaOrgsSetParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaOrgsSetParam) usergroupModel() {}

func (p usergroupWithPrismaOrgsSetParam) orgsField() {}

type UsergroupWithPrismaOrgsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	orgsField()
}

type usergroupWithPrismaOrgsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaOrgsEqualsParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaOrgsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaOrgsEqualsParam) usergroupModel() {}

func (p usergroupWithPrismaOrgsEqualsParam) orgsField() {}

func (usergroupWithPrismaOrgsSetParam) settable()  {}
func (usergroupWithPrismaOrgsEqualsParam) equals() {}

type usergroupWithPrismaOrgsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaOrgsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaOrgsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaOrgsEqualsUniqueParam) usergroupModel() {}
func (p usergroupWithPrismaOrgsEqualsUniqueParam) orgsField()      {}

func (usergroupWithPrismaOrgsEqualsUniqueParam) unique() {}
func (usergroupWithPrismaOrgsEqualsUniqueParam) equals() {}

type UsergroupWithPrismaUsersEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usergroupModel()
	usersField()
}

type UsergroupWithPrismaUsersSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	usersField()
}

type usergroupWithPrismaUsersSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaUsersSetParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaUsersSetParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaUsersSetParam) usergroupModel() {}

func (p usergroupWithPrismaUsersSetParam) usersField() {}

type UsergroupWithPrismaUsersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usergroupModel()
	usersField()
}

type usergroupWithPrismaUsersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaUsersEqualsParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaUsersEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaUsersEqualsParam) usergroupModel() {}

func (p usergroupWithPrismaUsersEqualsParam) usersField() {}

func (usergroupWithPrismaUsersSetParam) settable()  {}
func (usergroupWithPrismaUsersEqualsParam) equals() {}

type usergroupWithPrismaUsersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usergroupWithPrismaUsersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usergroupWithPrismaUsersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usergroupWithPrismaUsersEqualsUniqueParam) usergroupModel() {}
func (p usergroupWithPrismaUsersEqualsUniqueParam) usersField()     {}

func (usergroupWithPrismaUsersEqualsUniqueParam) unique() {}
func (usergroupWithPrismaUsersEqualsUniqueParam) equals() {}

type usersActions struct {
	// client holds the prisma client
	client *PrismaClient
}

var usersOutput = []builder.Output{
	{Name: "userid"},
	{Name: "name"},
	{Name: "email"},
	{Name: "isemailverified"},
	{Name: "usermeta"},
	{Name: "isenabled"},
	{Name: "secretprv"},
	{Name: "secretpub"},
	{Name: "createdat"},
	{Name: "updatedat"},
}

type UsersRelationWith interface {
	getQuery() builder.Query
	with()
	usersRelation()
}

type UsersWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
}

type usersDefaultParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersDefaultParam) field() builder.Field {
	return p.data
}

func (p usersDefaultParam) getQuery() builder.Query {
	return p.query
}

func (p usersDefaultParam) usersModel() {}

type UsersOrderByParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
}

type usersOrderByParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersOrderByParam) field() builder.Field {
	return p.data
}

func (p usersOrderByParam) getQuery() builder.Query {
	return p.query
}

func (p usersOrderByParam) usersModel() {}

type UsersCursorParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	isCursor()
}

type usersCursorParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersCursorParam) field() builder.Field {
	return p.data
}

func (p usersCursorParam) isCursor() {}

func (p usersCursorParam) getQuery() builder.Query {
	return p.query
}

func (p usersCursorParam) usersModel() {}

type UsersParamUnique interface {
	field() builder.Field
	getQuery() builder.Query
	unique()
	usersModel()
}

type usersParamUnique struct {
	data  builder.Field
	query builder.Query
}

func (p usersParamUnique) usersModel() {}

func (usersParamUnique) unique() {}

func (p usersParamUnique) field() builder.Field {
	return p.data
}

func (p usersParamUnique) getQuery() builder.Query {
	return p.query
}

type UsersEqualsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
}

type usersEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersEqualsParam) usersModel() {}

func (usersEqualsParam) equals() {}

func (p usersEqualsParam) field() builder.Field {
	return p.data
}

func (p usersEqualsParam) getQuery() builder.Query {
	return p.query
}

type UsersEqualsUniqueWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	unique()
	usersModel()
}

type usersEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersEqualsUniqueParam) usersModel() {}

func (usersEqualsUniqueParam) unique() {}
func (usersEqualsUniqueParam) equals() {}

func (p usersEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

type UsersSetParam interface {
	field() builder.Field
	settable()
	usersModel()
}

type usersSetParam struct {
	data builder.Field
}

func (usersSetParam) settable() {}

func (p usersSetParam) field() builder.Field {
	return p.data
}

func (p usersSetParam) usersModel() {}

type UsersWithPrismaUseridEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	useridField()
}

type UsersWithPrismaUseridSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	useridField()
}

type usersWithPrismaUseridSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUseridSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUseridSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUseridSetParam) usersModel() {}

func (p usersWithPrismaUseridSetParam) useridField() {}

type UsersWithPrismaUseridWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	useridField()
}

type usersWithPrismaUseridEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUseridEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUseridEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUseridEqualsParam) usersModel() {}

func (p usersWithPrismaUseridEqualsParam) useridField() {}

func (usersWithPrismaUseridSetParam) settable()  {}
func (usersWithPrismaUseridEqualsParam) equals() {}

type usersWithPrismaUseridEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUseridEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUseridEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUseridEqualsUniqueParam) usersModel()  {}
func (p usersWithPrismaUseridEqualsUniqueParam) useridField() {}

func (usersWithPrismaUseridEqualsUniqueParam) unique() {}
func (usersWithPrismaUseridEqualsUniqueParam) equals() {}

type UsersWithPrismaNameEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	nameField()
}

type UsersWithPrismaNameSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	nameField()
}

type usersWithPrismaNameSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaNameSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaNameSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaNameSetParam) usersModel() {}

func (p usersWithPrismaNameSetParam) nameField() {}

type UsersWithPrismaNameWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	nameField()
}

type usersWithPrismaNameEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaNameEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaNameEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaNameEqualsParam) usersModel() {}

func (p usersWithPrismaNameEqualsParam) nameField() {}

func (usersWithPrismaNameSetParam) settable()  {}
func (usersWithPrismaNameEqualsParam) equals() {}

type usersWithPrismaNameEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaNameEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaNameEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaNameEqualsUniqueParam) usersModel() {}
func (p usersWithPrismaNameEqualsUniqueParam) nameField()  {}

func (usersWithPrismaNameEqualsUniqueParam) unique() {}
func (usersWithPrismaNameEqualsUniqueParam) equals() {}

type UsersWithPrismaEmailEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	emailField()
}

type UsersWithPrismaEmailSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	emailField()
}

type usersWithPrismaEmailSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailSetParam) usersModel() {}

func (p usersWithPrismaEmailSetParam) emailField() {}

type UsersWithPrismaEmailWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	emailField()
}

type usersWithPrismaEmailEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailEqualsParam) usersModel() {}

func (p usersWithPrismaEmailEqualsParam) emailField() {}

func (usersWithPrismaEmailSetParam) settable()  {}
func (usersWithPrismaEmailEqualsParam) equals() {}

type usersWithPrismaEmailEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaEmailEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaEmailEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaEmailEqualsUniqueParam) usersModel() {}
func (p usersWithPrismaEmailEqualsUniqueParam) emailField() {}

func (usersWithPrismaEmailEqualsUniqueParam) unique() {}
func (usersWithPrismaEmailEqualsUniqueParam) equals() {}

type UsersWithPrismaIsemailverifiedEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	isemailverifiedField()
}

type UsersWithPrismaIsemailverifiedSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	isemailverifiedField()
}

type usersWithPrismaIsemailverifiedSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIsemailverifiedSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIsemailverifiedSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIsemailverifiedSetParam) usersModel() {}

func (p usersWithPrismaIsemailverifiedSetParam) isemailverifiedField() {}

type UsersWithPrismaIsemailverifiedWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	isemailverifiedField()
}

type usersWithPrismaIsemailverifiedEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIsemailverifiedEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIsemailverifiedEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIsemailverifiedEqualsParam) usersModel() {}

func (p usersWithPrismaIsemailverifiedEqualsParam) isemailverifiedField() {}

func (usersWithPrismaIsemailverifiedSetParam) settable()  {}
func (usersWithPrismaIsemailverifiedEqualsParam) equals() {}

type usersWithPrismaIsemailverifiedEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIsemailverifiedEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIsemailverifiedEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIsemailverifiedEqualsUniqueParam) usersModel()           {}
func (p usersWithPrismaIsemailverifiedEqualsUniqueParam) isemailverifiedField() {}

func (usersWithPrismaIsemailverifiedEqualsUniqueParam) unique() {}
func (usersWithPrismaIsemailverifiedEqualsUniqueParam) equals() {}

type UsersWithPrismaUsermetaEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	usermetaField()
}

type UsersWithPrismaUsermetaSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	usermetaField()
}

type usersWithPrismaUsermetaSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUsermetaSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUsermetaSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUsermetaSetParam) usersModel() {}

func (p usersWithPrismaUsermetaSetParam) usermetaField() {}

type UsersWithPrismaUsermetaWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	usermetaField()
}

type usersWithPrismaUsermetaEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUsermetaEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUsermetaEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUsermetaEqualsParam) usersModel() {}

func (p usersWithPrismaUsermetaEqualsParam) usermetaField() {}

func (usersWithPrismaUsermetaSetParam) settable()  {}
func (usersWithPrismaUsermetaEqualsParam) equals() {}

type usersWithPrismaUsermetaEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUsermetaEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUsermetaEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUsermetaEqualsUniqueParam) usersModel()    {}
func (p usersWithPrismaUsermetaEqualsUniqueParam) usermetaField() {}

func (usersWithPrismaUsermetaEqualsUniqueParam) unique() {}
func (usersWithPrismaUsermetaEqualsUniqueParam) equals() {}

type UsersWithPrismaIsenabledEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	isenabledField()
}

type UsersWithPrismaIsenabledSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	isenabledField()
}

type usersWithPrismaIsenabledSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIsenabledSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIsenabledSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIsenabledSetParam) usersModel() {}

func (p usersWithPrismaIsenabledSetParam) isenabledField() {}

type UsersWithPrismaIsenabledWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	isenabledField()
}

type usersWithPrismaIsenabledEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIsenabledEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIsenabledEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIsenabledEqualsParam) usersModel() {}

func (p usersWithPrismaIsenabledEqualsParam) isenabledField() {}

func (usersWithPrismaIsenabledSetParam) settable()  {}
func (usersWithPrismaIsenabledEqualsParam) equals() {}

type usersWithPrismaIsenabledEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaIsenabledEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaIsenabledEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaIsenabledEqualsUniqueParam) usersModel()     {}
func (p usersWithPrismaIsenabledEqualsUniqueParam) isenabledField() {}

func (usersWithPrismaIsenabledEqualsUniqueParam) unique() {}
func (usersWithPrismaIsenabledEqualsUniqueParam) equals() {}

type UsersWithPrismaSecretprvEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	secretprvField()
}

type UsersWithPrismaSecretprvSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	secretprvField()
}

type usersWithPrismaSecretprvSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaSecretprvSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaSecretprvSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaSecretprvSetParam) usersModel() {}

func (p usersWithPrismaSecretprvSetParam) secretprvField() {}

type UsersWithPrismaSecretprvWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	secretprvField()
}

type usersWithPrismaSecretprvEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaSecretprvEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaSecretprvEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaSecretprvEqualsParam) usersModel() {}

func (p usersWithPrismaSecretprvEqualsParam) secretprvField() {}

func (usersWithPrismaSecretprvSetParam) settable()  {}
func (usersWithPrismaSecretprvEqualsParam) equals() {}

type usersWithPrismaSecretprvEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaSecretprvEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaSecretprvEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaSecretprvEqualsUniqueParam) usersModel()     {}
func (p usersWithPrismaSecretprvEqualsUniqueParam) secretprvField() {}

func (usersWithPrismaSecretprvEqualsUniqueParam) unique() {}
func (usersWithPrismaSecretprvEqualsUniqueParam) equals() {}

type UsersWithPrismaSecretpubEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	secretpubField()
}

type UsersWithPrismaSecretpubSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	secretpubField()
}

type usersWithPrismaSecretpubSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaSecretpubSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaSecretpubSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaSecretpubSetParam) usersModel() {}

func (p usersWithPrismaSecretpubSetParam) secretpubField() {}

type UsersWithPrismaSecretpubWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	secretpubField()
}

type usersWithPrismaSecretpubEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaSecretpubEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaSecretpubEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaSecretpubEqualsParam) usersModel() {}

func (p usersWithPrismaSecretpubEqualsParam) secretpubField() {}

func (usersWithPrismaSecretpubSetParam) settable()  {}
func (usersWithPrismaSecretpubEqualsParam) equals() {}

type usersWithPrismaSecretpubEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaSecretpubEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaSecretpubEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaSecretpubEqualsUniqueParam) usersModel()     {}
func (p usersWithPrismaSecretpubEqualsUniqueParam) secretpubField() {}

func (usersWithPrismaSecretpubEqualsUniqueParam) unique() {}
func (usersWithPrismaSecretpubEqualsUniqueParam) equals() {}

type UsersWithPrismaCreatedatEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	createdatField()
}

type UsersWithPrismaCreatedatSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	createdatField()
}

type usersWithPrismaCreatedatSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaCreatedatSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaCreatedatSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaCreatedatSetParam) usersModel() {}

func (p usersWithPrismaCreatedatSetParam) createdatField() {}

type UsersWithPrismaCreatedatWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	createdatField()
}

type usersWithPrismaCreatedatEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaCreatedatEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaCreatedatEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaCreatedatEqualsParam) usersModel() {}

func (p usersWithPrismaCreatedatEqualsParam) createdatField() {}

func (usersWithPrismaCreatedatSetParam) settable()  {}
func (usersWithPrismaCreatedatEqualsParam) equals() {}

type usersWithPrismaCreatedatEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaCreatedatEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaCreatedatEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaCreatedatEqualsUniqueParam) usersModel()     {}
func (p usersWithPrismaCreatedatEqualsUniqueParam) createdatField() {}

func (usersWithPrismaCreatedatEqualsUniqueParam) unique() {}
func (usersWithPrismaCreatedatEqualsUniqueParam) equals() {}

type UsersWithPrismaUpdatedatEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	updatedatField()
}

type UsersWithPrismaUpdatedatSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	updatedatField()
}

type usersWithPrismaUpdatedatSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUpdatedatSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUpdatedatSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUpdatedatSetParam) usersModel() {}

func (p usersWithPrismaUpdatedatSetParam) updatedatField() {}

type UsersWithPrismaUpdatedatWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	updatedatField()
}

type usersWithPrismaUpdatedatEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUpdatedatEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUpdatedatEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUpdatedatEqualsParam) usersModel() {}

func (p usersWithPrismaUpdatedatEqualsParam) updatedatField() {}

func (usersWithPrismaUpdatedatSetParam) settable()  {}
func (usersWithPrismaUpdatedatEqualsParam) equals() {}

type usersWithPrismaUpdatedatEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUpdatedatEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUpdatedatEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUpdatedatEqualsUniqueParam) usersModel()     {}
func (p usersWithPrismaUpdatedatEqualsUniqueParam) updatedatField() {}

func (usersWithPrismaUpdatedatEqualsUniqueParam) unique() {}
func (usersWithPrismaUpdatedatEqualsUniqueParam) equals() {}

type UsersWithPrismaGroupuserpermsEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	groupuserpermsField()
}

type UsersWithPrismaGroupuserpermsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	groupuserpermsField()
}

type usersWithPrismaGroupuserpermsSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaGroupuserpermsSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaGroupuserpermsSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaGroupuserpermsSetParam) usersModel() {}

func (p usersWithPrismaGroupuserpermsSetParam) groupuserpermsField() {}

type UsersWithPrismaGroupuserpermsWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	groupuserpermsField()
}

type usersWithPrismaGroupuserpermsEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaGroupuserpermsEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaGroupuserpermsEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaGroupuserpermsEqualsParam) usersModel() {}

func (p usersWithPrismaGroupuserpermsEqualsParam) groupuserpermsField() {}

func (usersWithPrismaGroupuserpermsSetParam) settable()  {}
func (usersWithPrismaGroupuserpermsEqualsParam) equals() {}

type usersWithPrismaGroupuserpermsEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaGroupuserpermsEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaGroupuserpermsEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaGroupuserpermsEqualsUniqueParam) usersModel()          {}
func (p usersWithPrismaGroupuserpermsEqualsUniqueParam) groupuserpermsField() {}

func (usersWithPrismaGroupuserpermsEqualsUniqueParam) unique() {}
func (usersWithPrismaGroupuserpermsEqualsUniqueParam) equals() {}

type UsersWithPrismaUsergroupEqualsSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	equals()
	usersModel()
	usergroupField()
}

type UsersWithPrismaUsergroupSetParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	usergroupField()
}

type usersWithPrismaUsergroupSetParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUsergroupSetParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUsergroupSetParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUsergroupSetParam) usersModel() {}

func (p usersWithPrismaUsergroupSetParam) usergroupField() {}

type UsersWithPrismaUsergroupWhereParam interface {
	field() builder.Field
	getQuery() builder.Query
	usersModel()
	usergroupField()
}

type usersWithPrismaUsergroupEqualsParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUsergroupEqualsParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUsergroupEqualsParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUsergroupEqualsParam) usersModel() {}

func (p usersWithPrismaUsergroupEqualsParam) usergroupField() {}

func (usersWithPrismaUsergroupSetParam) settable()  {}
func (usersWithPrismaUsergroupEqualsParam) equals() {}

type usersWithPrismaUsergroupEqualsUniqueParam struct {
	data  builder.Field
	query builder.Query
}

func (p usersWithPrismaUsergroupEqualsUniqueParam) field() builder.Field {
	return p.data
}

func (p usersWithPrismaUsergroupEqualsUniqueParam) getQuery() builder.Query {
	return p.query
}

func (p usersWithPrismaUsergroupEqualsUniqueParam) usersModel()     {}
func (p usersWithPrismaUsergroupEqualsUniqueParam) usergroupField() {}

func (usersWithPrismaUsergroupEqualsUniqueParam) unique() {}
func (usersWithPrismaUsergroupEqualsUniqueParam) equals() {}

// --- template create.gotpl ---

// Creates a single activitylog.
func (r activitylogActions) CreateOne(
	_msgtype ActivitylogWithPrismaMsgtypeSetParam,
	_msgpayload ActivitylogWithPrismaMsgpayloadSetParam,

	optional ...ActivitylogSetParam,
) activitylogCreateOne {
	var v activitylogCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "activitylog"
	v.query.Outputs = activitylogOutput

	var fields []builder.Field

	fields = append(fields, _msgtype.field())
	fields = append(fields, _msgpayload.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r activitylogCreateOne) With(params ...ActivitylogRelationWith) activitylogCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type activitylogCreateOne struct {
	query builder.Query
}

func (p activitylogCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p activitylogCreateOne) activitylogModel() {}

func (r activitylogCreateOne) Exec(ctx context.Context) (*ActivitylogModel, error) {
	var v ActivitylogModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r activitylogCreateOne) Tx() ActivitylogUniqueTxResult {
	v := newActivitylogUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single devices.
func (r devicesActions) CreateOne(
	_deviceid DevicesWithPrismaDeviceidSetParam,
	_devicemeta DevicesWithPrismaDevicemetaSetParam,
	_createdby DevicesWithPrismaCreatedbySetParam,
	_updatedby DevicesWithPrismaUpdatedbySetParam,

	optional ...DevicesSetParam,
) devicesCreateOne {
	var v devicesCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "devices"
	v.query.Outputs = devicesOutput

	var fields []builder.Field

	fields = append(fields, _deviceid.field())
	fields = append(fields, _devicemeta.field())
	fields = append(fields, _createdby.field())
	fields = append(fields, _updatedby.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r devicesCreateOne) With(params ...DevicesRelationWith) devicesCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type devicesCreateOne struct {
	query builder.Query
}

func (p devicesCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p devicesCreateOne) devicesModel() {}

func (r devicesCreateOne) Exec(ctx context.Context) (*DevicesModel, error) {
	var v DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesCreateOne) Tx() DevicesUniqueTxResult {
	v := newDevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single groupdevices.
func (r groupdevicesActions) CreateOne(
	_isexist GroupdevicesWithPrismaIsexistSetParam,
	_updatedby GroupdevicesWithPrismaUpdatedbySetParam,
	_devices GroupdevicesWithPrismaDevicesSetParam,
	_groups GroupdevicesWithPrismaGroupsSetParam,
	_orgs GroupdevicesWithPrismaOrgsSetParam,

	optional ...GroupdevicesSetParam,
) groupdevicesCreateOne {
	var v groupdevicesCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "groupdevices"
	v.query.Outputs = groupdevicesOutput

	var fields []builder.Field

	fields = append(fields, _isexist.field())
	fields = append(fields, _updatedby.field())
	fields = append(fields, _devices.field())
	fields = append(fields, _groups.field())
	fields = append(fields, _orgs.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r groupdevicesCreateOne) With(params ...GroupdevicesRelationWith) groupdevicesCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type groupdevicesCreateOne struct {
	query builder.Query
}

func (p groupdevicesCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p groupdevicesCreateOne) groupdevicesModel() {}

func (r groupdevicesCreateOne) Exec(ctx context.Context) (*GroupdevicesModel, error) {
	var v GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesCreateOne) Tx() GroupdevicesUniqueTxResult {
	v := newGroupdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single groups.
func (r groupsActions) CreateOne(
	_groupid GroupsWithPrismaGroupidSetParam,
	_groupname GroupsWithPrismaGroupnameSetParam,
	_isdeleted GroupsWithPrismaIsdeletedSetParam,
	_createdby GroupsWithPrismaCreatedbySetParam,
	_updatedby GroupsWithPrismaUpdatedbySetParam,
	_orgs GroupsWithPrismaOrgsSetParam,

	optional ...GroupsSetParam,
) groupsCreateOne {
	var v groupsCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "groups"
	v.query.Outputs = groupsOutput

	var fields []builder.Field

	fields = append(fields, _groupid.field())
	fields = append(fields, _groupname.field())
	fields = append(fields, _isdeleted.field())
	fields = append(fields, _createdby.field())
	fields = append(fields, _updatedby.field())
	fields = append(fields, _orgs.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r groupsCreateOne) With(params ...GroupsRelationWith) groupsCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type groupsCreateOne struct {
	query builder.Query
}

func (p groupsCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p groupsCreateOne) groupsModel() {}

func (r groupsCreateOne) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsCreateOne) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single grouptree.
func (r grouptreeActions) CreateOne(
	_name GrouptreeWithPrismaNameSetParam,
	_groupsGrouptreeGroupidTogroups GrouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam,
	_orgs GrouptreeWithPrismaOrgsSetParam,
	_groupsGrouptreePgroupidTogroups GrouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam,

	optional ...GrouptreeSetParam,
) grouptreeCreateOne {
	var v grouptreeCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "grouptree"
	v.query.Outputs = grouptreeOutput

	var fields []builder.Field

	fields = append(fields, _name.field())
	fields = append(fields, _groupsGrouptreeGroupidTogroups.field())
	fields = append(fields, _orgs.field())
	fields = append(fields, _groupsGrouptreePgroupidTogroups.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r grouptreeCreateOne) With(params ...GrouptreeRelationWith) grouptreeCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type grouptreeCreateOne struct {
	query builder.Query
}

func (p grouptreeCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p grouptreeCreateOne) grouptreeModel() {}

func (r grouptreeCreateOne) Exec(ctx context.Context) (*GrouptreeModel, error) {
	var v GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeCreateOne) Tx() GrouptreeUniqueTxResult {
	v := newGrouptreeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single groupuserperms.
func (r groupuserpermsActions) CreateOne(
	_permid GroupuserpermsWithPrismaPermidSetParam,
	_groups GroupuserpermsWithPrismaGroupsSetParam,
	_orgs GroupuserpermsWithPrismaOrgsSetParam,
	_users GroupuserpermsWithPrismaUsersSetParam,

	optional ...GroupuserpermsSetParam,
) groupuserpermsCreateOne {
	var v groupuserpermsCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "groupuserperms"
	v.query.Outputs = groupuserpermsOutput

	var fields []builder.Field

	fields = append(fields, _permid.field())
	fields = append(fields, _groups.field())
	fields = append(fields, _orgs.field())
	fields = append(fields, _users.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r groupuserpermsCreateOne) With(params ...GroupuserpermsRelationWith) groupuserpermsCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type groupuserpermsCreateOne struct {
	query builder.Query
}

func (p groupuserpermsCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p groupuserpermsCreateOne) groupuserpermsModel() {}

func (r groupuserpermsCreateOne) Exec(ctx context.Context) (*GroupuserpermsModel, error) {
	var v GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsCreateOne) Tx() GroupuserpermsUniqueTxResult {
	v := newGroupuserpermsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single orgdevices.
func (r orgdevicesActions) CreateOne(
	_orgdevicemeta OrgdevicesWithPrismaOrgdevicemetaSetParam,
	_updatedby OrgdevicesWithPrismaUpdatedbySetParam,
	_devices OrgdevicesWithPrismaDevicesSetParam,
	_orgs OrgdevicesWithPrismaOrgsSetParam,

	optional ...OrgdevicesSetParam,
) orgdevicesCreateOne {
	var v orgdevicesCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "orgdevices"
	v.query.Outputs = orgdevicesOutput

	var fields []builder.Field

	fields = append(fields, _orgdevicemeta.field())
	fields = append(fields, _updatedby.field())
	fields = append(fields, _devices.field())
	fields = append(fields, _orgs.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r orgdevicesCreateOne) With(params ...OrgdevicesRelationWith) orgdevicesCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type orgdevicesCreateOne struct {
	query builder.Query
}

func (p orgdevicesCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p orgdevicesCreateOne) orgdevicesModel() {}

func (r orgdevicesCreateOne) Exec(ctx context.Context) (*OrgdevicesModel, error) {
	var v OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesCreateOne) Tx() OrgdevicesUniqueTxResult {
	v := newOrgdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single orgrgroup.
func (r orgrgroupActions) CreateOne(
	_orgs OrgrgroupWithPrismaOrgsSetParam,
	_groups OrgrgroupWithPrismaGroupsSetParam,

	optional ...OrgrgroupSetParam,
) orgrgroupCreateOne {
	var v orgrgroupCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "orgrgroup"
	v.query.Outputs = orgrgroupOutput

	var fields []builder.Field

	fields = append(fields, _orgs.field())
	fields = append(fields, _groups.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r orgrgroupCreateOne) With(params ...OrgrgroupRelationWith) orgrgroupCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type orgrgroupCreateOne struct {
	query builder.Query
}

func (p orgrgroupCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p orgrgroupCreateOne) orgrgroupModel() {}

func (r orgrgroupCreateOne) Exec(ctx context.Context) (*OrgrgroupModel, error) {
	var v OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupCreateOne) Tx() OrgrgroupUniqueTxResult {
	v := newOrgrgroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single orgs.
func (r orgsActions) CreateOne(
	_orgid OrgsWithPrismaOrgidSetParam,
	_orgname OrgsWithPrismaOrgnameSetParam,
	_orgmeta OrgsWithPrismaOrgmetaSetParam,
	_createdby OrgsWithPrismaCreatedbySetParam,
	_updatedby OrgsWithPrismaUpdatedbySetParam,

	optional ...OrgsSetParam,
) orgsCreateOne {
	var v orgsCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "orgs"
	v.query.Outputs = orgsOutput

	var fields []builder.Field

	fields = append(fields, _orgid.field())
	fields = append(fields, _orgname.field())
	fields = append(fields, _orgmeta.field())
	fields = append(fields, _createdby.field())
	fields = append(fields, _updatedby.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r orgsCreateOne) With(params ...OrgsRelationWith) orgsCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type orgsCreateOne struct {
	query builder.Query
}

func (p orgsCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p orgsCreateOne) orgsModel() {}

func (r orgsCreateOne) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsCreateOne) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single usergroup.
func (r usergroupActions) CreateOne(
	_groups UsergroupWithPrismaGroupsSetParam,
	_orgs UsergroupWithPrismaOrgsSetParam,
	_users UsergroupWithPrismaUsersSetParam,

	optional ...UsergroupSetParam,
) usergroupCreateOne {
	var v usergroupCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "usergroup"
	v.query.Outputs = usergroupOutput

	var fields []builder.Field

	fields = append(fields, _groups.field())
	fields = append(fields, _orgs.field())
	fields = append(fields, _users.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r usergroupCreateOne) With(params ...UsergroupRelationWith) usergroupCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type usergroupCreateOne struct {
	query builder.Query
}

func (p usergroupCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p usergroupCreateOne) usergroupModel() {}

func (r usergroupCreateOne) Exec(ctx context.Context) (*UsergroupModel, error) {
	var v UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupCreateOne) Tx() UsergroupUniqueTxResult {
	v := newUsergroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// Creates a single users.
func (r usersActions) CreateOne(
	_userid UsersWithPrismaUseridSetParam,
	_name UsersWithPrismaNameSetParam,
	_email UsersWithPrismaEmailSetParam,
	_isemailverified UsersWithPrismaIsemailverifiedSetParam,
	_isenabled UsersWithPrismaIsenabledSetParam,
	_secretprv UsersWithPrismaSecretprvSetParam,
	_secretpub UsersWithPrismaSecretpubSetParam,
	_createdat UsersWithPrismaCreatedatSetParam,
	_updatedat UsersWithPrismaUpdatedatSetParam,

	optional ...UsersSetParam,
) usersCreateOne {
	var v usersCreateOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "createOne"
	v.query.Model = "users"
	v.query.Outputs = usersOutput

	var fields []builder.Field

	fields = append(fields, _userid.field())
	fields = append(fields, _name.field())
	fields = append(fields, _email.field())
	fields = append(fields, _isemailverified.field())
	fields = append(fields, _isenabled.field())
	fields = append(fields, _secretprv.field())
	fields = append(fields, _secretpub.field())
	fields = append(fields, _createdat.field())
	fields = append(fields, _updatedat.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

func (r usersCreateOne) With(params ...UsersRelationWith) usersCreateOne {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

type usersCreateOne struct {
	query builder.Query
}

func (p usersCreateOne) ExtractQuery() builder.Query {
	return p.query
}

func (p usersCreateOne) usersModel() {}

func (r usersCreateOne) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersCreateOne) Tx() UsersUniqueTxResult {
	v := newUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template find.gotpl ---

type activitylogFindUnique struct {
	query builder.Query
}

func (r activitylogFindUnique) getQuery() builder.Query {
	return r.query
}

func (r activitylogFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r activitylogFindUnique) with()                {}
func (r activitylogFindUnique) activitylogModel()    {}
func (r activitylogFindUnique) activitylogRelation() {}

func (r activitylogActions) FindUnique(
	params ActivitylogEqualsUniqueWhereParam,
) activitylogFindUnique {
	var v activitylogFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "activitylog"
	v.query.Outputs = activitylogOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r activitylogFindUnique) With(params ...ActivitylogRelationWith) activitylogFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r activitylogFindUnique) Select(params ...activitylogPrismaFields) activitylogFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r activitylogFindUnique) Omit(params ...activitylogPrismaFields) activitylogFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range activitylogOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r activitylogFindUnique) Exec(ctx context.Context) (
	*ActivitylogModel,
	error,
) {
	var v *ActivitylogModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r activitylogFindUnique) ExecInner(ctx context.Context) (
	*InnerActivitylog,
	error,
) {
	var v *InnerActivitylog
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r activitylogFindUnique) Update(params ...ActivitylogSetParam) activitylogUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "activitylog"

	var v activitylogUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type activitylogUpdateUnique struct {
	query builder.Query
}

func (r activitylogUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r activitylogUpdateUnique) activitylogModel() {}

func (r activitylogUpdateUnique) Exec(ctx context.Context) (*ActivitylogModel, error) {
	var v ActivitylogModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r activitylogUpdateUnique) Tx() ActivitylogUniqueTxResult {
	v := newActivitylogUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r activitylogFindUnique) Delete() activitylogDeleteUnique {
	var v activitylogDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "activitylog"

	return v
}

type activitylogDeleteUnique struct {
	query builder.Query
}

func (r activitylogDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p activitylogDeleteUnique) activitylogModel() {}

func (r activitylogDeleteUnique) Exec(ctx context.Context) (*ActivitylogModel, error) {
	var v ActivitylogModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r activitylogDeleteUnique) Tx() ActivitylogUniqueTxResult {
	v := newActivitylogUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type activitylogFindFirst struct {
	query builder.Query
}

func (r activitylogFindFirst) getQuery() builder.Query {
	return r.query
}

func (r activitylogFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r activitylogFindFirst) with()                {}
func (r activitylogFindFirst) activitylogModel()    {}
func (r activitylogFindFirst) activitylogRelation() {}

func (r activitylogActions) FindFirst(
	params ...ActivitylogWhereParam,
) activitylogFindFirst {
	var v activitylogFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "activitylog"
	v.query.Outputs = activitylogOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r activitylogFindFirst) With(params ...ActivitylogRelationWith) activitylogFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r activitylogFindFirst) Select(params ...activitylogPrismaFields) activitylogFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r activitylogFindFirst) Omit(params ...activitylogPrismaFields) activitylogFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range activitylogOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r activitylogFindFirst) OrderBy(params ...ActivitylogOrderByParam) activitylogFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r activitylogFindFirst) Skip(count int) activitylogFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r activitylogFindFirst) Take(count int) activitylogFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r activitylogFindFirst) Cursor(cursor ActivitylogCursorParam) activitylogFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r activitylogFindFirst) Exec(ctx context.Context) (
	*ActivitylogModel,
	error,
) {
	var v *ActivitylogModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r activitylogFindFirst) ExecInner(ctx context.Context) (
	*InnerActivitylog,
	error,
) {
	var v *InnerActivitylog
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type activitylogFindMany struct {
	query builder.Query
}

func (r activitylogFindMany) getQuery() builder.Query {
	return r.query
}

func (r activitylogFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r activitylogFindMany) with()                {}
func (r activitylogFindMany) activitylogModel()    {}
func (r activitylogFindMany) activitylogRelation() {}

func (r activitylogActions) FindMany(
	params ...ActivitylogWhereParam,
) activitylogFindMany {
	var v activitylogFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "activitylog"
	v.query.Outputs = activitylogOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r activitylogFindMany) With(params ...ActivitylogRelationWith) activitylogFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r activitylogFindMany) Select(params ...activitylogPrismaFields) activitylogFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r activitylogFindMany) Omit(params ...activitylogPrismaFields) activitylogFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range activitylogOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r activitylogFindMany) OrderBy(params ...ActivitylogOrderByParam) activitylogFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r activitylogFindMany) Skip(count int) activitylogFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r activitylogFindMany) Take(count int) activitylogFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r activitylogFindMany) Cursor(cursor ActivitylogCursorParam) activitylogFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r activitylogFindMany) Exec(ctx context.Context) (
	[]ActivitylogModel,
	error,
) {
	var v []ActivitylogModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r activitylogFindMany) ExecInner(ctx context.Context) (
	[]InnerActivitylog,
	error,
) {
	var v []InnerActivitylog
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r activitylogFindMany) Update(params ...ActivitylogSetParam) activitylogUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "activitylog"

	r.query.Outputs = countOutput

	var v activitylogUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type activitylogUpdateMany struct {
	query builder.Query
}

func (r activitylogUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r activitylogUpdateMany) activitylogModel() {}

func (r activitylogUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r activitylogUpdateMany) Tx() ActivitylogManyTxResult {
	v := newActivitylogManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r activitylogFindMany) Delete() activitylogDeleteMany {
	var v activitylogDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "activitylog"

	v.query.Outputs = countOutput

	return v
}

type activitylogDeleteMany struct {
	query builder.Query
}

func (r activitylogDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p activitylogDeleteMany) activitylogModel() {}

func (r activitylogDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r activitylogDeleteMany) Tx() ActivitylogManyTxResult {
	v := newActivitylogManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesToGroupdevicesFindUnique struct {
	query builder.Query
}

func (r devicesToGroupdevicesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r devicesToGroupdevicesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesToGroupdevicesFindUnique) with()            {}
func (r devicesToGroupdevicesFindUnique) devicesModel()    {}
func (r devicesToGroupdevicesFindUnique) devicesRelation() {}

func (r devicesToGroupdevicesFindUnique) With(params ...GroupdevicesRelationWith) devicesToGroupdevicesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesToGroupdevicesFindUnique) Select(params ...devicesPrismaFields) devicesToGroupdevicesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesToGroupdevicesFindUnique) Omit(params ...devicesPrismaFields) devicesToGroupdevicesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range devicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesToGroupdevicesFindUnique) Exec(ctx context.Context) (
	*DevicesModel,
	error,
) {
	var v *DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesToGroupdevicesFindUnique) ExecInner(ctx context.Context) (
	*InnerDevices,
	error,
) {
	var v *InnerDevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesToGroupdevicesFindUnique) Update(params ...DevicesSetParam) devicesToGroupdevicesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "devices"

	var v devicesToGroupdevicesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type devicesToGroupdevicesUpdateUnique struct {
	query builder.Query
}

func (r devicesToGroupdevicesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesToGroupdevicesUpdateUnique) devicesModel() {}

func (r devicesToGroupdevicesUpdateUnique) Exec(ctx context.Context) (*DevicesModel, error) {
	var v DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesToGroupdevicesUpdateUnique) Tx() DevicesUniqueTxResult {
	v := newDevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r devicesToGroupdevicesFindUnique) Delete() devicesToGroupdevicesDeleteUnique {
	var v devicesToGroupdevicesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "devices"

	return v
}

type devicesToGroupdevicesDeleteUnique struct {
	query builder.Query
}

func (r devicesToGroupdevicesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p devicesToGroupdevicesDeleteUnique) devicesModel() {}

func (r devicesToGroupdevicesDeleteUnique) Exec(ctx context.Context) (*DevicesModel, error) {
	var v DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesToGroupdevicesDeleteUnique) Tx() DevicesUniqueTxResult {
	v := newDevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesToGroupdevicesFindFirst struct {
	query builder.Query
}

func (r devicesToGroupdevicesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r devicesToGroupdevicesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesToGroupdevicesFindFirst) with()            {}
func (r devicesToGroupdevicesFindFirst) devicesModel()    {}
func (r devicesToGroupdevicesFindFirst) devicesRelation() {}

func (r devicesToGroupdevicesFindFirst) With(params ...GroupdevicesRelationWith) devicesToGroupdevicesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesToGroupdevicesFindFirst) Select(params ...devicesPrismaFields) devicesToGroupdevicesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesToGroupdevicesFindFirst) Omit(params ...devicesPrismaFields) devicesToGroupdevicesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range devicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesToGroupdevicesFindFirst) OrderBy(params ...GroupdevicesOrderByParam) devicesToGroupdevicesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r devicesToGroupdevicesFindFirst) Skip(count int) devicesToGroupdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r devicesToGroupdevicesFindFirst) Take(count int) devicesToGroupdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r devicesToGroupdevicesFindFirst) Cursor(cursor DevicesCursorParam) devicesToGroupdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r devicesToGroupdevicesFindFirst) Exec(ctx context.Context) (
	*DevicesModel,
	error,
) {
	var v *DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesToGroupdevicesFindFirst) ExecInner(ctx context.Context) (
	*InnerDevices,
	error,
) {
	var v *InnerDevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type devicesToGroupdevicesFindMany struct {
	query builder.Query
}

func (r devicesToGroupdevicesFindMany) getQuery() builder.Query {
	return r.query
}

func (r devicesToGroupdevicesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesToGroupdevicesFindMany) with()            {}
func (r devicesToGroupdevicesFindMany) devicesModel()    {}
func (r devicesToGroupdevicesFindMany) devicesRelation() {}

func (r devicesToGroupdevicesFindMany) With(params ...GroupdevicesRelationWith) devicesToGroupdevicesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesToGroupdevicesFindMany) Select(params ...devicesPrismaFields) devicesToGroupdevicesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesToGroupdevicesFindMany) Omit(params ...devicesPrismaFields) devicesToGroupdevicesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range devicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesToGroupdevicesFindMany) OrderBy(params ...GroupdevicesOrderByParam) devicesToGroupdevicesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r devicesToGroupdevicesFindMany) Skip(count int) devicesToGroupdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r devicesToGroupdevicesFindMany) Take(count int) devicesToGroupdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r devicesToGroupdevicesFindMany) Cursor(cursor DevicesCursorParam) devicesToGroupdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r devicesToGroupdevicesFindMany) Exec(ctx context.Context) (
	[]DevicesModel,
	error,
) {
	var v []DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r devicesToGroupdevicesFindMany) ExecInner(ctx context.Context) (
	[]InnerDevices,
	error,
) {
	var v []InnerDevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r devicesToGroupdevicesFindMany) Update(params ...DevicesSetParam) devicesToGroupdevicesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "devices"

	r.query.Outputs = countOutput

	var v devicesToGroupdevicesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type devicesToGroupdevicesUpdateMany struct {
	query builder.Query
}

func (r devicesToGroupdevicesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesToGroupdevicesUpdateMany) devicesModel() {}

func (r devicesToGroupdevicesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesToGroupdevicesUpdateMany) Tx() DevicesManyTxResult {
	v := newDevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r devicesToGroupdevicesFindMany) Delete() devicesToGroupdevicesDeleteMany {
	var v devicesToGroupdevicesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "devices"

	v.query.Outputs = countOutput

	return v
}

type devicesToGroupdevicesDeleteMany struct {
	query builder.Query
}

func (r devicesToGroupdevicesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p devicesToGroupdevicesDeleteMany) devicesModel() {}

func (r devicesToGroupdevicesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesToGroupdevicesDeleteMany) Tx() DevicesManyTxResult {
	v := newDevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesToOrgdevicesFindUnique struct {
	query builder.Query
}

func (r devicesToOrgdevicesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r devicesToOrgdevicesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesToOrgdevicesFindUnique) with()            {}
func (r devicesToOrgdevicesFindUnique) devicesModel()    {}
func (r devicesToOrgdevicesFindUnique) devicesRelation() {}

func (r devicesToOrgdevicesFindUnique) With(params ...OrgdevicesRelationWith) devicesToOrgdevicesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesToOrgdevicesFindUnique) Select(params ...devicesPrismaFields) devicesToOrgdevicesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesToOrgdevicesFindUnique) Omit(params ...devicesPrismaFields) devicesToOrgdevicesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range devicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesToOrgdevicesFindUnique) Exec(ctx context.Context) (
	*DevicesModel,
	error,
) {
	var v *DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesToOrgdevicesFindUnique) ExecInner(ctx context.Context) (
	*InnerDevices,
	error,
) {
	var v *InnerDevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesToOrgdevicesFindUnique) Update(params ...DevicesSetParam) devicesToOrgdevicesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "devices"

	var v devicesToOrgdevicesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type devicesToOrgdevicesUpdateUnique struct {
	query builder.Query
}

func (r devicesToOrgdevicesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesToOrgdevicesUpdateUnique) devicesModel() {}

func (r devicesToOrgdevicesUpdateUnique) Exec(ctx context.Context) (*DevicesModel, error) {
	var v DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesToOrgdevicesUpdateUnique) Tx() DevicesUniqueTxResult {
	v := newDevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r devicesToOrgdevicesFindUnique) Delete() devicesToOrgdevicesDeleteUnique {
	var v devicesToOrgdevicesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "devices"

	return v
}

type devicesToOrgdevicesDeleteUnique struct {
	query builder.Query
}

func (r devicesToOrgdevicesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p devicesToOrgdevicesDeleteUnique) devicesModel() {}

func (r devicesToOrgdevicesDeleteUnique) Exec(ctx context.Context) (*DevicesModel, error) {
	var v DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesToOrgdevicesDeleteUnique) Tx() DevicesUniqueTxResult {
	v := newDevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesToOrgdevicesFindFirst struct {
	query builder.Query
}

func (r devicesToOrgdevicesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r devicesToOrgdevicesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesToOrgdevicesFindFirst) with()            {}
func (r devicesToOrgdevicesFindFirst) devicesModel()    {}
func (r devicesToOrgdevicesFindFirst) devicesRelation() {}

func (r devicesToOrgdevicesFindFirst) With(params ...OrgdevicesRelationWith) devicesToOrgdevicesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesToOrgdevicesFindFirst) Select(params ...devicesPrismaFields) devicesToOrgdevicesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesToOrgdevicesFindFirst) Omit(params ...devicesPrismaFields) devicesToOrgdevicesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range devicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesToOrgdevicesFindFirst) OrderBy(params ...OrgdevicesOrderByParam) devicesToOrgdevicesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r devicesToOrgdevicesFindFirst) Skip(count int) devicesToOrgdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r devicesToOrgdevicesFindFirst) Take(count int) devicesToOrgdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r devicesToOrgdevicesFindFirst) Cursor(cursor DevicesCursorParam) devicesToOrgdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r devicesToOrgdevicesFindFirst) Exec(ctx context.Context) (
	*DevicesModel,
	error,
) {
	var v *DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesToOrgdevicesFindFirst) ExecInner(ctx context.Context) (
	*InnerDevices,
	error,
) {
	var v *InnerDevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type devicesToOrgdevicesFindMany struct {
	query builder.Query
}

func (r devicesToOrgdevicesFindMany) getQuery() builder.Query {
	return r.query
}

func (r devicesToOrgdevicesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesToOrgdevicesFindMany) with()            {}
func (r devicesToOrgdevicesFindMany) devicesModel()    {}
func (r devicesToOrgdevicesFindMany) devicesRelation() {}

func (r devicesToOrgdevicesFindMany) With(params ...OrgdevicesRelationWith) devicesToOrgdevicesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesToOrgdevicesFindMany) Select(params ...devicesPrismaFields) devicesToOrgdevicesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesToOrgdevicesFindMany) Omit(params ...devicesPrismaFields) devicesToOrgdevicesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range devicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesToOrgdevicesFindMany) OrderBy(params ...OrgdevicesOrderByParam) devicesToOrgdevicesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r devicesToOrgdevicesFindMany) Skip(count int) devicesToOrgdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r devicesToOrgdevicesFindMany) Take(count int) devicesToOrgdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r devicesToOrgdevicesFindMany) Cursor(cursor DevicesCursorParam) devicesToOrgdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r devicesToOrgdevicesFindMany) Exec(ctx context.Context) (
	[]DevicesModel,
	error,
) {
	var v []DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r devicesToOrgdevicesFindMany) ExecInner(ctx context.Context) (
	[]InnerDevices,
	error,
) {
	var v []InnerDevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r devicesToOrgdevicesFindMany) Update(params ...DevicesSetParam) devicesToOrgdevicesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "devices"

	r.query.Outputs = countOutput

	var v devicesToOrgdevicesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type devicesToOrgdevicesUpdateMany struct {
	query builder.Query
}

func (r devicesToOrgdevicesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesToOrgdevicesUpdateMany) devicesModel() {}

func (r devicesToOrgdevicesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesToOrgdevicesUpdateMany) Tx() DevicesManyTxResult {
	v := newDevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r devicesToOrgdevicesFindMany) Delete() devicesToOrgdevicesDeleteMany {
	var v devicesToOrgdevicesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "devices"

	v.query.Outputs = countOutput

	return v
}

type devicesToOrgdevicesDeleteMany struct {
	query builder.Query
}

func (r devicesToOrgdevicesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p devicesToOrgdevicesDeleteMany) devicesModel() {}

func (r devicesToOrgdevicesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesToOrgdevicesDeleteMany) Tx() DevicesManyTxResult {
	v := newDevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesFindUnique struct {
	query builder.Query
}

func (r devicesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r devicesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesFindUnique) with()            {}
func (r devicesFindUnique) devicesModel()    {}
func (r devicesFindUnique) devicesRelation() {}

func (r devicesActions) FindUnique(
	params DevicesEqualsUniqueWhereParam,
) devicesFindUnique {
	var v devicesFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "devices"
	v.query.Outputs = devicesOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r devicesFindUnique) With(params ...DevicesRelationWith) devicesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesFindUnique) Select(params ...devicesPrismaFields) devicesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesFindUnique) Omit(params ...devicesPrismaFields) devicesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range devicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesFindUnique) Exec(ctx context.Context) (
	*DevicesModel,
	error,
) {
	var v *DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesFindUnique) ExecInner(ctx context.Context) (
	*InnerDevices,
	error,
) {
	var v *InnerDevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesFindUnique) Update(params ...DevicesSetParam) devicesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "devices"

	var v devicesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type devicesUpdateUnique struct {
	query builder.Query
}

func (r devicesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesUpdateUnique) devicesModel() {}

func (r devicesUpdateUnique) Exec(ctx context.Context) (*DevicesModel, error) {
	var v DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesUpdateUnique) Tx() DevicesUniqueTxResult {
	v := newDevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r devicesFindUnique) Delete() devicesDeleteUnique {
	var v devicesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "devices"

	return v
}

type devicesDeleteUnique struct {
	query builder.Query
}

func (r devicesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p devicesDeleteUnique) devicesModel() {}

func (r devicesDeleteUnique) Exec(ctx context.Context) (*DevicesModel, error) {
	var v DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesDeleteUnique) Tx() DevicesUniqueTxResult {
	v := newDevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesFindFirst struct {
	query builder.Query
}

func (r devicesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r devicesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesFindFirst) with()            {}
func (r devicesFindFirst) devicesModel()    {}
func (r devicesFindFirst) devicesRelation() {}

func (r devicesActions) FindFirst(
	params ...DevicesWhereParam,
) devicesFindFirst {
	var v devicesFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "devices"
	v.query.Outputs = devicesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r devicesFindFirst) With(params ...DevicesRelationWith) devicesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesFindFirst) Select(params ...devicesPrismaFields) devicesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesFindFirst) Omit(params ...devicesPrismaFields) devicesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range devicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesFindFirst) OrderBy(params ...DevicesOrderByParam) devicesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r devicesFindFirst) Skip(count int) devicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r devicesFindFirst) Take(count int) devicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r devicesFindFirst) Cursor(cursor DevicesCursorParam) devicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r devicesFindFirst) Exec(ctx context.Context) (
	*DevicesModel,
	error,
) {
	var v *DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r devicesFindFirst) ExecInner(ctx context.Context) (
	*InnerDevices,
	error,
) {
	var v *InnerDevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type devicesFindMany struct {
	query builder.Query
}

func (r devicesFindMany) getQuery() builder.Query {
	return r.query
}

func (r devicesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesFindMany) with()            {}
func (r devicesFindMany) devicesModel()    {}
func (r devicesFindMany) devicesRelation() {}

func (r devicesActions) FindMany(
	params ...DevicesWhereParam,
) devicesFindMany {
	var v devicesFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "devices"
	v.query.Outputs = devicesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r devicesFindMany) With(params ...DevicesRelationWith) devicesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r devicesFindMany) Select(params ...devicesPrismaFields) devicesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesFindMany) Omit(params ...devicesPrismaFields) devicesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range devicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r devicesFindMany) OrderBy(params ...DevicesOrderByParam) devicesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r devicesFindMany) Skip(count int) devicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r devicesFindMany) Take(count int) devicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r devicesFindMany) Cursor(cursor DevicesCursorParam) devicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r devicesFindMany) Exec(ctx context.Context) (
	[]DevicesModel,
	error,
) {
	var v []DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r devicesFindMany) ExecInner(ctx context.Context) (
	[]InnerDevices,
	error,
) {
	var v []InnerDevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r devicesFindMany) Update(params ...DevicesSetParam) devicesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "devices"

	r.query.Outputs = countOutput

	var v devicesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type devicesUpdateMany struct {
	query builder.Query
}

func (r devicesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesUpdateMany) devicesModel() {}

func (r devicesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesUpdateMany) Tx() DevicesManyTxResult {
	v := newDevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r devicesFindMany) Delete() devicesDeleteMany {
	var v devicesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "devices"

	v.query.Outputs = countOutput

	return v
}

type devicesDeleteMany struct {
	query builder.Query
}

func (r devicesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p devicesDeleteMany) devicesModel() {}

func (r devicesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesDeleteMany) Tx() DevicesManyTxResult {
	v := newDevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupdevicesToDevicesFindUnique struct {
	query builder.Query
}

func (r groupdevicesToDevicesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesToDevicesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToDevicesFindUnique) with()                 {}
func (r groupdevicesToDevicesFindUnique) groupdevicesModel()    {}
func (r groupdevicesToDevicesFindUnique) groupdevicesRelation() {}

func (r groupdevicesToDevicesFindUnique) With(params ...DevicesRelationWith) groupdevicesToDevicesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupdevicesToDevicesFindUnique) Select(params ...groupdevicesPrismaFields) groupdevicesToDevicesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToDevicesFindUnique) Omit(params ...groupdevicesPrismaFields) groupdevicesToDevicesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToDevicesFindUnique) Exec(ctx context.Context) (
	*GroupdevicesModel,
	error,
) {
	var v *GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupdevicesToDevicesFindUnique) ExecInner(ctx context.Context) (
	*InnerGroupdevices,
	error,
) {
	var v *InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupdevicesToDevicesFindUnique) Update(params ...GroupdevicesSetParam) groupdevicesToDevicesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groupdevices"

	var v groupdevicesToDevicesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupdevicesToDevicesUpdateUnique struct {
	query builder.Query
}

func (r groupdevicesToDevicesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToDevicesUpdateUnique) groupdevicesModel() {}

func (r groupdevicesToDevicesUpdateUnique) Exec(ctx context.Context) (*GroupdevicesModel, error) {
	var v GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesToDevicesUpdateUnique) Tx() GroupdevicesUniqueTxResult {
	v := newGroupdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupdevicesToDevicesFindUnique) Delete() groupdevicesToDevicesDeleteUnique {
	var v groupdevicesToDevicesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groupdevices"

	return v
}

type groupdevicesToDevicesDeleteUnique struct {
	query builder.Query
}

func (r groupdevicesToDevicesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupdevicesToDevicesDeleteUnique) groupdevicesModel() {}

func (r groupdevicesToDevicesDeleteUnique) Exec(ctx context.Context) (*GroupdevicesModel, error) {
	var v GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesToDevicesDeleteUnique) Tx() GroupdevicesUniqueTxResult {
	v := newGroupdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupdevicesToDevicesFindFirst struct {
	query builder.Query
}

func (r groupdevicesToDevicesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesToDevicesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToDevicesFindFirst) with()                 {}
func (r groupdevicesToDevicesFindFirst) groupdevicesModel()    {}
func (r groupdevicesToDevicesFindFirst) groupdevicesRelation() {}

func (r groupdevicesToDevicesFindFirst) With(params ...DevicesRelationWith) groupdevicesToDevicesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupdevicesToDevicesFindFirst) Select(params ...groupdevicesPrismaFields) groupdevicesToDevicesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToDevicesFindFirst) Omit(params ...groupdevicesPrismaFields) groupdevicesToDevicesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToDevicesFindFirst) OrderBy(params ...DevicesOrderByParam) groupdevicesToDevicesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupdevicesToDevicesFindFirst) Skip(count int) groupdevicesToDevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupdevicesToDevicesFindFirst) Take(count int) groupdevicesToDevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupdevicesToDevicesFindFirst) Cursor(cursor GroupdevicesCursorParam) groupdevicesToDevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupdevicesToDevicesFindFirst) Exec(ctx context.Context) (
	*GroupdevicesModel,
	error,
) {
	var v *GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupdevicesToDevicesFindFirst) ExecInner(ctx context.Context) (
	*InnerGroupdevices,
	error,
) {
	var v *InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupdevicesToDevicesFindMany struct {
	query builder.Query
}

func (r groupdevicesToDevicesFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesToDevicesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToDevicesFindMany) with()                 {}
func (r groupdevicesToDevicesFindMany) groupdevicesModel()    {}
func (r groupdevicesToDevicesFindMany) groupdevicesRelation() {}

func (r groupdevicesToDevicesFindMany) With(params ...DevicesRelationWith) groupdevicesToDevicesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupdevicesToDevicesFindMany) Select(params ...groupdevicesPrismaFields) groupdevicesToDevicesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToDevicesFindMany) Omit(params ...groupdevicesPrismaFields) groupdevicesToDevicesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToDevicesFindMany) OrderBy(params ...DevicesOrderByParam) groupdevicesToDevicesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupdevicesToDevicesFindMany) Skip(count int) groupdevicesToDevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupdevicesToDevicesFindMany) Take(count int) groupdevicesToDevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupdevicesToDevicesFindMany) Cursor(cursor GroupdevicesCursorParam) groupdevicesToDevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupdevicesToDevicesFindMany) Exec(ctx context.Context) (
	[]GroupdevicesModel,
	error,
) {
	var v []GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupdevicesToDevicesFindMany) ExecInner(ctx context.Context) (
	[]InnerGroupdevices,
	error,
) {
	var v []InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupdevicesToDevicesFindMany) Update(params ...GroupdevicesSetParam) groupdevicesToDevicesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groupdevices"

	r.query.Outputs = countOutput

	var v groupdevicesToDevicesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupdevicesToDevicesUpdateMany struct {
	query builder.Query
}

func (r groupdevicesToDevicesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToDevicesUpdateMany) groupdevicesModel() {}

func (r groupdevicesToDevicesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesToDevicesUpdateMany) Tx() GroupdevicesManyTxResult {
	v := newGroupdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupdevicesToDevicesFindMany) Delete() groupdevicesToDevicesDeleteMany {
	var v groupdevicesToDevicesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groupdevices"

	v.query.Outputs = countOutput

	return v
}

type groupdevicesToDevicesDeleteMany struct {
	query builder.Query
}

func (r groupdevicesToDevicesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupdevicesToDevicesDeleteMany) groupdevicesModel() {}

func (r groupdevicesToDevicesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesToDevicesDeleteMany) Tx() GroupdevicesManyTxResult {
	v := newGroupdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupdevicesToGroupsFindUnique struct {
	query builder.Query
}

func (r groupdevicesToGroupsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesToGroupsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToGroupsFindUnique) with()                 {}
func (r groupdevicesToGroupsFindUnique) groupdevicesModel()    {}
func (r groupdevicesToGroupsFindUnique) groupdevicesRelation() {}

func (r groupdevicesToGroupsFindUnique) With(params ...GroupsRelationWith) groupdevicesToGroupsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupdevicesToGroupsFindUnique) Select(params ...groupdevicesPrismaFields) groupdevicesToGroupsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToGroupsFindUnique) Omit(params ...groupdevicesPrismaFields) groupdevicesToGroupsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToGroupsFindUnique) Exec(ctx context.Context) (
	*GroupdevicesModel,
	error,
) {
	var v *GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupdevicesToGroupsFindUnique) ExecInner(ctx context.Context) (
	*InnerGroupdevices,
	error,
) {
	var v *InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupdevicesToGroupsFindUnique) Update(params ...GroupdevicesSetParam) groupdevicesToGroupsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groupdevices"

	var v groupdevicesToGroupsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupdevicesToGroupsUpdateUnique struct {
	query builder.Query
}

func (r groupdevicesToGroupsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToGroupsUpdateUnique) groupdevicesModel() {}

func (r groupdevicesToGroupsUpdateUnique) Exec(ctx context.Context) (*GroupdevicesModel, error) {
	var v GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesToGroupsUpdateUnique) Tx() GroupdevicesUniqueTxResult {
	v := newGroupdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupdevicesToGroupsFindUnique) Delete() groupdevicesToGroupsDeleteUnique {
	var v groupdevicesToGroupsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groupdevices"

	return v
}

type groupdevicesToGroupsDeleteUnique struct {
	query builder.Query
}

func (r groupdevicesToGroupsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupdevicesToGroupsDeleteUnique) groupdevicesModel() {}

func (r groupdevicesToGroupsDeleteUnique) Exec(ctx context.Context) (*GroupdevicesModel, error) {
	var v GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesToGroupsDeleteUnique) Tx() GroupdevicesUniqueTxResult {
	v := newGroupdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupdevicesToGroupsFindFirst struct {
	query builder.Query
}

func (r groupdevicesToGroupsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesToGroupsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToGroupsFindFirst) with()                 {}
func (r groupdevicesToGroupsFindFirst) groupdevicesModel()    {}
func (r groupdevicesToGroupsFindFirst) groupdevicesRelation() {}

func (r groupdevicesToGroupsFindFirst) With(params ...GroupsRelationWith) groupdevicesToGroupsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupdevicesToGroupsFindFirst) Select(params ...groupdevicesPrismaFields) groupdevicesToGroupsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToGroupsFindFirst) Omit(params ...groupdevicesPrismaFields) groupdevicesToGroupsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToGroupsFindFirst) OrderBy(params ...GroupsOrderByParam) groupdevicesToGroupsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupdevicesToGroupsFindFirst) Skip(count int) groupdevicesToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupdevicesToGroupsFindFirst) Take(count int) groupdevicesToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupdevicesToGroupsFindFirst) Cursor(cursor GroupdevicesCursorParam) groupdevicesToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupdevicesToGroupsFindFirst) Exec(ctx context.Context) (
	*GroupdevicesModel,
	error,
) {
	var v *GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupdevicesToGroupsFindFirst) ExecInner(ctx context.Context) (
	*InnerGroupdevices,
	error,
) {
	var v *InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupdevicesToGroupsFindMany struct {
	query builder.Query
}

func (r groupdevicesToGroupsFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesToGroupsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToGroupsFindMany) with()                 {}
func (r groupdevicesToGroupsFindMany) groupdevicesModel()    {}
func (r groupdevicesToGroupsFindMany) groupdevicesRelation() {}

func (r groupdevicesToGroupsFindMany) With(params ...GroupsRelationWith) groupdevicesToGroupsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupdevicesToGroupsFindMany) Select(params ...groupdevicesPrismaFields) groupdevicesToGroupsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToGroupsFindMany) Omit(params ...groupdevicesPrismaFields) groupdevicesToGroupsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToGroupsFindMany) OrderBy(params ...GroupsOrderByParam) groupdevicesToGroupsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupdevicesToGroupsFindMany) Skip(count int) groupdevicesToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupdevicesToGroupsFindMany) Take(count int) groupdevicesToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupdevicesToGroupsFindMany) Cursor(cursor GroupdevicesCursorParam) groupdevicesToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupdevicesToGroupsFindMany) Exec(ctx context.Context) (
	[]GroupdevicesModel,
	error,
) {
	var v []GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupdevicesToGroupsFindMany) ExecInner(ctx context.Context) (
	[]InnerGroupdevices,
	error,
) {
	var v []InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupdevicesToGroupsFindMany) Update(params ...GroupdevicesSetParam) groupdevicesToGroupsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groupdevices"

	r.query.Outputs = countOutput

	var v groupdevicesToGroupsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupdevicesToGroupsUpdateMany struct {
	query builder.Query
}

func (r groupdevicesToGroupsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToGroupsUpdateMany) groupdevicesModel() {}

func (r groupdevicesToGroupsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesToGroupsUpdateMany) Tx() GroupdevicesManyTxResult {
	v := newGroupdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupdevicesToGroupsFindMany) Delete() groupdevicesToGroupsDeleteMany {
	var v groupdevicesToGroupsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groupdevices"

	v.query.Outputs = countOutput

	return v
}

type groupdevicesToGroupsDeleteMany struct {
	query builder.Query
}

func (r groupdevicesToGroupsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupdevicesToGroupsDeleteMany) groupdevicesModel() {}

func (r groupdevicesToGroupsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesToGroupsDeleteMany) Tx() GroupdevicesManyTxResult {
	v := newGroupdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupdevicesToOrgsFindUnique struct {
	query builder.Query
}

func (r groupdevicesToOrgsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesToOrgsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToOrgsFindUnique) with()                 {}
func (r groupdevicesToOrgsFindUnique) groupdevicesModel()    {}
func (r groupdevicesToOrgsFindUnique) groupdevicesRelation() {}

func (r groupdevicesToOrgsFindUnique) With(params ...OrgsRelationWith) groupdevicesToOrgsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupdevicesToOrgsFindUnique) Select(params ...groupdevicesPrismaFields) groupdevicesToOrgsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToOrgsFindUnique) Omit(params ...groupdevicesPrismaFields) groupdevicesToOrgsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToOrgsFindUnique) Exec(ctx context.Context) (
	*GroupdevicesModel,
	error,
) {
	var v *GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupdevicesToOrgsFindUnique) ExecInner(ctx context.Context) (
	*InnerGroupdevices,
	error,
) {
	var v *InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupdevicesToOrgsFindUnique) Update(params ...GroupdevicesSetParam) groupdevicesToOrgsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groupdevices"

	var v groupdevicesToOrgsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupdevicesToOrgsUpdateUnique struct {
	query builder.Query
}

func (r groupdevicesToOrgsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToOrgsUpdateUnique) groupdevicesModel() {}

func (r groupdevicesToOrgsUpdateUnique) Exec(ctx context.Context) (*GroupdevicesModel, error) {
	var v GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesToOrgsUpdateUnique) Tx() GroupdevicesUniqueTxResult {
	v := newGroupdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupdevicesToOrgsFindUnique) Delete() groupdevicesToOrgsDeleteUnique {
	var v groupdevicesToOrgsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groupdevices"

	return v
}

type groupdevicesToOrgsDeleteUnique struct {
	query builder.Query
}

func (r groupdevicesToOrgsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupdevicesToOrgsDeleteUnique) groupdevicesModel() {}

func (r groupdevicesToOrgsDeleteUnique) Exec(ctx context.Context) (*GroupdevicesModel, error) {
	var v GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesToOrgsDeleteUnique) Tx() GroupdevicesUniqueTxResult {
	v := newGroupdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupdevicesToOrgsFindFirst struct {
	query builder.Query
}

func (r groupdevicesToOrgsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesToOrgsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToOrgsFindFirst) with()                 {}
func (r groupdevicesToOrgsFindFirst) groupdevicesModel()    {}
func (r groupdevicesToOrgsFindFirst) groupdevicesRelation() {}

func (r groupdevicesToOrgsFindFirst) With(params ...OrgsRelationWith) groupdevicesToOrgsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupdevicesToOrgsFindFirst) Select(params ...groupdevicesPrismaFields) groupdevicesToOrgsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToOrgsFindFirst) Omit(params ...groupdevicesPrismaFields) groupdevicesToOrgsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToOrgsFindFirst) OrderBy(params ...OrgsOrderByParam) groupdevicesToOrgsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupdevicesToOrgsFindFirst) Skip(count int) groupdevicesToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupdevicesToOrgsFindFirst) Take(count int) groupdevicesToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupdevicesToOrgsFindFirst) Cursor(cursor GroupdevicesCursorParam) groupdevicesToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupdevicesToOrgsFindFirst) Exec(ctx context.Context) (
	*GroupdevicesModel,
	error,
) {
	var v *GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupdevicesToOrgsFindFirst) ExecInner(ctx context.Context) (
	*InnerGroupdevices,
	error,
) {
	var v *InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupdevicesToOrgsFindMany struct {
	query builder.Query
}

func (r groupdevicesToOrgsFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesToOrgsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToOrgsFindMany) with()                 {}
func (r groupdevicesToOrgsFindMany) groupdevicesModel()    {}
func (r groupdevicesToOrgsFindMany) groupdevicesRelation() {}

func (r groupdevicesToOrgsFindMany) With(params ...OrgsRelationWith) groupdevicesToOrgsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupdevicesToOrgsFindMany) Select(params ...groupdevicesPrismaFields) groupdevicesToOrgsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToOrgsFindMany) Omit(params ...groupdevicesPrismaFields) groupdevicesToOrgsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesToOrgsFindMany) OrderBy(params ...OrgsOrderByParam) groupdevicesToOrgsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupdevicesToOrgsFindMany) Skip(count int) groupdevicesToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupdevicesToOrgsFindMany) Take(count int) groupdevicesToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupdevicesToOrgsFindMany) Cursor(cursor GroupdevicesCursorParam) groupdevicesToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupdevicesToOrgsFindMany) Exec(ctx context.Context) (
	[]GroupdevicesModel,
	error,
) {
	var v []GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupdevicesToOrgsFindMany) ExecInner(ctx context.Context) (
	[]InnerGroupdevices,
	error,
) {
	var v []InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupdevicesToOrgsFindMany) Update(params ...GroupdevicesSetParam) groupdevicesToOrgsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groupdevices"

	r.query.Outputs = countOutput

	var v groupdevicesToOrgsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupdevicesToOrgsUpdateMany struct {
	query builder.Query
}

func (r groupdevicesToOrgsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesToOrgsUpdateMany) groupdevicesModel() {}

func (r groupdevicesToOrgsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesToOrgsUpdateMany) Tx() GroupdevicesManyTxResult {
	v := newGroupdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupdevicesToOrgsFindMany) Delete() groupdevicesToOrgsDeleteMany {
	var v groupdevicesToOrgsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groupdevices"

	v.query.Outputs = countOutput

	return v
}

type groupdevicesToOrgsDeleteMany struct {
	query builder.Query
}

func (r groupdevicesToOrgsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupdevicesToOrgsDeleteMany) groupdevicesModel() {}

func (r groupdevicesToOrgsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesToOrgsDeleteMany) Tx() GroupdevicesManyTxResult {
	v := newGroupdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupdevicesFindUnique struct {
	query builder.Query
}

func (r groupdevicesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesFindUnique) with()                 {}
func (r groupdevicesFindUnique) groupdevicesModel()    {}
func (r groupdevicesFindUnique) groupdevicesRelation() {}

func (r groupdevicesActions) FindUnique(
	params GroupdevicesEqualsUniqueWhereParam,
) groupdevicesFindUnique {
	var v groupdevicesFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "groupdevices"
	v.query.Outputs = groupdevicesOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r groupdevicesFindUnique) With(params ...GroupdevicesRelationWith) groupdevicesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupdevicesFindUnique) Select(params ...groupdevicesPrismaFields) groupdevicesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesFindUnique) Omit(params ...groupdevicesPrismaFields) groupdevicesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesFindUnique) Exec(ctx context.Context) (
	*GroupdevicesModel,
	error,
) {
	var v *GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupdevicesFindUnique) ExecInner(ctx context.Context) (
	*InnerGroupdevices,
	error,
) {
	var v *InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupdevicesFindUnique) Update(params ...GroupdevicesSetParam) groupdevicesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groupdevices"

	var v groupdevicesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupdevicesUpdateUnique struct {
	query builder.Query
}

func (r groupdevicesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesUpdateUnique) groupdevicesModel() {}

func (r groupdevicesUpdateUnique) Exec(ctx context.Context) (*GroupdevicesModel, error) {
	var v GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesUpdateUnique) Tx() GroupdevicesUniqueTxResult {
	v := newGroupdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupdevicesFindUnique) Delete() groupdevicesDeleteUnique {
	var v groupdevicesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groupdevices"

	return v
}

type groupdevicesDeleteUnique struct {
	query builder.Query
}

func (r groupdevicesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupdevicesDeleteUnique) groupdevicesModel() {}

func (r groupdevicesDeleteUnique) Exec(ctx context.Context) (*GroupdevicesModel, error) {
	var v GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesDeleteUnique) Tx() GroupdevicesUniqueTxResult {
	v := newGroupdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupdevicesFindFirst struct {
	query builder.Query
}

func (r groupdevicesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesFindFirst) with()                 {}
func (r groupdevicesFindFirst) groupdevicesModel()    {}
func (r groupdevicesFindFirst) groupdevicesRelation() {}

func (r groupdevicesActions) FindFirst(
	params ...GroupdevicesWhereParam,
) groupdevicesFindFirst {
	var v groupdevicesFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "groupdevices"
	v.query.Outputs = groupdevicesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r groupdevicesFindFirst) With(params ...GroupdevicesRelationWith) groupdevicesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupdevicesFindFirst) Select(params ...groupdevicesPrismaFields) groupdevicesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesFindFirst) Omit(params ...groupdevicesPrismaFields) groupdevicesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesFindFirst) OrderBy(params ...GroupdevicesOrderByParam) groupdevicesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupdevicesFindFirst) Skip(count int) groupdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupdevicesFindFirst) Take(count int) groupdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupdevicesFindFirst) Cursor(cursor GroupdevicesCursorParam) groupdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupdevicesFindFirst) Exec(ctx context.Context) (
	*GroupdevicesModel,
	error,
) {
	var v *GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupdevicesFindFirst) ExecInner(ctx context.Context) (
	*InnerGroupdevices,
	error,
) {
	var v *InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupdevicesFindMany struct {
	query builder.Query
}

func (r groupdevicesFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesFindMany) with()                 {}
func (r groupdevicesFindMany) groupdevicesModel()    {}
func (r groupdevicesFindMany) groupdevicesRelation() {}

func (r groupdevicesActions) FindMany(
	params ...GroupdevicesWhereParam,
) groupdevicesFindMany {
	var v groupdevicesFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "groupdevices"
	v.query.Outputs = groupdevicesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r groupdevicesFindMany) With(params ...GroupdevicesRelationWith) groupdevicesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupdevicesFindMany) Select(params ...groupdevicesPrismaFields) groupdevicesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesFindMany) Omit(params ...groupdevicesPrismaFields) groupdevicesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupdevicesFindMany) OrderBy(params ...GroupdevicesOrderByParam) groupdevicesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupdevicesFindMany) Skip(count int) groupdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupdevicesFindMany) Take(count int) groupdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupdevicesFindMany) Cursor(cursor GroupdevicesCursorParam) groupdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupdevicesFindMany) Exec(ctx context.Context) (
	[]GroupdevicesModel,
	error,
) {
	var v []GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupdevicesFindMany) ExecInner(ctx context.Context) (
	[]InnerGroupdevices,
	error,
) {
	var v []InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupdevicesFindMany) Update(params ...GroupdevicesSetParam) groupdevicesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groupdevices"

	r.query.Outputs = countOutput

	var v groupdevicesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupdevicesUpdateMany struct {
	query builder.Query
}

func (r groupdevicesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesUpdateMany) groupdevicesModel() {}

func (r groupdevicesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesUpdateMany) Tx() GroupdevicesManyTxResult {
	v := newGroupdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupdevicesFindMany) Delete() groupdevicesDeleteMany {
	var v groupdevicesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groupdevices"

	v.query.Outputs = countOutput

	return v
}

type groupdevicesDeleteMany struct {
	query builder.Query
}

func (r groupdevicesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupdevicesDeleteMany) groupdevicesModel() {}

func (r groupdevicesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesDeleteMany) Tx() GroupdevicesManyTxResult {
	v := newGroupdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToGroupdevicesFindUnique struct {
	query builder.Query
}

func (r groupsToGroupdevicesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupsToGroupdevicesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGroupdevicesFindUnique) with()           {}
func (r groupsToGroupdevicesFindUnique) groupsModel()    {}
func (r groupsToGroupdevicesFindUnique) groupsRelation() {}

func (r groupsToGroupdevicesFindUnique) With(params ...GroupdevicesRelationWith) groupsToGroupdevicesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToGroupdevicesFindUnique) Select(params ...groupsPrismaFields) groupsToGroupdevicesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGroupdevicesFindUnique) Omit(params ...groupsPrismaFields) groupsToGroupdevicesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGroupdevicesFindUnique) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToGroupdevicesFindUnique) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToGroupdevicesFindUnique) Update(params ...GroupsSetParam) groupsToGroupdevicesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groups"

	var v groupsToGroupdevicesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToGroupdevicesUpdateUnique struct {
	query builder.Query
}

func (r groupsToGroupdevicesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGroupdevicesUpdateUnique) groupsModel() {}

func (r groupsToGroupdevicesUpdateUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGroupdevicesUpdateUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToGroupdevicesFindUnique) Delete() groupsToGroupdevicesDeleteUnique {
	var v groupsToGroupdevicesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groups"

	return v
}

type groupsToGroupdevicesDeleteUnique struct {
	query builder.Query
}

func (r groupsToGroupdevicesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToGroupdevicesDeleteUnique) groupsModel() {}

func (r groupsToGroupdevicesDeleteUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGroupdevicesDeleteUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToGroupdevicesFindFirst struct {
	query builder.Query
}

func (r groupsToGroupdevicesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupsToGroupdevicesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGroupdevicesFindFirst) with()           {}
func (r groupsToGroupdevicesFindFirst) groupsModel()    {}
func (r groupsToGroupdevicesFindFirst) groupsRelation() {}

func (r groupsToGroupdevicesFindFirst) With(params ...GroupdevicesRelationWith) groupsToGroupdevicesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToGroupdevicesFindFirst) Select(params ...groupsPrismaFields) groupsToGroupdevicesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGroupdevicesFindFirst) Omit(params ...groupsPrismaFields) groupsToGroupdevicesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGroupdevicesFindFirst) OrderBy(params ...GroupdevicesOrderByParam) groupsToGroupdevicesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToGroupdevicesFindFirst) Skip(count int) groupsToGroupdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToGroupdevicesFindFirst) Take(count int) groupsToGroupdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToGroupdevicesFindFirst) Cursor(cursor GroupsCursorParam) groupsToGroupdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToGroupdevicesFindFirst) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToGroupdevicesFindFirst) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupsToGroupdevicesFindMany struct {
	query builder.Query
}

func (r groupsToGroupdevicesFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupsToGroupdevicesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGroupdevicesFindMany) with()           {}
func (r groupsToGroupdevicesFindMany) groupsModel()    {}
func (r groupsToGroupdevicesFindMany) groupsRelation() {}

func (r groupsToGroupdevicesFindMany) With(params ...GroupdevicesRelationWith) groupsToGroupdevicesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToGroupdevicesFindMany) Select(params ...groupsPrismaFields) groupsToGroupdevicesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGroupdevicesFindMany) Omit(params ...groupsPrismaFields) groupsToGroupdevicesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGroupdevicesFindMany) OrderBy(params ...GroupdevicesOrderByParam) groupsToGroupdevicesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToGroupdevicesFindMany) Skip(count int) groupsToGroupdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToGroupdevicesFindMany) Take(count int) groupsToGroupdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToGroupdevicesFindMany) Cursor(cursor GroupsCursorParam) groupsToGroupdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToGroupdevicesFindMany) Exec(ctx context.Context) (
	[]GroupsModel,
	error,
) {
	var v []GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToGroupdevicesFindMany) ExecInner(ctx context.Context) (
	[]InnerGroups,
	error,
) {
	var v []InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToGroupdevicesFindMany) Update(params ...GroupsSetParam) groupsToGroupdevicesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groups"

	r.query.Outputs = countOutput

	var v groupsToGroupdevicesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToGroupdevicesUpdateMany struct {
	query builder.Query
}

func (r groupsToGroupdevicesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGroupdevicesUpdateMany) groupsModel() {}

func (r groupsToGroupdevicesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGroupdevicesUpdateMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToGroupdevicesFindMany) Delete() groupsToGroupdevicesDeleteMany {
	var v groupsToGroupdevicesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groups"

	v.query.Outputs = countOutput

	return v
}

type groupsToGroupdevicesDeleteMany struct {
	query builder.Query
}

func (r groupsToGroupdevicesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToGroupdevicesDeleteMany) groupsModel() {}

func (r groupsToGroupdevicesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGroupdevicesDeleteMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToOrgsFindUnique struct {
	query builder.Query
}

func (r groupsToOrgsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupsToOrgsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToOrgsFindUnique) with()           {}
func (r groupsToOrgsFindUnique) groupsModel()    {}
func (r groupsToOrgsFindUnique) groupsRelation() {}

func (r groupsToOrgsFindUnique) With(params ...OrgsRelationWith) groupsToOrgsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToOrgsFindUnique) Select(params ...groupsPrismaFields) groupsToOrgsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToOrgsFindUnique) Omit(params ...groupsPrismaFields) groupsToOrgsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToOrgsFindUnique) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToOrgsFindUnique) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToOrgsFindUnique) Update(params ...GroupsSetParam) groupsToOrgsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groups"

	var v groupsToOrgsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToOrgsUpdateUnique struct {
	query builder.Query
}

func (r groupsToOrgsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToOrgsUpdateUnique) groupsModel() {}

func (r groupsToOrgsUpdateUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToOrgsUpdateUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToOrgsFindUnique) Delete() groupsToOrgsDeleteUnique {
	var v groupsToOrgsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groups"

	return v
}

type groupsToOrgsDeleteUnique struct {
	query builder.Query
}

func (r groupsToOrgsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToOrgsDeleteUnique) groupsModel() {}

func (r groupsToOrgsDeleteUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToOrgsDeleteUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToOrgsFindFirst struct {
	query builder.Query
}

func (r groupsToOrgsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupsToOrgsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToOrgsFindFirst) with()           {}
func (r groupsToOrgsFindFirst) groupsModel()    {}
func (r groupsToOrgsFindFirst) groupsRelation() {}

func (r groupsToOrgsFindFirst) With(params ...OrgsRelationWith) groupsToOrgsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToOrgsFindFirst) Select(params ...groupsPrismaFields) groupsToOrgsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToOrgsFindFirst) Omit(params ...groupsPrismaFields) groupsToOrgsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToOrgsFindFirst) OrderBy(params ...OrgsOrderByParam) groupsToOrgsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToOrgsFindFirst) Skip(count int) groupsToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToOrgsFindFirst) Take(count int) groupsToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToOrgsFindFirst) Cursor(cursor GroupsCursorParam) groupsToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToOrgsFindFirst) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToOrgsFindFirst) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupsToOrgsFindMany struct {
	query builder.Query
}

func (r groupsToOrgsFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupsToOrgsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToOrgsFindMany) with()           {}
func (r groupsToOrgsFindMany) groupsModel()    {}
func (r groupsToOrgsFindMany) groupsRelation() {}

func (r groupsToOrgsFindMany) With(params ...OrgsRelationWith) groupsToOrgsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToOrgsFindMany) Select(params ...groupsPrismaFields) groupsToOrgsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToOrgsFindMany) Omit(params ...groupsPrismaFields) groupsToOrgsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToOrgsFindMany) OrderBy(params ...OrgsOrderByParam) groupsToOrgsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToOrgsFindMany) Skip(count int) groupsToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToOrgsFindMany) Take(count int) groupsToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToOrgsFindMany) Cursor(cursor GroupsCursorParam) groupsToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToOrgsFindMany) Exec(ctx context.Context) (
	[]GroupsModel,
	error,
) {
	var v []GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToOrgsFindMany) ExecInner(ctx context.Context) (
	[]InnerGroups,
	error,
) {
	var v []InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToOrgsFindMany) Update(params ...GroupsSetParam) groupsToOrgsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groups"

	r.query.Outputs = countOutput

	var v groupsToOrgsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToOrgsUpdateMany struct {
	query builder.Query
}

func (r groupsToOrgsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToOrgsUpdateMany) groupsModel() {}

func (r groupsToOrgsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToOrgsUpdateMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToOrgsFindMany) Delete() groupsToOrgsDeleteMany {
	var v groupsToOrgsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groups"

	v.query.Outputs = countOutput

	return v
}

type groupsToOrgsDeleteMany struct {
	query builder.Query
}

func (r groupsToOrgsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToOrgsDeleteMany) groupsModel() {}

func (r groupsToOrgsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToOrgsDeleteMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique) with()           {}
func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique) groupsModel()    {}
func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique) groupsRelation() {}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique) With(params ...GrouptreeRelationWith) groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique) Select(params ...groupsPrismaFields) groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique) Omit(params ...groupsPrismaFields) groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique) Update(params ...GroupsSetParam) groupsToGrouptreeGrouptreeGroupidTogroupsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groups"

	var v groupsToGrouptreeGrouptreeGroupidTogroupsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToGrouptreeGrouptreeGroupidTogroupsUpdateUnique struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsUpdateUnique) groupsModel() {}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsUpdateUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsUpdateUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindUnique) Delete() groupsToGrouptreeGrouptreeGroupidTogroupsDeleteUnique {
	var v groupsToGrouptreeGrouptreeGroupidTogroupsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groups"

	return v
}

type groupsToGrouptreeGrouptreeGroupidTogroupsDeleteUnique struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToGrouptreeGrouptreeGroupidTogroupsDeleteUnique) groupsModel() {}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsDeleteUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsDeleteUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) with()           {}
func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) groupsModel()    {}
func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) groupsRelation() {}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) With(params ...GrouptreeRelationWith) groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) Select(params ...groupsPrismaFields) groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) Omit(params ...groupsPrismaFields) groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) OrderBy(params ...GrouptreeOrderByParam) groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) Skip(count int) groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) Take(count int) groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) Cursor(cursor GroupsCursorParam) groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindFirst) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupsToGrouptreeGrouptreeGroupidTogroupsFindMany struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) with()           {}
func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) groupsModel()    {}
func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) groupsRelation() {}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) With(params ...GrouptreeRelationWith) groupsToGrouptreeGrouptreeGroupidTogroupsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) Select(params ...groupsPrismaFields) groupsToGrouptreeGrouptreeGroupidTogroupsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) Omit(params ...groupsPrismaFields) groupsToGrouptreeGrouptreeGroupidTogroupsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) OrderBy(params ...GrouptreeOrderByParam) groupsToGrouptreeGrouptreeGroupidTogroupsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) Skip(count int) groupsToGrouptreeGrouptreeGroupidTogroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) Take(count int) groupsToGrouptreeGrouptreeGroupidTogroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) Cursor(cursor GroupsCursorParam) groupsToGrouptreeGrouptreeGroupidTogroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) Exec(ctx context.Context) (
	[]GroupsModel,
	error,
) {
	var v []GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) ExecInner(ctx context.Context) (
	[]InnerGroups,
	error,
) {
	var v []InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) Update(params ...GroupsSetParam) groupsToGrouptreeGrouptreeGroupidTogroupsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groups"

	r.query.Outputs = countOutput

	var v groupsToGrouptreeGrouptreeGroupidTogroupsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToGrouptreeGrouptreeGroupidTogroupsUpdateMany struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsUpdateMany) groupsModel() {}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsUpdateMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsFindMany) Delete() groupsToGrouptreeGrouptreeGroupidTogroupsDeleteMany {
	var v groupsToGrouptreeGrouptreeGroupidTogroupsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groups"

	v.query.Outputs = countOutput

	return v
}

type groupsToGrouptreeGrouptreeGroupidTogroupsDeleteMany struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToGrouptreeGrouptreeGroupidTogroupsDeleteMany) groupsModel() {}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGrouptreeGrouptreeGroupidTogroupsDeleteMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique) with()           {}
func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique) groupsModel()    {}
func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique) groupsRelation() {}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique) With(params ...GrouptreeRelationWith) groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique) Select(params ...groupsPrismaFields) groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique) Omit(params ...groupsPrismaFields) groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique) Update(params ...GroupsSetParam) groupsToGrouptreeGrouptreePgroupidTogroupsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groups"

	var v groupsToGrouptreeGrouptreePgroupidTogroupsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToGrouptreeGrouptreePgroupidTogroupsUpdateUnique struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsUpdateUnique) groupsModel() {}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsUpdateUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsUpdateUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindUnique) Delete() groupsToGrouptreeGrouptreePgroupidTogroupsDeleteUnique {
	var v groupsToGrouptreeGrouptreePgroupidTogroupsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groups"

	return v
}

type groupsToGrouptreeGrouptreePgroupidTogroupsDeleteUnique struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToGrouptreeGrouptreePgroupidTogroupsDeleteUnique) groupsModel() {}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsDeleteUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsDeleteUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) with()           {}
func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) groupsModel()    {}
func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) groupsRelation() {}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) With(params ...GrouptreeRelationWith) groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) Select(params ...groupsPrismaFields) groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) Omit(params ...groupsPrismaFields) groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) OrderBy(params ...GrouptreeOrderByParam) groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) Skip(count int) groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) Take(count int) groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) Cursor(cursor GroupsCursorParam) groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindFirst) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupsToGrouptreeGrouptreePgroupidTogroupsFindMany struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) with()           {}
func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) groupsModel()    {}
func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) groupsRelation() {}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) With(params ...GrouptreeRelationWith) groupsToGrouptreeGrouptreePgroupidTogroupsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) Select(params ...groupsPrismaFields) groupsToGrouptreeGrouptreePgroupidTogroupsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) Omit(params ...groupsPrismaFields) groupsToGrouptreeGrouptreePgroupidTogroupsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) OrderBy(params ...GrouptreeOrderByParam) groupsToGrouptreeGrouptreePgroupidTogroupsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) Skip(count int) groupsToGrouptreeGrouptreePgroupidTogroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) Take(count int) groupsToGrouptreeGrouptreePgroupidTogroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) Cursor(cursor GroupsCursorParam) groupsToGrouptreeGrouptreePgroupidTogroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) Exec(ctx context.Context) (
	[]GroupsModel,
	error,
) {
	var v []GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) ExecInner(ctx context.Context) (
	[]InnerGroups,
	error,
) {
	var v []InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) Update(params ...GroupsSetParam) groupsToGrouptreeGrouptreePgroupidTogroupsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groups"

	r.query.Outputs = countOutput

	var v groupsToGrouptreeGrouptreePgroupidTogroupsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToGrouptreeGrouptreePgroupidTogroupsUpdateMany struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsUpdateMany) groupsModel() {}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsUpdateMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsFindMany) Delete() groupsToGrouptreeGrouptreePgroupidTogroupsDeleteMany {
	var v groupsToGrouptreeGrouptreePgroupidTogroupsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groups"

	v.query.Outputs = countOutput

	return v
}

type groupsToGrouptreeGrouptreePgroupidTogroupsDeleteMany struct {
	query builder.Query
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToGrouptreeGrouptreePgroupidTogroupsDeleteMany) groupsModel() {}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGrouptreeGrouptreePgroupidTogroupsDeleteMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToGroupuserpermsFindUnique struct {
	query builder.Query
}

func (r groupsToGroupuserpermsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupsToGroupuserpermsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGroupuserpermsFindUnique) with()           {}
func (r groupsToGroupuserpermsFindUnique) groupsModel()    {}
func (r groupsToGroupuserpermsFindUnique) groupsRelation() {}

func (r groupsToGroupuserpermsFindUnique) With(params ...GroupuserpermsRelationWith) groupsToGroupuserpermsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToGroupuserpermsFindUnique) Select(params ...groupsPrismaFields) groupsToGroupuserpermsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGroupuserpermsFindUnique) Omit(params ...groupsPrismaFields) groupsToGroupuserpermsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGroupuserpermsFindUnique) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToGroupuserpermsFindUnique) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToGroupuserpermsFindUnique) Update(params ...GroupsSetParam) groupsToGroupuserpermsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groups"

	var v groupsToGroupuserpermsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToGroupuserpermsUpdateUnique struct {
	query builder.Query
}

func (r groupsToGroupuserpermsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGroupuserpermsUpdateUnique) groupsModel() {}

func (r groupsToGroupuserpermsUpdateUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGroupuserpermsUpdateUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToGroupuserpermsFindUnique) Delete() groupsToGroupuserpermsDeleteUnique {
	var v groupsToGroupuserpermsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groups"

	return v
}

type groupsToGroupuserpermsDeleteUnique struct {
	query builder.Query
}

func (r groupsToGroupuserpermsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToGroupuserpermsDeleteUnique) groupsModel() {}

func (r groupsToGroupuserpermsDeleteUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGroupuserpermsDeleteUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToGroupuserpermsFindFirst struct {
	query builder.Query
}

func (r groupsToGroupuserpermsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupsToGroupuserpermsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGroupuserpermsFindFirst) with()           {}
func (r groupsToGroupuserpermsFindFirst) groupsModel()    {}
func (r groupsToGroupuserpermsFindFirst) groupsRelation() {}

func (r groupsToGroupuserpermsFindFirst) With(params ...GroupuserpermsRelationWith) groupsToGroupuserpermsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToGroupuserpermsFindFirst) Select(params ...groupsPrismaFields) groupsToGroupuserpermsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGroupuserpermsFindFirst) Omit(params ...groupsPrismaFields) groupsToGroupuserpermsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGroupuserpermsFindFirst) OrderBy(params ...GroupuserpermsOrderByParam) groupsToGroupuserpermsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToGroupuserpermsFindFirst) Skip(count int) groupsToGroupuserpermsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToGroupuserpermsFindFirst) Take(count int) groupsToGroupuserpermsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToGroupuserpermsFindFirst) Cursor(cursor GroupsCursorParam) groupsToGroupuserpermsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToGroupuserpermsFindFirst) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToGroupuserpermsFindFirst) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupsToGroupuserpermsFindMany struct {
	query builder.Query
}

func (r groupsToGroupuserpermsFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupsToGroupuserpermsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGroupuserpermsFindMany) with()           {}
func (r groupsToGroupuserpermsFindMany) groupsModel()    {}
func (r groupsToGroupuserpermsFindMany) groupsRelation() {}

func (r groupsToGroupuserpermsFindMany) With(params ...GroupuserpermsRelationWith) groupsToGroupuserpermsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToGroupuserpermsFindMany) Select(params ...groupsPrismaFields) groupsToGroupuserpermsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGroupuserpermsFindMany) Omit(params ...groupsPrismaFields) groupsToGroupuserpermsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToGroupuserpermsFindMany) OrderBy(params ...GroupuserpermsOrderByParam) groupsToGroupuserpermsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToGroupuserpermsFindMany) Skip(count int) groupsToGroupuserpermsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToGroupuserpermsFindMany) Take(count int) groupsToGroupuserpermsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToGroupuserpermsFindMany) Cursor(cursor GroupsCursorParam) groupsToGroupuserpermsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToGroupuserpermsFindMany) Exec(ctx context.Context) (
	[]GroupsModel,
	error,
) {
	var v []GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToGroupuserpermsFindMany) ExecInner(ctx context.Context) (
	[]InnerGroups,
	error,
) {
	var v []InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToGroupuserpermsFindMany) Update(params ...GroupsSetParam) groupsToGroupuserpermsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groups"

	r.query.Outputs = countOutput

	var v groupsToGroupuserpermsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToGroupuserpermsUpdateMany struct {
	query builder.Query
}

func (r groupsToGroupuserpermsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToGroupuserpermsUpdateMany) groupsModel() {}

func (r groupsToGroupuserpermsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGroupuserpermsUpdateMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToGroupuserpermsFindMany) Delete() groupsToGroupuserpermsDeleteMany {
	var v groupsToGroupuserpermsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groups"

	v.query.Outputs = countOutput

	return v
}

type groupsToGroupuserpermsDeleteMany struct {
	query builder.Query
}

func (r groupsToGroupuserpermsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToGroupuserpermsDeleteMany) groupsModel() {}

func (r groupsToGroupuserpermsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToGroupuserpermsDeleteMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToOrgrgroupFindUnique struct {
	query builder.Query
}

func (r groupsToOrgrgroupFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupsToOrgrgroupFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToOrgrgroupFindUnique) with()           {}
func (r groupsToOrgrgroupFindUnique) groupsModel()    {}
func (r groupsToOrgrgroupFindUnique) groupsRelation() {}

func (r groupsToOrgrgroupFindUnique) With(params ...OrgrgroupRelationWith) groupsToOrgrgroupFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToOrgrgroupFindUnique) Select(params ...groupsPrismaFields) groupsToOrgrgroupFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToOrgrgroupFindUnique) Omit(params ...groupsPrismaFields) groupsToOrgrgroupFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToOrgrgroupFindUnique) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToOrgrgroupFindUnique) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToOrgrgroupFindUnique) Update(params ...GroupsSetParam) groupsToOrgrgroupUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groups"

	var v groupsToOrgrgroupUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToOrgrgroupUpdateUnique struct {
	query builder.Query
}

func (r groupsToOrgrgroupUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToOrgrgroupUpdateUnique) groupsModel() {}

func (r groupsToOrgrgroupUpdateUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToOrgrgroupUpdateUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToOrgrgroupFindUnique) Delete() groupsToOrgrgroupDeleteUnique {
	var v groupsToOrgrgroupDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groups"

	return v
}

type groupsToOrgrgroupDeleteUnique struct {
	query builder.Query
}

func (r groupsToOrgrgroupDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToOrgrgroupDeleteUnique) groupsModel() {}

func (r groupsToOrgrgroupDeleteUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToOrgrgroupDeleteUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToOrgrgroupFindFirst struct {
	query builder.Query
}

func (r groupsToOrgrgroupFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupsToOrgrgroupFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToOrgrgroupFindFirst) with()           {}
func (r groupsToOrgrgroupFindFirst) groupsModel()    {}
func (r groupsToOrgrgroupFindFirst) groupsRelation() {}

func (r groupsToOrgrgroupFindFirst) With(params ...OrgrgroupRelationWith) groupsToOrgrgroupFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToOrgrgroupFindFirst) Select(params ...groupsPrismaFields) groupsToOrgrgroupFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToOrgrgroupFindFirst) Omit(params ...groupsPrismaFields) groupsToOrgrgroupFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToOrgrgroupFindFirst) OrderBy(params ...OrgrgroupOrderByParam) groupsToOrgrgroupFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToOrgrgroupFindFirst) Skip(count int) groupsToOrgrgroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToOrgrgroupFindFirst) Take(count int) groupsToOrgrgroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToOrgrgroupFindFirst) Cursor(cursor GroupsCursorParam) groupsToOrgrgroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToOrgrgroupFindFirst) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToOrgrgroupFindFirst) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupsToOrgrgroupFindMany struct {
	query builder.Query
}

func (r groupsToOrgrgroupFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupsToOrgrgroupFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToOrgrgroupFindMany) with()           {}
func (r groupsToOrgrgroupFindMany) groupsModel()    {}
func (r groupsToOrgrgroupFindMany) groupsRelation() {}

func (r groupsToOrgrgroupFindMany) With(params ...OrgrgroupRelationWith) groupsToOrgrgroupFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToOrgrgroupFindMany) Select(params ...groupsPrismaFields) groupsToOrgrgroupFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToOrgrgroupFindMany) Omit(params ...groupsPrismaFields) groupsToOrgrgroupFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToOrgrgroupFindMany) OrderBy(params ...OrgrgroupOrderByParam) groupsToOrgrgroupFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToOrgrgroupFindMany) Skip(count int) groupsToOrgrgroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToOrgrgroupFindMany) Take(count int) groupsToOrgrgroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToOrgrgroupFindMany) Cursor(cursor GroupsCursorParam) groupsToOrgrgroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToOrgrgroupFindMany) Exec(ctx context.Context) (
	[]GroupsModel,
	error,
) {
	var v []GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToOrgrgroupFindMany) ExecInner(ctx context.Context) (
	[]InnerGroups,
	error,
) {
	var v []InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToOrgrgroupFindMany) Update(params ...GroupsSetParam) groupsToOrgrgroupUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groups"

	r.query.Outputs = countOutput

	var v groupsToOrgrgroupUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToOrgrgroupUpdateMany struct {
	query builder.Query
}

func (r groupsToOrgrgroupUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToOrgrgroupUpdateMany) groupsModel() {}

func (r groupsToOrgrgroupUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToOrgrgroupUpdateMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToOrgrgroupFindMany) Delete() groupsToOrgrgroupDeleteMany {
	var v groupsToOrgrgroupDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groups"

	v.query.Outputs = countOutput

	return v
}

type groupsToOrgrgroupDeleteMany struct {
	query builder.Query
}

func (r groupsToOrgrgroupDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToOrgrgroupDeleteMany) groupsModel() {}

func (r groupsToOrgrgroupDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToOrgrgroupDeleteMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToUsergroupFindUnique struct {
	query builder.Query
}

func (r groupsToUsergroupFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupsToUsergroupFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToUsergroupFindUnique) with()           {}
func (r groupsToUsergroupFindUnique) groupsModel()    {}
func (r groupsToUsergroupFindUnique) groupsRelation() {}

func (r groupsToUsergroupFindUnique) With(params ...UsergroupRelationWith) groupsToUsergroupFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToUsergroupFindUnique) Select(params ...groupsPrismaFields) groupsToUsergroupFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToUsergroupFindUnique) Omit(params ...groupsPrismaFields) groupsToUsergroupFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToUsergroupFindUnique) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToUsergroupFindUnique) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToUsergroupFindUnique) Update(params ...GroupsSetParam) groupsToUsergroupUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groups"

	var v groupsToUsergroupUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToUsergroupUpdateUnique struct {
	query builder.Query
}

func (r groupsToUsergroupUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToUsergroupUpdateUnique) groupsModel() {}

func (r groupsToUsergroupUpdateUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToUsergroupUpdateUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToUsergroupFindUnique) Delete() groupsToUsergroupDeleteUnique {
	var v groupsToUsergroupDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groups"

	return v
}

type groupsToUsergroupDeleteUnique struct {
	query builder.Query
}

func (r groupsToUsergroupDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToUsergroupDeleteUnique) groupsModel() {}

func (r groupsToUsergroupDeleteUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToUsergroupDeleteUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsToUsergroupFindFirst struct {
	query builder.Query
}

func (r groupsToUsergroupFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupsToUsergroupFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToUsergroupFindFirst) with()           {}
func (r groupsToUsergroupFindFirst) groupsModel()    {}
func (r groupsToUsergroupFindFirst) groupsRelation() {}

func (r groupsToUsergroupFindFirst) With(params ...UsergroupRelationWith) groupsToUsergroupFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToUsergroupFindFirst) Select(params ...groupsPrismaFields) groupsToUsergroupFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToUsergroupFindFirst) Omit(params ...groupsPrismaFields) groupsToUsergroupFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToUsergroupFindFirst) OrderBy(params ...UsergroupOrderByParam) groupsToUsergroupFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToUsergroupFindFirst) Skip(count int) groupsToUsergroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToUsergroupFindFirst) Take(count int) groupsToUsergroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToUsergroupFindFirst) Cursor(cursor GroupsCursorParam) groupsToUsergroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToUsergroupFindFirst) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsToUsergroupFindFirst) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupsToUsergroupFindMany struct {
	query builder.Query
}

func (r groupsToUsergroupFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupsToUsergroupFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToUsergroupFindMany) with()           {}
func (r groupsToUsergroupFindMany) groupsModel()    {}
func (r groupsToUsergroupFindMany) groupsRelation() {}

func (r groupsToUsergroupFindMany) With(params ...UsergroupRelationWith) groupsToUsergroupFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsToUsergroupFindMany) Select(params ...groupsPrismaFields) groupsToUsergroupFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToUsergroupFindMany) Omit(params ...groupsPrismaFields) groupsToUsergroupFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsToUsergroupFindMany) OrderBy(params ...UsergroupOrderByParam) groupsToUsergroupFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsToUsergroupFindMany) Skip(count int) groupsToUsergroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsToUsergroupFindMany) Take(count int) groupsToUsergroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsToUsergroupFindMany) Cursor(cursor GroupsCursorParam) groupsToUsergroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsToUsergroupFindMany) Exec(ctx context.Context) (
	[]GroupsModel,
	error,
) {
	var v []GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToUsergroupFindMany) ExecInner(ctx context.Context) (
	[]InnerGroups,
	error,
) {
	var v []InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsToUsergroupFindMany) Update(params ...GroupsSetParam) groupsToUsergroupUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groups"

	r.query.Outputs = countOutput

	var v groupsToUsergroupUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsToUsergroupUpdateMany struct {
	query builder.Query
}

func (r groupsToUsergroupUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsToUsergroupUpdateMany) groupsModel() {}

func (r groupsToUsergroupUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToUsergroupUpdateMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsToUsergroupFindMany) Delete() groupsToUsergroupDeleteMany {
	var v groupsToUsergroupDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groups"

	v.query.Outputs = countOutput

	return v
}

type groupsToUsergroupDeleteMany struct {
	query builder.Query
}

func (r groupsToUsergroupDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsToUsergroupDeleteMany) groupsModel() {}

func (r groupsToUsergroupDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsToUsergroupDeleteMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsFindUnique struct {
	query builder.Query
}

func (r groupsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsFindUnique) with()           {}
func (r groupsFindUnique) groupsModel()    {}
func (r groupsFindUnique) groupsRelation() {}

func (r groupsActions) FindUnique(
	params GroupsEqualsUniqueWhereParam,
) groupsFindUnique {
	var v groupsFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "groups"
	v.query.Outputs = groupsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r groupsFindUnique) With(params ...GroupsRelationWith) groupsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsFindUnique) Select(params ...groupsPrismaFields) groupsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsFindUnique) Omit(params ...groupsPrismaFields) groupsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsFindUnique) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsFindUnique) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsFindUnique) Update(params ...GroupsSetParam) groupsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groups"

	var v groupsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsUpdateUnique struct {
	query builder.Query
}

func (r groupsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsUpdateUnique) groupsModel() {}

func (r groupsUpdateUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsUpdateUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsFindUnique) Delete() groupsDeleteUnique {
	var v groupsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groups"

	return v
}

type groupsDeleteUnique struct {
	query builder.Query
}

func (r groupsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsDeleteUnique) groupsModel() {}

func (r groupsDeleteUnique) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsDeleteUnique) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsFindFirst struct {
	query builder.Query
}

func (r groupsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsFindFirst) with()           {}
func (r groupsFindFirst) groupsModel()    {}
func (r groupsFindFirst) groupsRelation() {}

func (r groupsActions) FindFirst(
	params ...GroupsWhereParam,
) groupsFindFirst {
	var v groupsFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "groups"
	v.query.Outputs = groupsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r groupsFindFirst) With(params ...GroupsRelationWith) groupsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsFindFirst) Select(params ...groupsPrismaFields) groupsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsFindFirst) Omit(params ...groupsPrismaFields) groupsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsFindFirst) OrderBy(params ...GroupsOrderByParam) groupsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsFindFirst) Skip(count int) groupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsFindFirst) Take(count int) groupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsFindFirst) Cursor(cursor GroupsCursorParam) groupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsFindFirst) Exec(ctx context.Context) (
	*GroupsModel,
	error,
) {
	var v *GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupsFindFirst) ExecInner(ctx context.Context) (
	*InnerGroups,
	error,
) {
	var v *InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupsFindMany struct {
	query builder.Query
}

func (r groupsFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsFindMany) with()           {}
func (r groupsFindMany) groupsModel()    {}
func (r groupsFindMany) groupsRelation() {}

func (r groupsActions) FindMany(
	params ...GroupsWhereParam,
) groupsFindMany {
	var v groupsFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "groups"
	v.query.Outputs = groupsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r groupsFindMany) With(params ...GroupsRelationWith) groupsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupsFindMany) Select(params ...groupsPrismaFields) groupsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsFindMany) Omit(params ...groupsPrismaFields) groupsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupsFindMany) OrderBy(params ...GroupsOrderByParam) groupsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupsFindMany) Skip(count int) groupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupsFindMany) Take(count int) groupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupsFindMany) Cursor(cursor GroupsCursorParam) groupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupsFindMany) Exec(ctx context.Context) (
	[]GroupsModel,
	error,
) {
	var v []GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsFindMany) ExecInner(ctx context.Context) (
	[]InnerGroups,
	error,
) {
	var v []InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupsFindMany) Update(params ...GroupsSetParam) groupsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groups"

	r.query.Outputs = countOutput

	var v groupsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupsUpdateMany struct {
	query builder.Query
}

func (r groupsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsUpdateMany) groupsModel() {}

func (r groupsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsUpdateMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupsFindMany) Delete() groupsDeleteMany {
	var v groupsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groups"

	v.query.Outputs = countOutput

	return v
}

type groupsDeleteMany struct {
	query builder.Query
}

func (r groupsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupsDeleteMany) groupsModel() {}

func (r groupsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsDeleteMany) Tx() GroupsManyTxResult {
	v := newGroupsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique) with()              {}
func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique) grouptreeModel()    {}
func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique) grouptreeRelation() {}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique) With(params ...GroupsRelationWith) grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique) Select(params ...grouptreePrismaFields) grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique) Omit(params ...grouptreePrismaFields) grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range grouptreeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique) Exec(ctx context.Context) (
	*GrouptreeModel,
	error,
) {
	var v *GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique) ExecInner(ctx context.Context) (
	*InnerGrouptree,
	error,
) {
	var v *InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique) Update(params ...GrouptreeSetParam) grouptreeToGroupsGrouptreeGroupidTogroupsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "grouptree"

	var v grouptreeToGroupsGrouptreeGroupidTogroupsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type grouptreeToGroupsGrouptreeGroupidTogroupsUpdateUnique struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsUpdateUnique) grouptreeModel() {}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsUpdateUnique) Exec(ctx context.Context) (*GrouptreeModel, error) {
	var v GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsUpdateUnique) Tx() GrouptreeUniqueTxResult {
	v := newGrouptreeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindUnique) Delete() grouptreeToGroupsGrouptreeGroupidTogroupsDeleteUnique {
	var v grouptreeToGroupsGrouptreeGroupidTogroupsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "grouptree"

	return v
}

type grouptreeToGroupsGrouptreeGroupidTogroupsDeleteUnique struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p grouptreeToGroupsGrouptreeGroupidTogroupsDeleteUnique) grouptreeModel() {}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsDeleteUnique) Exec(ctx context.Context) (*GrouptreeModel, error) {
	var v GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsDeleteUnique) Tx() GrouptreeUniqueTxResult {
	v := newGrouptreeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) with()              {}
func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) grouptreeModel()    {}
func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) grouptreeRelation() {}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) With(params ...GroupsRelationWith) grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) Select(params ...grouptreePrismaFields) grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) Omit(params ...grouptreePrismaFields) grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range grouptreeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) OrderBy(params ...GroupsOrderByParam) grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) Skip(count int) grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) Take(count int) grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) Cursor(cursor GrouptreeCursorParam) grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) Exec(ctx context.Context) (
	*GrouptreeModel,
	error,
) {
	var v *GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindFirst) ExecInner(ctx context.Context) (
	*InnerGrouptree,
	error,
) {
	var v *InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type grouptreeToGroupsGrouptreeGroupidTogroupsFindMany struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) getQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) with()              {}
func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) grouptreeModel()    {}
func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) grouptreeRelation() {}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) With(params ...GroupsRelationWith) grouptreeToGroupsGrouptreeGroupidTogroupsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) Select(params ...grouptreePrismaFields) grouptreeToGroupsGrouptreeGroupidTogroupsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) Omit(params ...grouptreePrismaFields) grouptreeToGroupsGrouptreeGroupidTogroupsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range grouptreeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) OrderBy(params ...GroupsOrderByParam) grouptreeToGroupsGrouptreeGroupidTogroupsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) Skip(count int) grouptreeToGroupsGrouptreeGroupidTogroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) Take(count int) grouptreeToGroupsGrouptreeGroupidTogroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) Cursor(cursor GrouptreeCursorParam) grouptreeToGroupsGrouptreeGroupidTogroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) Exec(ctx context.Context) (
	[]GrouptreeModel,
	error,
) {
	var v []GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) ExecInner(ctx context.Context) (
	[]InnerGrouptree,
	error,
) {
	var v []InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) Update(params ...GrouptreeSetParam) grouptreeToGroupsGrouptreeGroupidTogroupsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "grouptree"

	r.query.Outputs = countOutput

	var v grouptreeToGroupsGrouptreeGroupidTogroupsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type grouptreeToGroupsGrouptreeGroupidTogroupsUpdateMany struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsUpdateMany) grouptreeModel() {}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsUpdateMany) Tx() GrouptreeManyTxResult {
	v := newGrouptreeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsFindMany) Delete() grouptreeToGroupsGrouptreeGroupidTogroupsDeleteMany {
	var v grouptreeToGroupsGrouptreeGroupidTogroupsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "grouptree"

	v.query.Outputs = countOutput

	return v
}

type grouptreeToGroupsGrouptreeGroupidTogroupsDeleteMany struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p grouptreeToGroupsGrouptreeGroupidTogroupsDeleteMany) grouptreeModel() {}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeToGroupsGrouptreeGroupidTogroupsDeleteMany) Tx() GrouptreeManyTxResult {
	v := newGrouptreeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type grouptreeToOrgsFindUnique struct {
	query builder.Query
}

func (r grouptreeToOrgsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r grouptreeToOrgsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToOrgsFindUnique) with()              {}
func (r grouptreeToOrgsFindUnique) grouptreeModel()    {}
func (r grouptreeToOrgsFindUnique) grouptreeRelation() {}

func (r grouptreeToOrgsFindUnique) With(params ...OrgsRelationWith) grouptreeToOrgsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r grouptreeToOrgsFindUnique) Select(params ...grouptreePrismaFields) grouptreeToOrgsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToOrgsFindUnique) Omit(params ...grouptreePrismaFields) grouptreeToOrgsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range grouptreeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToOrgsFindUnique) Exec(ctx context.Context) (
	*GrouptreeModel,
	error,
) {
	var v *GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r grouptreeToOrgsFindUnique) ExecInner(ctx context.Context) (
	*InnerGrouptree,
	error,
) {
	var v *InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r grouptreeToOrgsFindUnique) Update(params ...GrouptreeSetParam) grouptreeToOrgsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "grouptree"

	var v grouptreeToOrgsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type grouptreeToOrgsUpdateUnique struct {
	query builder.Query
}

func (r grouptreeToOrgsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToOrgsUpdateUnique) grouptreeModel() {}

func (r grouptreeToOrgsUpdateUnique) Exec(ctx context.Context) (*GrouptreeModel, error) {
	var v GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeToOrgsUpdateUnique) Tx() GrouptreeUniqueTxResult {
	v := newGrouptreeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r grouptreeToOrgsFindUnique) Delete() grouptreeToOrgsDeleteUnique {
	var v grouptreeToOrgsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "grouptree"

	return v
}

type grouptreeToOrgsDeleteUnique struct {
	query builder.Query
}

func (r grouptreeToOrgsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p grouptreeToOrgsDeleteUnique) grouptreeModel() {}

func (r grouptreeToOrgsDeleteUnique) Exec(ctx context.Context) (*GrouptreeModel, error) {
	var v GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeToOrgsDeleteUnique) Tx() GrouptreeUniqueTxResult {
	v := newGrouptreeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type grouptreeToOrgsFindFirst struct {
	query builder.Query
}

func (r grouptreeToOrgsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r grouptreeToOrgsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToOrgsFindFirst) with()              {}
func (r grouptreeToOrgsFindFirst) grouptreeModel()    {}
func (r grouptreeToOrgsFindFirst) grouptreeRelation() {}

func (r grouptreeToOrgsFindFirst) With(params ...OrgsRelationWith) grouptreeToOrgsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r grouptreeToOrgsFindFirst) Select(params ...grouptreePrismaFields) grouptreeToOrgsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToOrgsFindFirst) Omit(params ...grouptreePrismaFields) grouptreeToOrgsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range grouptreeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToOrgsFindFirst) OrderBy(params ...OrgsOrderByParam) grouptreeToOrgsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r grouptreeToOrgsFindFirst) Skip(count int) grouptreeToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r grouptreeToOrgsFindFirst) Take(count int) grouptreeToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r grouptreeToOrgsFindFirst) Cursor(cursor GrouptreeCursorParam) grouptreeToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r grouptreeToOrgsFindFirst) Exec(ctx context.Context) (
	*GrouptreeModel,
	error,
) {
	var v *GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r grouptreeToOrgsFindFirst) ExecInner(ctx context.Context) (
	*InnerGrouptree,
	error,
) {
	var v *InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type grouptreeToOrgsFindMany struct {
	query builder.Query
}

func (r grouptreeToOrgsFindMany) getQuery() builder.Query {
	return r.query
}

func (r grouptreeToOrgsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToOrgsFindMany) with()              {}
func (r grouptreeToOrgsFindMany) grouptreeModel()    {}
func (r grouptreeToOrgsFindMany) grouptreeRelation() {}

func (r grouptreeToOrgsFindMany) With(params ...OrgsRelationWith) grouptreeToOrgsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r grouptreeToOrgsFindMany) Select(params ...grouptreePrismaFields) grouptreeToOrgsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToOrgsFindMany) Omit(params ...grouptreePrismaFields) grouptreeToOrgsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range grouptreeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToOrgsFindMany) OrderBy(params ...OrgsOrderByParam) grouptreeToOrgsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r grouptreeToOrgsFindMany) Skip(count int) grouptreeToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r grouptreeToOrgsFindMany) Take(count int) grouptreeToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r grouptreeToOrgsFindMany) Cursor(cursor GrouptreeCursorParam) grouptreeToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r grouptreeToOrgsFindMany) Exec(ctx context.Context) (
	[]GrouptreeModel,
	error,
) {
	var v []GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r grouptreeToOrgsFindMany) ExecInner(ctx context.Context) (
	[]InnerGrouptree,
	error,
) {
	var v []InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r grouptreeToOrgsFindMany) Update(params ...GrouptreeSetParam) grouptreeToOrgsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "grouptree"

	r.query.Outputs = countOutput

	var v grouptreeToOrgsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type grouptreeToOrgsUpdateMany struct {
	query builder.Query
}

func (r grouptreeToOrgsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToOrgsUpdateMany) grouptreeModel() {}

func (r grouptreeToOrgsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeToOrgsUpdateMany) Tx() GrouptreeManyTxResult {
	v := newGrouptreeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r grouptreeToOrgsFindMany) Delete() grouptreeToOrgsDeleteMany {
	var v grouptreeToOrgsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "grouptree"

	v.query.Outputs = countOutput

	return v
}

type grouptreeToOrgsDeleteMany struct {
	query builder.Query
}

func (r grouptreeToOrgsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p grouptreeToOrgsDeleteMany) grouptreeModel() {}

func (r grouptreeToOrgsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeToOrgsDeleteMany) Tx() GrouptreeManyTxResult {
	v := newGrouptreeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique) with()              {}
func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique) grouptreeModel()    {}
func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique) grouptreeRelation() {}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique) With(params ...GroupsRelationWith) grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique) Select(params ...grouptreePrismaFields) grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique) Omit(params ...grouptreePrismaFields) grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range grouptreeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique) Exec(ctx context.Context) (
	*GrouptreeModel,
	error,
) {
	var v *GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique) ExecInner(ctx context.Context) (
	*InnerGrouptree,
	error,
) {
	var v *InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique) Update(params ...GrouptreeSetParam) grouptreeToGroupsGrouptreePgroupidTogroupsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "grouptree"

	var v grouptreeToGroupsGrouptreePgroupidTogroupsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type grouptreeToGroupsGrouptreePgroupidTogroupsUpdateUnique struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsUpdateUnique) grouptreeModel() {}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsUpdateUnique) Exec(ctx context.Context) (*GrouptreeModel, error) {
	var v GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsUpdateUnique) Tx() GrouptreeUniqueTxResult {
	v := newGrouptreeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindUnique) Delete() grouptreeToGroupsGrouptreePgroupidTogroupsDeleteUnique {
	var v grouptreeToGroupsGrouptreePgroupidTogroupsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "grouptree"

	return v
}

type grouptreeToGroupsGrouptreePgroupidTogroupsDeleteUnique struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p grouptreeToGroupsGrouptreePgroupidTogroupsDeleteUnique) grouptreeModel() {}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsDeleteUnique) Exec(ctx context.Context) (*GrouptreeModel, error) {
	var v GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsDeleteUnique) Tx() GrouptreeUniqueTxResult {
	v := newGrouptreeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) with()              {}
func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) grouptreeModel()    {}
func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) grouptreeRelation() {}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) With(params ...GroupsRelationWith) grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) Select(params ...grouptreePrismaFields) grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) Omit(params ...grouptreePrismaFields) grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range grouptreeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) OrderBy(params ...GroupsOrderByParam) grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) Skip(count int) grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) Take(count int) grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) Cursor(cursor GrouptreeCursorParam) grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) Exec(ctx context.Context) (
	*GrouptreeModel,
	error,
) {
	var v *GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindFirst) ExecInner(ctx context.Context) (
	*InnerGrouptree,
	error,
) {
	var v *InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type grouptreeToGroupsGrouptreePgroupidTogroupsFindMany struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) getQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) with()              {}
func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) grouptreeModel()    {}
func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) grouptreeRelation() {}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) With(params ...GroupsRelationWith) grouptreeToGroupsGrouptreePgroupidTogroupsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) Select(params ...grouptreePrismaFields) grouptreeToGroupsGrouptreePgroupidTogroupsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) Omit(params ...grouptreePrismaFields) grouptreeToGroupsGrouptreePgroupidTogroupsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range grouptreeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) OrderBy(params ...GroupsOrderByParam) grouptreeToGroupsGrouptreePgroupidTogroupsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) Skip(count int) grouptreeToGroupsGrouptreePgroupidTogroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) Take(count int) grouptreeToGroupsGrouptreePgroupidTogroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) Cursor(cursor GrouptreeCursorParam) grouptreeToGroupsGrouptreePgroupidTogroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) Exec(ctx context.Context) (
	[]GrouptreeModel,
	error,
) {
	var v []GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) ExecInner(ctx context.Context) (
	[]InnerGrouptree,
	error,
) {
	var v []InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) Update(params ...GrouptreeSetParam) grouptreeToGroupsGrouptreePgroupidTogroupsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "grouptree"

	r.query.Outputs = countOutput

	var v grouptreeToGroupsGrouptreePgroupidTogroupsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type grouptreeToGroupsGrouptreePgroupidTogroupsUpdateMany struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsUpdateMany) grouptreeModel() {}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsUpdateMany) Tx() GrouptreeManyTxResult {
	v := newGrouptreeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsFindMany) Delete() grouptreeToGroupsGrouptreePgroupidTogroupsDeleteMany {
	var v grouptreeToGroupsGrouptreePgroupidTogroupsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "grouptree"

	v.query.Outputs = countOutput

	return v
}

type grouptreeToGroupsGrouptreePgroupidTogroupsDeleteMany struct {
	query builder.Query
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p grouptreeToGroupsGrouptreePgroupidTogroupsDeleteMany) grouptreeModel() {}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeToGroupsGrouptreePgroupidTogroupsDeleteMany) Tx() GrouptreeManyTxResult {
	v := newGrouptreeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type grouptreeFindUnique struct {
	query builder.Query
}

func (r grouptreeFindUnique) getQuery() builder.Query {
	return r.query
}

func (r grouptreeFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeFindUnique) with()              {}
func (r grouptreeFindUnique) grouptreeModel()    {}
func (r grouptreeFindUnique) grouptreeRelation() {}

func (r grouptreeActions) FindUnique(
	params GrouptreeEqualsUniqueWhereParam,
) grouptreeFindUnique {
	var v grouptreeFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "grouptree"
	v.query.Outputs = grouptreeOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r grouptreeFindUnique) With(params ...GrouptreeRelationWith) grouptreeFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r grouptreeFindUnique) Select(params ...grouptreePrismaFields) grouptreeFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeFindUnique) Omit(params ...grouptreePrismaFields) grouptreeFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range grouptreeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeFindUnique) Exec(ctx context.Context) (
	*GrouptreeModel,
	error,
) {
	var v *GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r grouptreeFindUnique) ExecInner(ctx context.Context) (
	*InnerGrouptree,
	error,
) {
	var v *InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r grouptreeFindUnique) Update(params ...GrouptreeSetParam) grouptreeUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "grouptree"

	var v grouptreeUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type grouptreeUpdateUnique struct {
	query builder.Query
}

func (r grouptreeUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeUpdateUnique) grouptreeModel() {}

func (r grouptreeUpdateUnique) Exec(ctx context.Context) (*GrouptreeModel, error) {
	var v GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeUpdateUnique) Tx() GrouptreeUniqueTxResult {
	v := newGrouptreeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r grouptreeFindUnique) Delete() grouptreeDeleteUnique {
	var v grouptreeDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "grouptree"

	return v
}

type grouptreeDeleteUnique struct {
	query builder.Query
}

func (r grouptreeDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p grouptreeDeleteUnique) grouptreeModel() {}

func (r grouptreeDeleteUnique) Exec(ctx context.Context) (*GrouptreeModel, error) {
	var v GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeDeleteUnique) Tx() GrouptreeUniqueTxResult {
	v := newGrouptreeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type grouptreeFindFirst struct {
	query builder.Query
}

func (r grouptreeFindFirst) getQuery() builder.Query {
	return r.query
}

func (r grouptreeFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeFindFirst) with()              {}
func (r grouptreeFindFirst) grouptreeModel()    {}
func (r grouptreeFindFirst) grouptreeRelation() {}

func (r grouptreeActions) FindFirst(
	params ...GrouptreeWhereParam,
) grouptreeFindFirst {
	var v grouptreeFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "grouptree"
	v.query.Outputs = grouptreeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r grouptreeFindFirst) With(params ...GrouptreeRelationWith) grouptreeFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r grouptreeFindFirst) Select(params ...grouptreePrismaFields) grouptreeFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeFindFirst) Omit(params ...grouptreePrismaFields) grouptreeFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range grouptreeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeFindFirst) OrderBy(params ...GrouptreeOrderByParam) grouptreeFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r grouptreeFindFirst) Skip(count int) grouptreeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r grouptreeFindFirst) Take(count int) grouptreeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r grouptreeFindFirst) Cursor(cursor GrouptreeCursorParam) grouptreeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r grouptreeFindFirst) Exec(ctx context.Context) (
	*GrouptreeModel,
	error,
) {
	var v *GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r grouptreeFindFirst) ExecInner(ctx context.Context) (
	*InnerGrouptree,
	error,
) {
	var v *InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type grouptreeFindMany struct {
	query builder.Query
}

func (r grouptreeFindMany) getQuery() builder.Query {
	return r.query
}

func (r grouptreeFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeFindMany) with()              {}
func (r grouptreeFindMany) grouptreeModel()    {}
func (r grouptreeFindMany) grouptreeRelation() {}

func (r grouptreeActions) FindMany(
	params ...GrouptreeWhereParam,
) grouptreeFindMany {
	var v grouptreeFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "grouptree"
	v.query.Outputs = grouptreeOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r grouptreeFindMany) With(params ...GrouptreeRelationWith) grouptreeFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r grouptreeFindMany) Select(params ...grouptreePrismaFields) grouptreeFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeFindMany) Omit(params ...grouptreePrismaFields) grouptreeFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range grouptreeOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r grouptreeFindMany) OrderBy(params ...GrouptreeOrderByParam) grouptreeFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r grouptreeFindMany) Skip(count int) grouptreeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r grouptreeFindMany) Take(count int) grouptreeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r grouptreeFindMany) Cursor(cursor GrouptreeCursorParam) grouptreeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r grouptreeFindMany) Exec(ctx context.Context) (
	[]GrouptreeModel,
	error,
) {
	var v []GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r grouptreeFindMany) ExecInner(ctx context.Context) (
	[]InnerGrouptree,
	error,
) {
	var v []InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r grouptreeFindMany) Update(params ...GrouptreeSetParam) grouptreeUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "grouptree"

	r.query.Outputs = countOutput

	var v grouptreeUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type grouptreeUpdateMany struct {
	query builder.Query
}

func (r grouptreeUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeUpdateMany) grouptreeModel() {}

func (r grouptreeUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeUpdateMany) Tx() GrouptreeManyTxResult {
	v := newGrouptreeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r grouptreeFindMany) Delete() grouptreeDeleteMany {
	var v grouptreeDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "grouptree"

	v.query.Outputs = countOutput

	return v
}

type grouptreeDeleteMany struct {
	query builder.Query
}

func (r grouptreeDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p grouptreeDeleteMany) grouptreeModel() {}

func (r grouptreeDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeDeleteMany) Tx() GrouptreeManyTxResult {
	v := newGrouptreeManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupuserpermsToGroupsFindUnique struct {
	query builder.Query
}

func (r groupuserpermsToGroupsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToGroupsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToGroupsFindUnique) with()                   {}
func (r groupuserpermsToGroupsFindUnique) groupuserpermsModel()    {}
func (r groupuserpermsToGroupsFindUnique) groupuserpermsRelation() {}

func (r groupuserpermsToGroupsFindUnique) With(params ...GroupsRelationWith) groupuserpermsToGroupsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupuserpermsToGroupsFindUnique) Select(params ...groupuserpermsPrismaFields) groupuserpermsToGroupsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToGroupsFindUnique) Omit(params ...groupuserpermsPrismaFields) groupuserpermsToGroupsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupuserpermsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToGroupsFindUnique) Exec(ctx context.Context) (
	*GroupuserpermsModel,
	error,
) {
	var v *GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupuserpermsToGroupsFindUnique) ExecInner(ctx context.Context) (
	*InnerGroupuserperms,
	error,
) {
	var v *InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupuserpermsToGroupsFindUnique) Update(params ...GroupuserpermsSetParam) groupuserpermsToGroupsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groupuserperms"

	var v groupuserpermsToGroupsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupuserpermsToGroupsUpdateUnique struct {
	query builder.Query
}

func (r groupuserpermsToGroupsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToGroupsUpdateUnique) groupuserpermsModel() {}

func (r groupuserpermsToGroupsUpdateUnique) Exec(ctx context.Context) (*GroupuserpermsModel, error) {
	var v GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsToGroupsUpdateUnique) Tx() GroupuserpermsUniqueTxResult {
	v := newGroupuserpermsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupuserpermsToGroupsFindUnique) Delete() groupuserpermsToGroupsDeleteUnique {
	var v groupuserpermsToGroupsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groupuserperms"

	return v
}

type groupuserpermsToGroupsDeleteUnique struct {
	query builder.Query
}

func (r groupuserpermsToGroupsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupuserpermsToGroupsDeleteUnique) groupuserpermsModel() {}

func (r groupuserpermsToGroupsDeleteUnique) Exec(ctx context.Context) (*GroupuserpermsModel, error) {
	var v GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsToGroupsDeleteUnique) Tx() GroupuserpermsUniqueTxResult {
	v := newGroupuserpermsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupuserpermsToGroupsFindFirst struct {
	query builder.Query
}

func (r groupuserpermsToGroupsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToGroupsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToGroupsFindFirst) with()                   {}
func (r groupuserpermsToGroupsFindFirst) groupuserpermsModel()    {}
func (r groupuserpermsToGroupsFindFirst) groupuserpermsRelation() {}

func (r groupuserpermsToGroupsFindFirst) With(params ...GroupsRelationWith) groupuserpermsToGroupsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupuserpermsToGroupsFindFirst) Select(params ...groupuserpermsPrismaFields) groupuserpermsToGroupsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToGroupsFindFirst) Omit(params ...groupuserpermsPrismaFields) groupuserpermsToGroupsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupuserpermsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToGroupsFindFirst) OrderBy(params ...GroupsOrderByParam) groupuserpermsToGroupsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupuserpermsToGroupsFindFirst) Skip(count int) groupuserpermsToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupuserpermsToGroupsFindFirst) Take(count int) groupuserpermsToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupuserpermsToGroupsFindFirst) Cursor(cursor GroupuserpermsCursorParam) groupuserpermsToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupuserpermsToGroupsFindFirst) Exec(ctx context.Context) (
	*GroupuserpermsModel,
	error,
) {
	var v *GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupuserpermsToGroupsFindFirst) ExecInner(ctx context.Context) (
	*InnerGroupuserperms,
	error,
) {
	var v *InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupuserpermsToGroupsFindMany struct {
	query builder.Query
}

func (r groupuserpermsToGroupsFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToGroupsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToGroupsFindMany) with()                   {}
func (r groupuserpermsToGroupsFindMany) groupuserpermsModel()    {}
func (r groupuserpermsToGroupsFindMany) groupuserpermsRelation() {}

func (r groupuserpermsToGroupsFindMany) With(params ...GroupsRelationWith) groupuserpermsToGroupsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupuserpermsToGroupsFindMany) Select(params ...groupuserpermsPrismaFields) groupuserpermsToGroupsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToGroupsFindMany) Omit(params ...groupuserpermsPrismaFields) groupuserpermsToGroupsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupuserpermsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToGroupsFindMany) OrderBy(params ...GroupsOrderByParam) groupuserpermsToGroupsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupuserpermsToGroupsFindMany) Skip(count int) groupuserpermsToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupuserpermsToGroupsFindMany) Take(count int) groupuserpermsToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupuserpermsToGroupsFindMany) Cursor(cursor GroupuserpermsCursorParam) groupuserpermsToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupuserpermsToGroupsFindMany) Exec(ctx context.Context) (
	[]GroupuserpermsModel,
	error,
) {
	var v []GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupuserpermsToGroupsFindMany) ExecInner(ctx context.Context) (
	[]InnerGroupuserperms,
	error,
) {
	var v []InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupuserpermsToGroupsFindMany) Update(params ...GroupuserpermsSetParam) groupuserpermsToGroupsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groupuserperms"

	r.query.Outputs = countOutput

	var v groupuserpermsToGroupsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupuserpermsToGroupsUpdateMany struct {
	query builder.Query
}

func (r groupuserpermsToGroupsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToGroupsUpdateMany) groupuserpermsModel() {}

func (r groupuserpermsToGroupsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsToGroupsUpdateMany) Tx() GroupuserpermsManyTxResult {
	v := newGroupuserpermsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupuserpermsToGroupsFindMany) Delete() groupuserpermsToGroupsDeleteMany {
	var v groupuserpermsToGroupsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groupuserperms"

	v.query.Outputs = countOutput

	return v
}

type groupuserpermsToGroupsDeleteMany struct {
	query builder.Query
}

func (r groupuserpermsToGroupsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupuserpermsToGroupsDeleteMany) groupuserpermsModel() {}

func (r groupuserpermsToGroupsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsToGroupsDeleteMany) Tx() GroupuserpermsManyTxResult {
	v := newGroupuserpermsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupuserpermsToOrgsFindUnique struct {
	query builder.Query
}

func (r groupuserpermsToOrgsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToOrgsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToOrgsFindUnique) with()                   {}
func (r groupuserpermsToOrgsFindUnique) groupuserpermsModel()    {}
func (r groupuserpermsToOrgsFindUnique) groupuserpermsRelation() {}

func (r groupuserpermsToOrgsFindUnique) With(params ...OrgsRelationWith) groupuserpermsToOrgsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupuserpermsToOrgsFindUnique) Select(params ...groupuserpermsPrismaFields) groupuserpermsToOrgsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToOrgsFindUnique) Omit(params ...groupuserpermsPrismaFields) groupuserpermsToOrgsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupuserpermsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToOrgsFindUnique) Exec(ctx context.Context) (
	*GroupuserpermsModel,
	error,
) {
	var v *GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupuserpermsToOrgsFindUnique) ExecInner(ctx context.Context) (
	*InnerGroupuserperms,
	error,
) {
	var v *InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupuserpermsToOrgsFindUnique) Update(params ...GroupuserpermsSetParam) groupuserpermsToOrgsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groupuserperms"

	var v groupuserpermsToOrgsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupuserpermsToOrgsUpdateUnique struct {
	query builder.Query
}

func (r groupuserpermsToOrgsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToOrgsUpdateUnique) groupuserpermsModel() {}

func (r groupuserpermsToOrgsUpdateUnique) Exec(ctx context.Context) (*GroupuserpermsModel, error) {
	var v GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsToOrgsUpdateUnique) Tx() GroupuserpermsUniqueTxResult {
	v := newGroupuserpermsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupuserpermsToOrgsFindUnique) Delete() groupuserpermsToOrgsDeleteUnique {
	var v groupuserpermsToOrgsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groupuserperms"

	return v
}

type groupuserpermsToOrgsDeleteUnique struct {
	query builder.Query
}

func (r groupuserpermsToOrgsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupuserpermsToOrgsDeleteUnique) groupuserpermsModel() {}

func (r groupuserpermsToOrgsDeleteUnique) Exec(ctx context.Context) (*GroupuserpermsModel, error) {
	var v GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsToOrgsDeleteUnique) Tx() GroupuserpermsUniqueTxResult {
	v := newGroupuserpermsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupuserpermsToOrgsFindFirst struct {
	query builder.Query
}

func (r groupuserpermsToOrgsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToOrgsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToOrgsFindFirst) with()                   {}
func (r groupuserpermsToOrgsFindFirst) groupuserpermsModel()    {}
func (r groupuserpermsToOrgsFindFirst) groupuserpermsRelation() {}

func (r groupuserpermsToOrgsFindFirst) With(params ...OrgsRelationWith) groupuserpermsToOrgsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupuserpermsToOrgsFindFirst) Select(params ...groupuserpermsPrismaFields) groupuserpermsToOrgsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToOrgsFindFirst) Omit(params ...groupuserpermsPrismaFields) groupuserpermsToOrgsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupuserpermsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToOrgsFindFirst) OrderBy(params ...OrgsOrderByParam) groupuserpermsToOrgsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupuserpermsToOrgsFindFirst) Skip(count int) groupuserpermsToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupuserpermsToOrgsFindFirst) Take(count int) groupuserpermsToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupuserpermsToOrgsFindFirst) Cursor(cursor GroupuserpermsCursorParam) groupuserpermsToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupuserpermsToOrgsFindFirst) Exec(ctx context.Context) (
	*GroupuserpermsModel,
	error,
) {
	var v *GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupuserpermsToOrgsFindFirst) ExecInner(ctx context.Context) (
	*InnerGroupuserperms,
	error,
) {
	var v *InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupuserpermsToOrgsFindMany struct {
	query builder.Query
}

func (r groupuserpermsToOrgsFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToOrgsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToOrgsFindMany) with()                   {}
func (r groupuserpermsToOrgsFindMany) groupuserpermsModel()    {}
func (r groupuserpermsToOrgsFindMany) groupuserpermsRelation() {}

func (r groupuserpermsToOrgsFindMany) With(params ...OrgsRelationWith) groupuserpermsToOrgsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupuserpermsToOrgsFindMany) Select(params ...groupuserpermsPrismaFields) groupuserpermsToOrgsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToOrgsFindMany) Omit(params ...groupuserpermsPrismaFields) groupuserpermsToOrgsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupuserpermsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToOrgsFindMany) OrderBy(params ...OrgsOrderByParam) groupuserpermsToOrgsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupuserpermsToOrgsFindMany) Skip(count int) groupuserpermsToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupuserpermsToOrgsFindMany) Take(count int) groupuserpermsToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupuserpermsToOrgsFindMany) Cursor(cursor GroupuserpermsCursorParam) groupuserpermsToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupuserpermsToOrgsFindMany) Exec(ctx context.Context) (
	[]GroupuserpermsModel,
	error,
) {
	var v []GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupuserpermsToOrgsFindMany) ExecInner(ctx context.Context) (
	[]InnerGroupuserperms,
	error,
) {
	var v []InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupuserpermsToOrgsFindMany) Update(params ...GroupuserpermsSetParam) groupuserpermsToOrgsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groupuserperms"

	r.query.Outputs = countOutput

	var v groupuserpermsToOrgsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupuserpermsToOrgsUpdateMany struct {
	query builder.Query
}

func (r groupuserpermsToOrgsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToOrgsUpdateMany) groupuserpermsModel() {}

func (r groupuserpermsToOrgsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsToOrgsUpdateMany) Tx() GroupuserpermsManyTxResult {
	v := newGroupuserpermsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupuserpermsToOrgsFindMany) Delete() groupuserpermsToOrgsDeleteMany {
	var v groupuserpermsToOrgsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groupuserperms"

	v.query.Outputs = countOutput

	return v
}

type groupuserpermsToOrgsDeleteMany struct {
	query builder.Query
}

func (r groupuserpermsToOrgsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupuserpermsToOrgsDeleteMany) groupuserpermsModel() {}

func (r groupuserpermsToOrgsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsToOrgsDeleteMany) Tx() GroupuserpermsManyTxResult {
	v := newGroupuserpermsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupuserpermsToUsersFindUnique struct {
	query builder.Query
}

func (r groupuserpermsToUsersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToUsersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToUsersFindUnique) with()                   {}
func (r groupuserpermsToUsersFindUnique) groupuserpermsModel()    {}
func (r groupuserpermsToUsersFindUnique) groupuserpermsRelation() {}

func (r groupuserpermsToUsersFindUnique) With(params ...UsersRelationWith) groupuserpermsToUsersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupuserpermsToUsersFindUnique) Select(params ...groupuserpermsPrismaFields) groupuserpermsToUsersFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToUsersFindUnique) Omit(params ...groupuserpermsPrismaFields) groupuserpermsToUsersFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupuserpermsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToUsersFindUnique) Exec(ctx context.Context) (
	*GroupuserpermsModel,
	error,
) {
	var v *GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupuserpermsToUsersFindUnique) ExecInner(ctx context.Context) (
	*InnerGroupuserperms,
	error,
) {
	var v *InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupuserpermsToUsersFindUnique) Update(params ...GroupuserpermsSetParam) groupuserpermsToUsersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groupuserperms"

	var v groupuserpermsToUsersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupuserpermsToUsersUpdateUnique struct {
	query builder.Query
}

func (r groupuserpermsToUsersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToUsersUpdateUnique) groupuserpermsModel() {}

func (r groupuserpermsToUsersUpdateUnique) Exec(ctx context.Context) (*GroupuserpermsModel, error) {
	var v GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsToUsersUpdateUnique) Tx() GroupuserpermsUniqueTxResult {
	v := newGroupuserpermsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupuserpermsToUsersFindUnique) Delete() groupuserpermsToUsersDeleteUnique {
	var v groupuserpermsToUsersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groupuserperms"

	return v
}

type groupuserpermsToUsersDeleteUnique struct {
	query builder.Query
}

func (r groupuserpermsToUsersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupuserpermsToUsersDeleteUnique) groupuserpermsModel() {}

func (r groupuserpermsToUsersDeleteUnique) Exec(ctx context.Context) (*GroupuserpermsModel, error) {
	var v GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsToUsersDeleteUnique) Tx() GroupuserpermsUniqueTxResult {
	v := newGroupuserpermsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupuserpermsToUsersFindFirst struct {
	query builder.Query
}

func (r groupuserpermsToUsersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToUsersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToUsersFindFirst) with()                   {}
func (r groupuserpermsToUsersFindFirst) groupuserpermsModel()    {}
func (r groupuserpermsToUsersFindFirst) groupuserpermsRelation() {}

func (r groupuserpermsToUsersFindFirst) With(params ...UsersRelationWith) groupuserpermsToUsersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupuserpermsToUsersFindFirst) Select(params ...groupuserpermsPrismaFields) groupuserpermsToUsersFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToUsersFindFirst) Omit(params ...groupuserpermsPrismaFields) groupuserpermsToUsersFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupuserpermsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToUsersFindFirst) OrderBy(params ...UsersOrderByParam) groupuserpermsToUsersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupuserpermsToUsersFindFirst) Skip(count int) groupuserpermsToUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupuserpermsToUsersFindFirst) Take(count int) groupuserpermsToUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupuserpermsToUsersFindFirst) Cursor(cursor GroupuserpermsCursorParam) groupuserpermsToUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupuserpermsToUsersFindFirst) Exec(ctx context.Context) (
	*GroupuserpermsModel,
	error,
) {
	var v *GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupuserpermsToUsersFindFirst) ExecInner(ctx context.Context) (
	*InnerGroupuserperms,
	error,
) {
	var v *InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupuserpermsToUsersFindMany struct {
	query builder.Query
}

func (r groupuserpermsToUsersFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToUsersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToUsersFindMany) with()                   {}
func (r groupuserpermsToUsersFindMany) groupuserpermsModel()    {}
func (r groupuserpermsToUsersFindMany) groupuserpermsRelation() {}

func (r groupuserpermsToUsersFindMany) With(params ...UsersRelationWith) groupuserpermsToUsersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupuserpermsToUsersFindMany) Select(params ...groupuserpermsPrismaFields) groupuserpermsToUsersFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToUsersFindMany) Omit(params ...groupuserpermsPrismaFields) groupuserpermsToUsersFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupuserpermsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsToUsersFindMany) OrderBy(params ...UsersOrderByParam) groupuserpermsToUsersFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupuserpermsToUsersFindMany) Skip(count int) groupuserpermsToUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupuserpermsToUsersFindMany) Take(count int) groupuserpermsToUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupuserpermsToUsersFindMany) Cursor(cursor GroupuserpermsCursorParam) groupuserpermsToUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupuserpermsToUsersFindMany) Exec(ctx context.Context) (
	[]GroupuserpermsModel,
	error,
) {
	var v []GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupuserpermsToUsersFindMany) ExecInner(ctx context.Context) (
	[]InnerGroupuserperms,
	error,
) {
	var v []InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupuserpermsToUsersFindMany) Update(params ...GroupuserpermsSetParam) groupuserpermsToUsersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groupuserperms"

	r.query.Outputs = countOutput

	var v groupuserpermsToUsersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupuserpermsToUsersUpdateMany struct {
	query builder.Query
}

func (r groupuserpermsToUsersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsToUsersUpdateMany) groupuserpermsModel() {}

func (r groupuserpermsToUsersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsToUsersUpdateMany) Tx() GroupuserpermsManyTxResult {
	v := newGroupuserpermsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupuserpermsToUsersFindMany) Delete() groupuserpermsToUsersDeleteMany {
	var v groupuserpermsToUsersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groupuserperms"

	v.query.Outputs = countOutput

	return v
}

type groupuserpermsToUsersDeleteMany struct {
	query builder.Query
}

func (r groupuserpermsToUsersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupuserpermsToUsersDeleteMany) groupuserpermsModel() {}

func (r groupuserpermsToUsersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsToUsersDeleteMany) Tx() GroupuserpermsManyTxResult {
	v := newGroupuserpermsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupuserpermsFindUnique struct {
	query builder.Query
}

func (r groupuserpermsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsFindUnique) with()                   {}
func (r groupuserpermsFindUnique) groupuserpermsModel()    {}
func (r groupuserpermsFindUnique) groupuserpermsRelation() {}

func (r groupuserpermsActions) FindUnique(
	params GroupuserpermsEqualsUniqueWhereParam,
) groupuserpermsFindUnique {
	var v groupuserpermsFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "groupuserperms"
	v.query.Outputs = groupuserpermsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r groupuserpermsFindUnique) With(params ...GroupuserpermsRelationWith) groupuserpermsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupuserpermsFindUnique) Select(params ...groupuserpermsPrismaFields) groupuserpermsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsFindUnique) Omit(params ...groupuserpermsPrismaFields) groupuserpermsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupuserpermsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsFindUnique) Exec(ctx context.Context) (
	*GroupuserpermsModel,
	error,
) {
	var v *GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupuserpermsFindUnique) ExecInner(ctx context.Context) (
	*InnerGroupuserperms,
	error,
) {
	var v *InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupuserpermsFindUnique) Update(params ...GroupuserpermsSetParam) groupuserpermsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "groupuserperms"

	var v groupuserpermsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupuserpermsUpdateUnique struct {
	query builder.Query
}

func (r groupuserpermsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsUpdateUnique) groupuserpermsModel() {}

func (r groupuserpermsUpdateUnique) Exec(ctx context.Context) (*GroupuserpermsModel, error) {
	var v GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsUpdateUnique) Tx() GroupuserpermsUniqueTxResult {
	v := newGroupuserpermsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupuserpermsFindUnique) Delete() groupuserpermsDeleteUnique {
	var v groupuserpermsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "groupuserperms"

	return v
}

type groupuserpermsDeleteUnique struct {
	query builder.Query
}

func (r groupuserpermsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p groupuserpermsDeleteUnique) groupuserpermsModel() {}

func (r groupuserpermsDeleteUnique) Exec(ctx context.Context) (*GroupuserpermsModel, error) {
	var v GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsDeleteUnique) Tx() GroupuserpermsUniqueTxResult {
	v := newGroupuserpermsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupuserpermsFindFirst struct {
	query builder.Query
}

func (r groupuserpermsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsFindFirst) with()                   {}
func (r groupuserpermsFindFirst) groupuserpermsModel()    {}
func (r groupuserpermsFindFirst) groupuserpermsRelation() {}

func (r groupuserpermsActions) FindFirst(
	params ...GroupuserpermsWhereParam,
) groupuserpermsFindFirst {
	var v groupuserpermsFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "groupuserperms"
	v.query.Outputs = groupuserpermsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r groupuserpermsFindFirst) With(params ...GroupuserpermsRelationWith) groupuserpermsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupuserpermsFindFirst) Select(params ...groupuserpermsPrismaFields) groupuserpermsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsFindFirst) Omit(params ...groupuserpermsPrismaFields) groupuserpermsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupuserpermsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsFindFirst) OrderBy(params ...GroupuserpermsOrderByParam) groupuserpermsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupuserpermsFindFirst) Skip(count int) groupuserpermsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupuserpermsFindFirst) Take(count int) groupuserpermsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupuserpermsFindFirst) Cursor(cursor GroupuserpermsCursorParam) groupuserpermsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupuserpermsFindFirst) Exec(ctx context.Context) (
	*GroupuserpermsModel,
	error,
) {
	var v *GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r groupuserpermsFindFirst) ExecInner(ctx context.Context) (
	*InnerGroupuserperms,
	error,
) {
	var v *InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type groupuserpermsFindMany struct {
	query builder.Query
}

func (r groupuserpermsFindMany) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsFindMany) with()                   {}
func (r groupuserpermsFindMany) groupuserpermsModel()    {}
func (r groupuserpermsFindMany) groupuserpermsRelation() {}

func (r groupuserpermsActions) FindMany(
	params ...GroupuserpermsWhereParam,
) groupuserpermsFindMany {
	var v groupuserpermsFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "groupuserperms"
	v.query.Outputs = groupuserpermsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r groupuserpermsFindMany) With(params ...GroupuserpermsRelationWith) groupuserpermsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r groupuserpermsFindMany) Select(params ...groupuserpermsPrismaFields) groupuserpermsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsFindMany) Omit(params ...groupuserpermsPrismaFields) groupuserpermsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range groupuserpermsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r groupuserpermsFindMany) OrderBy(params ...GroupuserpermsOrderByParam) groupuserpermsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r groupuserpermsFindMany) Skip(count int) groupuserpermsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r groupuserpermsFindMany) Take(count int) groupuserpermsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r groupuserpermsFindMany) Cursor(cursor GroupuserpermsCursorParam) groupuserpermsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r groupuserpermsFindMany) Exec(ctx context.Context) (
	[]GroupuserpermsModel,
	error,
) {
	var v []GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupuserpermsFindMany) ExecInner(ctx context.Context) (
	[]InnerGroupuserperms,
	error,
) {
	var v []InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r groupuserpermsFindMany) Update(params ...GroupuserpermsSetParam) groupuserpermsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "groupuserperms"

	r.query.Outputs = countOutput

	var v groupuserpermsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type groupuserpermsUpdateMany struct {
	query builder.Query
}

func (r groupuserpermsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsUpdateMany) groupuserpermsModel() {}

func (r groupuserpermsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsUpdateMany) Tx() GroupuserpermsManyTxResult {
	v := newGroupuserpermsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r groupuserpermsFindMany) Delete() groupuserpermsDeleteMany {
	var v groupuserpermsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "groupuserperms"

	v.query.Outputs = countOutput

	return v
}

type groupuserpermsDeleteMany struct {
	query builder.Query
}

func (r groupuserpermsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p groupuserpermsDeleteMany) groupuserpermsModel() {}

func (r groupuserpermsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsDeleteMany) Tx() GroupuserpermsManyTxResult {
	v := newGroupuserpermsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgdevicesToDevicesFindUnique struct {
	query builder.Query
}

func (r orgdevicesToDevicesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgdevicesToDevicesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesToDevicesFindUnique) with()               {}
func (r orgdevicesToDevicesFindUnique) orgdevicesModel()    {}
func (r orgdevicesToDevicesFindUnique) orgdevicesRelation() {}

func (r orgdevicesToDevicesFindUnique) With(params ...DevicesRelationWith) orgdevicesToDevicesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgdevicesToDevicesFindUnique) Select(params ...orgdevicesPrismaFields) orgdevicesToDevicesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesToDevicesFindUnique) Omit(params ...orgdevicesPrismaFields) orgdevicesToDevicesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesToDevicesFindUnique) Exec(ctx context.Context) (
	*OrgdevicesModel,
	error,
) {
	var v *OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgdevicesToDevicesFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgdevices,
	error,
) {
	var v *InnerOrgdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgdevicesToDevicesFindUnique) Update(params ...OrgdevicesSetParam) orgdevicesToDevicesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgdevices"

	var v orgdevicesToDevicesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgdevicesToDevicesUpdateUnique struct {
	query builder.Query
}

func (r orgdevicesToDevicesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesToDevicesUpdateUnique) orgdevicesModel() {}

func (r orgdevicesToDevicesUpdateUnique) Exec(ctx context.Context) (*OrgdevicesModel, error) {
	var v OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesToDevicesUpdateUnique) Tx() OrgdevicesUniqueTxResult {
	v := newOrgdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgdevicesToDevicesFindUnique) Delete() orgdevicesToDevicesDeleteUnique {
	var v orgdevicesToDevicesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgdevices"

	return v
}

type orgdevicesToDevicesDeleteUnique struct {
	query builder.Query
}

func (r orgdevicesToDevicesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgdevicesToDevicesDeleteUnique) orgdevicesModel() {}

func (r orgdevicesToDevicesDeleteUnique) Exec(ctx context.Context) (*OrgdevicesModel, error) {
	var v OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesToDevicesDeleteUnique) Tx() OrgdevicesUniqueTxResult {
	v := newOrgdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgdevicesToDevicesFindFirst struct {
	query builder.Query
}

func (r orgdevicesToDevicesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgdevicesToDevicesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesToDevicesFindFirst) with()               {}
func (r orgdevicesToDevicesFindFirst) orgdevicesModel()    {}
func (r orgdevicesToDevicesFindFirst) orgdevicesRelation() {}

func (r orgdevicesToDevicesFindFirst) With(params ...DevicesRelationWith) orgdevicesToDevicesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgdevicesToDevicesFindFirst) Select(params ...orgdevicesPrismaFields) orgdevicesToDevicesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesToDevicesFindFirst) Omit(params ...orgdevicesPrismaFields) orgdevicesToDevicesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesToDevicesFindFirst) OrderBy(params ...DevicesOrderByParam) orgdevicesToDevicesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgdevicesToDevicesFindFirst) Skip(count int) orgdevicesToDevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgdevicesToDevicesFindFirst) Take(count int) orgdevicesToDevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgdevicesToDevicesFindFirst) Cursor(cursor OrgdevicesCursorParam) orgdevicesToDevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgdevicesToDevicesFindFirst) Exec(ctx context.Context) (
	*OrgdevicesModel,
	error,
) {
	var v *OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgdevicesToDevicesFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgdevices,
	error,
) {
	var v *InnerOrgdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgdevicesToDevicesFindMany struct {
	query builder.Query
}

func (r orgdevicesToDevicesFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgdevicesToDevicesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesToDevicesFindMany) with()               {}
func (r orgdevicesToDevicesFindMany) orgdevicesModel()    {}
func (r orgdevicesToDevicesFindMany) orgdevicesRelation() {}

func (r orgdevicesToDevicesFindMany) With(params ...DevicesRelationWith) orgdevicesToDevicesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgdevicesToDevicesFindMany) Select(params ...orgdevicesPrismaFields) orgdevicesToDevicesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesToDevicesFindMany) Omit(params ...orgdevicesPrismaFields) orgdevicesToDevicesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesToDevicesFindMany) OrderBy(params ...DevicesOrderByParam) orgdevicesToDevicesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgdevicesToDevicesFindMany) Skip(count int) orgdevicesToDevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgdevicesToDevicesFindMany) Take(count int) orgdevicesToDevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgdevicesToDevicesFindMany) Cursor(cursor OrgdevicesCursorParam) orgdevicesToDevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgdevicesToDevicesFindMany) Exec(ctx context.Context) (
	[]OrgdevicesModel,
	error,
) {
	var v []OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgdevicesToDevicesFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgdevices,
	error,
) {
	var v []InnerOrgdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgdevicesToDevicesFindMany) Update(params ...OrgdevicesSetParam) orgdevicesToDevicesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgdevices"

	r.query.Outputs = countOutput

	var v orgdevicesToDevicesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgdevicesToDevicesUpdateMany struct {
	query builder.Query
}

func (r orgdevicesToDevicesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesToDevicesUpdateMany) orgdevicesModel() {}

func (r orgdevicesToDevicesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesToDevicesUpdateMany) Tx() OrgdevicesManyTxResult {
	v := newOrgdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgdevicesToDevicesFindMany) Delete() orgdevicesToDevicesDeleteMany {
	var v orgdevicesToDevicesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgdevices"

	v.query.Outputs = countOutput

	return v
}

type orgdevicesToDevicesDeleteMany struct {
	query builder.Query
}

func (r orgdevicesToDevicesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgdevicesToDevicesDeleteMany) orgdevicesModel() {}

func (r orgdevicesToDevicesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesToDevicesDeleteMany) Tx() OrgdevicesManyTxResult {
	v := newOrgdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgdevicesToOrgsFindUnique struct {
	query builder.Query
}

func (r orgdevicesToOrgsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgdevicesToOrgsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesToOrgsFindUnique) with()               {}
func (r orgdevicesToOrgsFindUnique) orgdevicesModel()    {}
func (r orgdevicesToOrgsFindUnique) orgdevicesRelation() {}

func (r orgdevicesToOrgsFindUnique) With(params ...OrgsRelationWith) orgdevicesToOrgsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgdevicesToOrgsFindUnique) Select(params ...orgdevicesPrismaFields) orgdevicesToOrgsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesToOrgsFindUnique) Omit(params ...orgdevicesPrismaFields) orgdevicesToOrgsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesToOrgsFindUnique) Exec(ctx context.Context) (
	*OrgdevicesModel,
	error,
) {
	var v *OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgdevicesToOrgsFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgdevices,
	error,
) {
	var v *InnerOrgdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgdevicesToOrgsFindUnique) Update(params ...OrgdevicesSetParam) orgdevicesToOrgsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgdevices"

	var v orgdevicesToOrgsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgdevicesToOrgsUpdateUnique struct {
	query builder.Query
}

func (r orgdevicesToOrgsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesToOrgsUpdateUnique) orgdevicesModel() {}

func (r orgdevicesToOrgsUpdateUnique) Exec(ctx context.Context) (*OrgdevicesModel, error) {
	var v OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesToOrgsUpdateUnique) Tx() OrgdevicesUniqueTxResult {
	v := newOrgdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgdevicesToOrgsFindUnique) Delete() orgdevicesToOrgsDeleteUnique {
	var v orgdevicesToOrgsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgdevices"

	return v
}

type orgdevicesToOrgsDeleteUnique struct {
	query builder.Query
}

func (r orgdevicesToOrgsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgdevicesToOrgsDeleteUnique) orgdevicesModel() {}

func (r orgdevicesToOrgsDeleteUnique) Exec(ctx context.Context) (*OrgdevicesModel, error) {
	var v OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesToOrgsDeleteUnique) Tx() OrgdevicesUniqueTxResult {
	v := newOrgdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgdevicesToOrgsFindFirst struct {
	query builder.Query
}

func (r orgdevicesToOrgsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgdevicesToOrgsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesToOrgsFindFirst) with()               {}
func (r orgdevicesToOrgsFindFirst) orgdevicesModel()    {}
func (r orgdevicesToOrgsFindFirst) orgdevicesRelation() {}

func (r orgdevicesToOrgsFindFirst) With(params ...OrgsRelationWith) orgdevicesToOrgsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgdevicesToOrgsFindFirst) Select(params ...orgdevicesPrismaFields) orgdevicesToOrgsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesToOrgsFindFirst) Omit(params ...orgdevicesPrismaFields) orgdevicesToOrgsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesToOrgsFindFirst) OrderBy(params ...OrgsOrderByParam) orgdevicesToOrgsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgdevicesToOrgsFindFirst) Skip(count int) orgdevicesToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgdevicesToOrgsFindFirst) Take(count int) orgdevicesToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgdevicesToOrgsFindFirst) Cursor(cursor OrgdevicesCursorParam) orgdevicesToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgdevicesToOrgsFindFirst) Exec(ctx context.Context) (
	*OrgdevicesModel,
	error,
) {
	var v *OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgdevicesToOrgsFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgdevices,
	error,
) {
	var v *InnerOrgdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgdevicesToOrgsFindMany struct {
	query builder.Query
}

func (r orgdevicesToOrgsFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgdevicesToOrgsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesToOrgsFindMany) with()               {}
func (r orgdevicesToOrgsFindMany) orgdevicesModel()    {}
func (r orgdevicesToOrgsFindMany) orgdevicesRelation() {}

func (r orgdevicesToOrgsFindMany) With(params ...OrgsRelationWith) orgdevicesToOrgsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgdevicesToOrgsFindMany) Select(params ...orgdevicesPrismaFields) orgdevicesToOrgsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesToOrgsFindMany) Omit(params ...orgdevicesPrismaFields) orgdevicesToOrgsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesToOrgsFindMany) OrderBy(params ...OrgsOrderByParam) orgdevicesToOrgsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgdevicesToOrgsFindMany) Skip(count int) orgdevicesToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgdevicesToOrgsFindMany) Take(count int) orgdevicesToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgdevicesToOrgsFindMany) Cursor(cursor OrgdevicesCursorParam) orgdevicesToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgdevicesToOrgsFindMany) Exec(ctx context.Context) (
	[]OrgdevicesModel,
	error,
) {
	var v []OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgdevicesToOrgsFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgdevices,
	error,
) {
	var v []InnerOrgdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgdevicesToOrgsFindMany) Update(params ...OrgdevicesSetParam) orgdevicesToOrgsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgdevices"

	r.query.Outputs = countOutput

	var v orgdevicesToOrgsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgdevicesToOrgsUpdateMany struct {
	query builder.Query
}

func (r orgdevicesToOrgsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesToOrgsUpdateMany) orgdevicesModel() {}

func (r orgdevicesToOrgsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesToOrgsUpdateMany) Tx() OrgdevicesManyTxResult {
	v := newOrgdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgdevicesToOrgsFindMany) Delete() orgdevicesToOrgsDeleteMany {
	var v orgdevicesToOrgsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgdevices"

	v.query.Outputs = countOutput

	return v
}

type orgdevicesToOrgsDeleteMany struct {
	query builder.Query
}

func (r orgdevicesToOrgsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgdevicesToOrgsDeleteMany) orgdevicesModel() {}

func (r orgdevicesToOrgsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesToOrgsDeleteMany) Tx() OrgdevicesManyTxResult {
	v := newOrgdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgdevicesFindUnique struct {
	query builder.Query
}

func (r orgdevicesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgdevicesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesFindUnique) with()               {}
func (r orgdevicesFindUnique) orgdevicesModel()    {}
func (r orgdevicesFindUnique) orgdevicesRelation() {}

func (r orgdevicesActions) FindUnique(
	params OrgdevicesEqualsUniqueWhereParam,
) orgdevicesFindUnique {
	var v orgdevicesFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "orgdevices"
	v.query.Outputs = orgdevicesOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r orgdevicesFindUnique) With(params ...OrgdevicesRelationWith) orgdevicesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgdevicesFindUnique) Select(params ...orgdevicesPrismaFields) orgdevicesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesFindUnique) Omit(params ...orgdevicesPrismaFields) orgdevicesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesFindUnique) Exec(ctx context.Context) (
	*OrgdevicesModel,
	error,
) {
	var v *OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgdevicesFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgdevices,
	error,
) {
	var v *InnerOrgdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgdevicesFindUnique) Update(params ...OrgdevicesSetParam) orgdevicesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgdevices"

	var v orgdevicesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgdevicesUpdateUnique struct {
	query builder.Query
}

func (r orgdevicesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesUpdateUnique) orgdevicesModel() {}

func (r orgdevicesUpdateUnique) Exec(ctx context.Context) (*OrgdevicesModel, error) {
	var v OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesUpdateUnique) Tx() OrgdevicesUniqueTxResult {
	v := newOrgdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgdevicesFindUnique) Delete() orgdevicesDeleteUnique {
	var v orgdevicesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgdevices"

	return v
}

type orgdevicesDeleteUnique struct {
	query builder.Query
}

func (r orgdevicesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgdevicesDeleteUnique) orgdevicesModel() {}

func (r orgdevicesDeleteUnique) Exec(ctx context.Context) (*OrgdevicesModel, error) {
	var v OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesDeleteUnique) Tx() OrgdevicesUniqueTxResult {
	v := newOrgdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgdevicesFindFirst struct {
	query builder.Query
}

func (r orgdevicesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgdevicesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesFindFirst) with()               {}
func (r orgdevicesFindFirst) orgdevicesModel()    {}
func (r orgdevicesFindFirst) orgdevicesRelation() {}

func (r orgdevicesActions) FindFirst(
	params ...OrgdevicesWhereParam,
) orgdevicesFindFirst {
	var v orgdevicesFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "orgdevices"
	v.query.Outputs = orgdevicesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orgdevicesFindFirst) With(params ...OrgdevicesRelationWith) orgdevicesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgdevicesFindFirst) Select(params ...orgdevicesPrismaFields) orgdevicesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesFindFirst) Omit(params ...orgdevicesPrismaFields) orgdevicesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesFindFirst) OrderBy(params ...OrgdevicesOrderByParam) orgdevicesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgdevicesFindFirst) Skip(count int) orgdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgdevicesFindFirst) Take(count int) orgdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgdevicesFindFirst) Cursor(cursor OrgdevicesCursorParam) orgdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgdevicesFindFirst) Exec(ctx context.Context) (
	*OrgdevicesModel,
	error,
) {
	var v *OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgdevicesFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgdevices,
	error,
) {
	var v *InnerOrgdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgdevicesFindMany struct {
	query builder.Query
}

func (r orgdevicesFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgdevicesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesFindMany) with()               {}
func (r orgdevicesFindMany) orgdevicesModel()    {}
func (r orgdevicesFindMany) orgdevicesRelation() {}

func (r orgdevicesActions) FindMany(
	params ...OrgdevicesWhereParam,
) orgdevicesFindMany {
	var v orgdevicesFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "orgdevices"
	v.query.Outputs = orgdevicesOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orgdevicesFindMany) With(params ...OrgdevicesRelationWith) orgdevicesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgdevicesFindMany) Select(params ...orgdevicesPrismaFields) orgdevicesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesFindMany) Omit(params ...orgdevicesPrismaFields) orgdevicesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgdevicesOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgdevicesFindMany) OrderBy(params ...OrgdevicesOrderByParam) orgdevicesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgdevicesFindMany) Skip(count int) orgdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgdevicesFindMany) Take(count int) orgdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgdevicesFindMany) Cursor(cursor OrgdevicesCursorParam) orgdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgdevicesFindMany) Exec(ctx context.Context) (
	[]OrgdevicesModel,
	error,
) {
	var v []OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgdevicesFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgdevices,
	error,
) {
	var v []InnerOrgdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgdevicesFindMany) Update(params ...OrgdevicesSetParam) orgdevicesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgdevices"

	r.query.Outputs = countOutput

	var v orgdevicesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgdevicesUpdateMany struct {
	query builder.Query
}

func (r orgdevicesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesUpdateMany) orgdevicesModel() {}

func (r orgdevicesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesUpdateMany) Tx() OrgdevicesManyTxResult {
	v := newOrgdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgdevicesFindMany) Delete() orgdevicesDeleteMany {
	var v orgdevicesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgdevices"

	v.query.Outputs = countOutput

	return v
}

type orgdevicesDeleteMany struct {
	query builder.Query
}

func (r orgdevicesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgdevicesDeleteMany) orgdevicesModel() {}

func (r orgdevicesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesDeleteMany) Tx() OrgdevicesManyTxResult {
	v := newOrgdevicesManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgrgroupToOrgsFindUnique struct {
	query builder.Query
}

func (r orgrgroupToOrgsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgrgroupToOrgsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupToOrgsFindUnique) with()              {}
func (r orgrgroupToOrgsFindUnique) orgrgroupModel()    {}
func (r orgrgroupToOrgsFindUnique) orgrgroupRelation() {}

func (r orgrgroupToOrgsFindUnique) With(params ...OrgsRelationWith) orgrgroupToOrgsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgrgroupToOrgsFindUnique) Select(params ...orgrgroupPrismaFields) orgrgroupToOrgsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupToOrgsFindUnique) Omit(params ...orgrgroupPrismaFields) orgrgroupToOrgsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgrgroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupToOrgsFindUnique) Exec(ctx context.Context) (
	*OrgrgroupModel,
	error,
) {
	var v *OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgrgroupToOrgsFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgrgroup,
	error,
) {
	var v *InnerOrgrgroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgrgroupToOrgsFindUnique) Update(params ...OrgrgroupSetParam) orgrgroupToOrgsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgrgroup"

	var v orgrgroupToOrgsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgrgroupToOrgsUpdateUnique struct {
	query builder.Query
}

func (r orgrgroupToOrgsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupToOrgsUpdateUnique) orgrgroupModel() {}

func (r orgrgroupToOrgsUpdateUnique) Exec(ctx context.Context) (*OrgrgroupModel, error) {
	var v OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupToOrgsUpdateUnique) Tx() OrgrgroupUniqueTxResult {
	v := newOrgrgroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgrgroupToOrgsFindUnique) Delete() orgrgroupToOrgsDeleteUnique {
	var v orgrgroupToOrgsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgrgroup"

	return v
}

type orgrgroupToOrgsDeleteUnique struct {
	query builder.Query
}

func (r orgrgroupToOrgsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgrgroupToOrgsDeleteUnique) orgrgroupModel() {}

func (r orgrgroupToOrgsDeleteUnique) Exec(ctx context.Context) (*OrgrgroupModel, error) {
	var v OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupToOrgsDeleteUnique) Tx() OrgrgroupUniqueTxResult {
	v := newOrgrgroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgrgroupToOrgsFindFirst struct {
	query builder.Query
}

func (r orgrgroupToOrgsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgrgroupToOrgsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupToOrgsFindFirst) with()              {}
func (r orgrgroupToOrgsFindFirst) orgrgroupModel()    {}
func (r orgrgroupToOrgsFindFirst) orgrgroupRelation() {}

func (r orgrgroupToOrgsFindFirst) With(params ...OrgsRelationWith) orgrgroupToOrgsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgrgroupToOrgsFindFirst) Select(params ...orgrgroupPrismaFields) orgrgroupToOrgsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupToOrgsFindFirst) Omit(params ...orgrgroupPrismaFields) orgrgroupToOrgsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgrgroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupToOrgsFindFirst) OrderBy(params ...OrgsOrderByParam) orgrgroupToOrgsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgrgroupToOrgsFindFirst) Skip(count int) orgrgroupToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgrgroupToOrgsFindFirst) Take(count int) orgrgroupToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgrgroupToOrgsFindFirst) Cursor(cursor OrgrgroupCursorParam) orgrgroupToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgrgroupToOrgsFindFirst) Exec(ctx context.Context) (
	*OrgrgroupModel,
	error,
) {
	var v *OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgrgroupToOrgsFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgrgroup,
	error,
) {
	var v *InnerOrgrgroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgrgroupToOrgsFindMany struct {
	query builder.Query
}

func (r orgrgroupToOrgsFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgrgroupToOrgsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupToOrgsFindMany) with()              {}
func (r orgrgroupToOrgsFindMany) orgrgroupModel()    {}
func (r orgrgroupToOrgsFindMany) orgrgroupRelation() {}

func (r orgrgroupToOrgsFindMany) With(params ...OrgsRelationWith) orgrgroupToOrgsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgrgroupToOrgsFindMany) Select(params ...orgrgroupPrismaFields) orgrgroupToOrgsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupToOrgsFindMany) Omit(params ...orgrgroupPrismaFields) orgrgroupToOrgsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgrgroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupToOrgsFindMany) OrderBy(params ...OrgsOrderByParam) orgrgroupToOrgsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgrgroupToOrgsFindMany) Skip(count int) orgrgroupToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgrgroupToOrgsFindMany) Take(count int) orgrgroupToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgrgroupToOrgsFindMany) Cursor(cursor OrgrgroupCursorParam) orgrgroupToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgrgroupToOrgsFindMany) Exec(ctx context.Context) (
	[]OrgrgroupModel,
	error,
) {
	var v []OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgrgroupToOrgsFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgrgroup,
	error,
) {
	var v []InnerOrgrgroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgrgroupToOrgsFindMany) Update(params ...OrgrgroupSetParam) orgrgroupToOrgsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgrgroup"

	r.query.Outputs = countOutput

	var v orgrgroupToOrgsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgrgroupToOrgsUpdateMany struct {
	query builder.Query
}

func (r orgrgroupToOrgsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupToOrgsUpdateMany) orgrgroupModel() {}

func (r orgrgroupToOrgsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupToOrgsUpdateMany) Tx() OrgrgroupManyTxResult {
	v := newOrgrgroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgrgroupToOrgsFindMany) Delete() orgrgroupToOrgsDeleteMany {
	var v orgrgroupToOrgsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgrgroup"

	v.query.Outputs = countOutput

	return v
}

type orgrgroupToOrgsDeleteMany struct {
	query builder.Query
}

func (r orgrgroupToOrgsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgrgroupToOrgsDeleteMany) orgrgroupModel() {}

func (r orgrgroupToOrgsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupToOrgsDeleteMany) Tx() OrgrgroupManyTxResult {
	v := newOrgrgroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgrgroupToGroupsFindUnique struct {
	query builder.Query
}

func (r orgrgroupToGroupsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgrgroupToGroupsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupToGroupsFindUnique) with()              {}
func (r orgrgroupToGroupsFindUnique) orgrgroupModel()    {}
func (r orgrgroupToGroupsFindUnique) orgrgroupRelation() {}

func (r orgrgroupToGroupsFindUnique) With(params ...GroupsRelationWith) orgrgroupToGroupsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgrgroupToGroupsFindUnique) Select(params ...orgrgroupPrismaFields) orgrgroupToGroupsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupToGroupsFindUnique) Omit(params ...orgrgroupPrismaFields) orgrgroupToGroupsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgrgroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupToGroupsFindUnique) Exec(ctx context.Context) (
	*OrgrgroupModel,
	error,
) {
	var v *OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgrgroupToGroupsFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgrgroup,
	error,
) {
	var v *InnerOrgrgroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgrgroupToGroupsFindUnique) Update(params ...OrgrgroupSetParam) orgrgroupToGroupsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgrgroup"

	var v orgrgroupToGroupsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgrgroupToGroupsUpdateUnique struct {
	query builder.Query
}

func (r orgrgroupToGroupsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupToGroupsUpdateUnique) orgrgroupModel() {}

func (r orgrgroupToGroupsUpdateUnique) Exec(ctx context.Context) (*OrgrgroupModel, error) {
	var v OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupToGroupsUpdateUnique) Tx() OrgrgroupUniqueTxResult {
	v := newOrgrgroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgrgroupToGroupsFindUnique) Delete() orgrgroupToGroupsDeleteUnique {
	var v orgrgroupToGroupsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgrgroup"

	return v
}

type orgrgroupToGroupsDeleteUnique struct {
	query builder.Query
}

func (r orgrgroupToGroupsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgrgroupToGroupsDeleteUnique) orgrgroupModel() {}

func (r orgrgroupToGroupsDeleteUnique) Exec(ctx context.Context) (*OrgrgroupModel, error) {
	var v OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupToGroupsDeleteUnique) Tx() OrgrgroupUniqueTxResult {
	v := newOrgrgroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgrgroupToGroupsFindFirst struct {
	query builder.Query
}

func (r orgrgroupToGroupsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgrgroupToGroupsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupToGroupsFindFirst) with()              {}
func (r orgrgroupToGroupsFindFirst) orgrgroupModel()    {}
func (r orgrgroupToGroupsFindFirst) orgrgroupRelation() {}

func (r orgrgroupToGroupsFindFirst) With(params ...GroupsRelationWith) orgrgroupToGroupsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgrgroupToGroupsFindFirst) Select(params ...orgrgroupPrismaFields) orgrgroupToGroupsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupToGroupsFindFirst) Omit(params ...orgrgroupPrismaFields) orgrgroupToGroupsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgrgroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupToGroupsFindFirst) OrderBy(params ...GroupsOrderByParam) orgrgroupToGroupsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgrgroupToGroupsFindFirst) Skip(count int) orgrgroupToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgrgroupToGroupsFindFirst) Take(count int) orgrgroupToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgrgroupToGroupsFindFirst) Cursor(cursor OrgrgroupCursorParam) orgrgroupToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgrgroupToGroupsFindFirst) Exec(ctx context.Context) (
	*OrgrgroupModel,
	error,
) {
	var v *OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgrgroupToGroupsFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgrgroup,
	error,
) {
	var v *InnerOrgrgroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgrgroupToGroupsFindMany struct {
	query builder.Query
}

func (r orgrgroupToGroupsFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgrgroupToGroupsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupToGroupsFindMany) with()              {}
func (r orgrgroupToGroupsFindMany) orgrgroupModel()    {}
func (r orgrgroupToGroupsFindMany) orgrgroupRelation() {}

func (r orgrgroupToGroupsFindMany) With(params ...GroupsRelationWith) orgrgroupToGroupsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgrgroupToGroupsFindMany) Select(params ...orgrgroupPrismaFields) orgrgroupToGroupsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupToGroupsFindMany) Omit(params ...orgrgroupPrismaFields) orgrgroupToGroupsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgrgroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupToGroupsFindMany) OrderBy(params ...GroupsOrderByParam) orgrgroupToGroupsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgrgroupToGroupsFindMany) Skip(count int) orgrgroupToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgrgroupToGroupsFindMany) Take(count int) orgrgroupToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgrgroupToGroupsFindMany) Cursor(cursor OrgrgroupCursorParam) orgrgroupToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgrgroupToGroupsFindMany) Exec(ctx context.Context) (
	[]OrgrgroupModel,
	error,
) {
	var v []OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgrgroupToGroupsFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgrgroup,
	error,
) {
	var v []InnerOrgrgroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgrgroupToGroupsFindMany) Update(params ...OrgrgroupSetParam) orgrgroupToGroupsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgrgroup"

	r.query.Outputs = countOutput

	var v orgrgroupToGroupsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgrgroupToGroupsUpdateMany struct {
	query builder.Query
}

func (r orgrgroupToGroupsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupToGroupsUpdateMany) orgrgroupModel() {}

func (r orgrgroupToGroupsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupToGroupsUpdateMany) Tx() OrgrgroupManyTxResult {
	v := newOrgrgroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgrgroupToGroupsFindMany) Delete() orgrgroupToGroupsDeleteMany {
	var v orgrgroupToGroupsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgrgroup"

	v.query.Outputs = countOutput

	return v
}

type orgrgroupToGroupsDeleteMany struct {
	query builder.Query
}

func (r orgrgroupToGroupsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgrgroupToGroupsDeleteMany) orgrgroupModel() {}

func (r orgrgroupToGroupsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupToGroupsDeleteMany) Tx() OrgrgroupManyTxResult {
	v := newOrgrgroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgrgroupFindUnique struct {
	query builder.Query
}

func (r orgrgroupFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgrgroupFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupFindUnique) with()              {}
func (r orgrgroupFindUnique) orgrgroupModel()    {}
func (r orgrgroupFindUnique) orgrgroupRelation() {}

func (r orgrgroupActions) FindUnique(
	params OrgrgroupEqualsUniqueWhereParam,
) orgrgroupFindUnique {
	var v orgrgroupFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "orgrgroup"
	v.query.Outputs = orgrgroupOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r orgrgroupFindUnique) With(params ...OrgrgroupRelationWith) orgrgroupFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgrgroupFindUnique) Select(params ...orgrgroupPrismaFields) orgrgroupFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupFindUnique) Omit(params ...orgrgroupPrismaFields) orgrgroupFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgrgroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupFindUnique) Exec(ctx context.Context) (
	*OrgrgroupModel,
	error,
) {
	var v *OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgrgroupFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgrgroup,
	error,
) {
	var v *InnerOrgrgroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgrgroupFindUnique) Update(params ...OrgrgroupSetParam) orgrgroupUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgrgroup"

	var v orgrgroupUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgrgroupUpdateUnique struct {
	query builder.Query
}

func (r orgrgroupUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupUpdateUnique) orgrgroupModel() {}

func (r orgrgroupUpdateUnique) Exec(ctx context.Context) (*OrgrgroupModel, error) {
	var v OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupUpdateUnique) Tx() OrgrgroupUniqueTxResult {
	v := newOrgrgroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgrgroupFindUnique) Delete() orgrgroupDeleteUnique {
	var v orgrgroupDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgrgroup"

	return v
}

type orgrgroupDeleteUnique struct {
	query builder.Query
}

func (r orgrgroupDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgrgroupDeleteUnique) orgrgroupModel() {}

func (r orgrgroupDeleteUnique) Exec(ctx context.Context) (*OrgrgroupModel, error) {
	var v OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupDeleteUnique) Tx() OrgrgroupUniqueTxResult {
	v := newOrgrgroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgrgroupFindFirst struct {
	query builder.Query
}

func (r orgrgroupFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgrgroupFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupFindFirst) with()              {}
func (r orgrgroupFindFirst) orgrgroupModel()    {}
func (r orgrgroupFindFirst) orgrgroupRelation() {}

func (r orgrgroupActions) FindFirst(
	params ...OrgrgroupWhereParam,
) orgrgroupFindFirst {
	var v orgrgroupFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "orgrgroup"
	v.query.Outputs = orgrgroupOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orgrgroupFindFirst) With(params ...OrgrgroupRelationWith) orgrgroupFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgrgroupFindFirst) Select(params ...orgrgroupPrismaFields) orgrgroupFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupFindFirst) Omit(params ...orgrgroupPrismaFields) orgrgroupFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgrgroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupFindFirst) OrderBy(params ...OrgrgroupOrderByParam) orgrgroupFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgrgroupFindFirst) Skip(count int) orgrgroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgrgroupFindFirst) Take(count int) orgrgroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgrgroupFindFirst) Cursor(cursor OrgrgroupCursorParam) orgrgroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgrgroupFindFirst) Exec(ctx context.Context) (
	*OrgrgroupModel,
	error,
) {
	var v *OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgrgroupFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgrgroup,
	error,
) {
	var v *InnerOrgrgroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgrgroupFindMany struct {
	query builder.Query
}

func (r orgrgroupFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgrgroupFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupFindMany) with()              {}
func (r orgrgroupFindMany) orgrgroupModel()    {}
func (r orgrgroupFindMany) orgrgroupRelation() {}

func (r orgrgroupActions) FindMany(
	params ...OrgrgroupWhereParam,
) orgrgroupFindMany {
	var v orgrgroupFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "orgrgroup"
	v.query.Outputs = orgrgroupOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orgrgroupFindMany) With(params ...OrgrgroupRelationWith) orgrgroupFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgrgroupFindMany) Select(params ...orgrgroupPrismaFields) orgrgroupFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupFindMany) Omit(params ...orgrgroupPrismaFields) orgrgroupFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgrgroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgrgroupFindMany) OrderBy(params ...OrgrgroupOrderByParam) orgrgroupFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgrgroupFindMany) Skip(count int) orgrgroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgrgroupFindMany) Take(count int) orgrgroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgrgroupFindMany) Cursor(cursor OrgrgroupCursorParam) orgrgroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgrgroupFindMany) Exec(ctx context.Context) (
	[]OrgrgroupModel,
	error,
) {
	var v []OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgrgroupFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgrgroup,
	error,
) {
	var v []InnerOrgrgroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgrgroupFindMany) Update(params ...OrgrgroupSetParam) orgrgroupUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgrgroup"

	r.query.Outputs = countOutput

	var v orgrgroupUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgrgroupUpdateMany struct {
	query builder.Query
}

func (r orgrgroupUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupUpdateMany) orgrgroupModel() {}

func (r orgrgroupUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupUpdateMany) Tx() OrgrgroupManyTxResult {
	v := newOrgrgroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgrgroupFindMany) Delete() orgrgroupDeleteMany {
	var v orgrgroupDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgrgroup"

	v.query.Outputs = countOutput

	return v
}

type orgrgroupDeleteMany struct {
	query builder.Query
}

func (r orgrgroupDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgrgroupDeleteMany) orgrgroupModel() {}

func (r orgrgroupDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupDeleteMany) Tx() OrgrgroupManyTxResult {
	v := newOrgrgroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToGroupdevicesFindUnique struct {
	query builder.Query
}

func (r orgsToGroupdevicesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgsToGroupdevicesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupdevicesFindUnique) with()         {}
func (r orgsToGroupdevicesFindUnique) orgsModel()    {}
func (r orgsToGroupdevicesFindUnique) orgsRelation() {}

func (r orgsToGroupdevicesFindUnique) With(params ...GroupdevicesRelationWith) orgsToGroupdevicesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToGroupdevicesFindUnique) Select(params ...orgsPrismaFields) orgsToGroupdevicesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupdevicesFindUnique) Omit(params ...orgsPrismaFields) orgsToGroupdevicesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupdevicesFindUnique) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToGroupdevicesFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToGroupdevicesFindUnique) Update(params ...OrgsSetParam) orgsToGroupdevicesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgs"

	var v orgsToGroupdevicesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToGroupdevicesUpdateUnique struct {
	query builder.Query
}

func (r orgsToGroupdevicesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupdevicesUpdateUnique) orgsModel() {}

func (r orgsToGroupdevicesUpdateUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGroupdevicesUpdateUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToGroupdevicesFindUnique) Delete() orgsToGroupdevicesDeleteUnique {
	var v orgsToGroupdevicesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgs"

	return v
}

type orgsToGroupdevicesDeleteUnique struct {
	query builder.Query
}

func (r orgsToGroupdevicesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToGroupdevicesDeleteUnique) orgsModel() {}

func (r orgsToGroupdevicesDeleteUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGroupdevicesDeleteUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToGroupdevicesFindFirst struct {
	query builder.Query
}

func (r orgsToGroupdevicesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgsToGroupdevicesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupdevicesFindFirst) with()         {}
func (r orgsToGroupdevicesFindFirst) orgsModel()    {}
func (r orgsToGroupdevicesFindFirst) orgsRelation() {}

func (r orgsToGroupdevicesFindFirst) With(params ...GroupdevicesRelationWith) orgsToGroupdevicesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToGroupdevicesFindFirst) Select(params ...orgsPrismaFields) orgsToGroupdevicesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupdevicesFindFirst) Omit(params ...orgsPrismaFields) orgsToGroupdevicesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupdevicesFindFirst) OrderBy(params ...GroupdevicesOrderByParam) orgsToGroupdevicesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToGroupdevicesFindFirst) Skip(count int) orgsToGroupdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToGroupdevicesFindFirst) Take(count int) orgsToGroupdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToGroupdevicesFindFirst) Cursor(cursor OrgsCursorParam) orgsToGroupdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToGroupdevicesFindFirst) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToGroupdevicesFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgsToGroupdevicesFindMany struct {
	query builder.Query
}

func (r orgsToGroupdevicesFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgsToGroupdevicesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupdevicesFindMany) with()         {}
func (r orgsToGroupdevicesFindMany) orgsModel()    {}
func (r orgsToGroupdevicesFindMany) orgsRelation() {}

func (r orgsToGroupdevicesFindMany) With(params ...GroupdevicesRelationWith) orgsToGroupdevicesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToGroupdevicesFindMany) Select(params ...orgsPrismaFields) orgsToGroupdevicesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupdevicesFindMany) Omit(params ...orgsPrismaFields) orgsToGroupdevicesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupdevicesFindMany) OrderBy(params ...GroupdevicesOrderByParam) orgsToGroupdevicesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToGroupdevicesFindMany) Skip(count int) orgsToGroupdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToGroupdevicesFindMany) Take(count int) orgsToGroupdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToGroupdevicesFindMany) Cursor(cursor OrgsCursorParam) orgsToGroupdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToGroupdevicesFindMany) Exec(ctx context.Context) (
	[]OrgsModel,
	error,
) {
	var v []OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToGroupdevicesFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgs,
	error,
) {
	var v []InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToGroupdevicesFindMany) Update(params ...OrgsSetParam) orgsToGroupdevicesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgs"

	r.query.Outputs = countOutput

	var v orgsToGroupdevicesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToGroupdevicesUpdateMany struct {
	query builder.Query
}

func (r orgsToGroupdevicesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupdevicesUpdateMany) orgsModel() {}

func (r orgsToGroupdevicesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGroupdevicesUpdateMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToGroupdevicesFindMany) Delete() orgsToGroupdevicesDeleteMany {
	var v orgsToGroupdevicesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgs"

	v.query.Outputs = countOutput

	return v
}

type orgsToGroupdevicesDeleteMany struct {
	query builder.Query
}

func (r orgsToGroupdevicesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToGroupdevicesDeleteMany) orgsModel() {}

func (r orgsToGroupdevicesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGroupdevicesDeleteMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToGroupsFindUnique struct {
	query builder.Query
}

func (r orgsToGroupsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgsToGroupsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupsFindUnique) with()         {}
func (r orgsToGroupsFindUnique) orgsModel()    {}
func (r orgsToGroupsFindUnique) orgsRelation() {}

func (r orgsToGroupsFindUnique) With(params ...GroupsRelationWith) orgsToGroupsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToGroupsFindUnique) Select(params ...orgsPrismaFields) orgsToGroupsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupsFindUnique) Omit(params ...orgsPrismaFields) orgsToGroupsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupsFindUnique) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToGroupsFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToGroupsFindUnique) Update(params ...OrgsSetParam) orgsToGroupsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgs"

	var v orgsToGroupsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToGroupsUpdateUnique struct {
	query builder.Query
}

func (r orgsToGroupsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupsUpdateUnique) orgsModel() {}

func (r orgsToGroupsUpdateUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGroupsUpdateUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToGroupsFindUnique) Delete() orgsToGroupsDeleteUnique {
	var v orgsToGroupsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgs"

	return v
}

type orgsToGroupsDeleteUnique struct {
	query builder.Query
}

func (r orgsToGroupsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToGroupsDeleteUnique) orgsModel() {}

func (r orgsToGroupsDeleteUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGroupsDeleteUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToGroupsFindFirst struct {
	query builder.Query
}

func (r orgsToGroupsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgsToGroupsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupsFindFirst) with()         {}
func (r orgsToGroupsFindFirst) orgsModel()    {}
func (r orgsToGroupsFindFirst) orgsRelation() {}

func (r orgsToGroupsFindFirst) With(params ...GroupsRelationWith) orgsToGroupsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToGroupsFindFirst) Select(params ...orgsPrismaFields) orgsToGroupsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupsFindFirst) Omit(params ...orgsPrismaFields) orgsToGroupsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupsFindFirst) OrderBy(params ...GroupsOrderByParam) orgsToGroupsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToGroupsFindFirst) Skip(count int) orgsToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToGroupsFindFirst) Take(count int) orgsToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToGroupsFindFirst) Cursor(cursor OrgsCursorParam) orgsToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToGroupsFindFirst) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToGroupsFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgsToGroupsFindMany struct {
	query builder.Query
}

func (r orgsToGroupsFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgsToGroupsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupsFindMany) with()         {}
func (r orgsToGroupsFindMany) orgsModel()    {}
func (r orgsToGroupsFindMany) orgsRelation() {}

func (r orgsToGroupsFindMany) With(params ...GroupsRelationWith) orgsToGroupsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToGroupsFindMany) Select(params ...orgsPrismaFields) orgsToGroupsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupsFindMany) Omit(params ...orgsPrismaFields) orgsToGroupsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupsFindMany) OrderBy(params ...GroupsOrderByParam) orgsToGroupsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToGroupsFindMany) Skip(count int) orgsToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToGroupsFindMany) Take(count int) orgsToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToGroupsFindMany) Cursor(cursor OrgsCursorParam) orgsToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToGroupsFindMany) Exec(ctx context.Context) (
	[]OrgsModel,
	error,
) {
	var v []OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToGroupsFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgs,
	error,
) {
	var v []InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToGroupsFindMany) Update(params ...OrgsSetParam) orgsToGroupsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgs"

	r.query.Outputs = countOutput

	var v orgsToGroupsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToGroupsUpdateMany struct {
	query builder.Query
}

func (r orgsToGroupsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupsUpdateMany) orgsModel() {}

func (r orgsToGroupsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGroupsUpdateMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToGroupsFindMany) Delete() orgsToGroupsDeleteMany {
	var v orgsToGroupsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgs"

	v.query.Outputs = countOutput

	return v
}

type orgsToGroupsDeleteMany struct {
	query builder.Query
}

func (r orgsToGroupsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToGroupsDeleteMany) orgsModel() {}

func (r orgsToGroupsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGroupsDeleteMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToGrouptreeFindUnique struct {
	query builder.Query
}

func (r orgsToGrouptreeFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgsToGrouptreeFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGrouptreeFindUnique) with()         {}
func (r orgsToGrouptreeFindUnique) orgsModel()    {}
func (r orgsToGrouptreeFindUnique) orgsRelation() {}

func (r orgsToGrouptreeFindUnique) With(params ...GrouptreeRelationWith) orgsToGrouptreeFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToGrouptreeFindUnique) Select(params ...orgsPrismaFields) orgsToGrouptreeFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGrouptreeFindUnique) Omit(params ...orgsPrismaFields) orgsToGrouptreeFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGrouptreeFindUnique) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToGrouptreeFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToGrouptreeFindUnique) Update(params ...OrgsSetParam) orgsToGrouptreeUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgs"

	var v orgsToGrouptreeUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToGrouptreeUpdateUnique struct {
	query builder.Query
}

func (r orgsToGrouptreeUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGrouptreeUpdateUnique) orgsModel() {}

func (r orgsToGrouptreeUpdateUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGrouptreeUpdateUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToGrouptreeFindUnique) Delete() orgsToGrouptreeDeleteUnique {
	var v orgsToGrouptreeDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgs"

	return v
}

type orgsToGrouptreeDeleteUnique struct {
	query builder.Query
}

func (r orgsToGrouptreeDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToGrouptreeDeleteUnique) orgsModel() {}

func (r orgsToGrouptreeDeleteUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGrouptreeDeleteUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToGrouptreeFindFirst struct {
	query builder.Query
}

func (r orgsToGrouptreeFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgsToGrouptreeFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGrouptreeFindFirst) with()         {}
func (r orgsToGrouptreeFindFirst) orgsModel()    {}
func (r orgsToGrouptreeFindFirst) orgsRelation() {}

func (r orgsToGrouptreeFindFirst) With(params ...GrouptreeRelationWith) orgsToGrouptreeFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToGrouptreeFindFirst) Select(params ...orgsPrismaFields) orgsToGrouptreeFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGrouptreeFindFirst) Omit(params ...orgsPrismaFields) orgsToGrouptreeFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGrouptreeFindFirst) OrderBy(params ...GrouptreeOrderByParam) orgsToGrouptreeFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToGrouptreeFindFirst) Skip(count int) orgsToGrouptreeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToGrouptreeFindFirst) Take(count int) orgsToGrouptreeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToGrouptreeFindFirst) Cursor(cursor OrgsCursorParam) orgsToGrouptreeFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToGrouptreeFindFirst) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToGrouptreeFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgsToGrouptreeFindMany struct {
	query builder.Query
}

func (r orgsToGrouptreeFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgsToGrouptreeFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGrouptreeFindMany) with()         {}
func (r orgsToGrouptreeFindMany) orgsModel()    {}
func (r orgsToGrouptreeFindMany) orgsRelation() {}

func (r orgsToGrouptreeFindMany) With(params ...GrouptreeRelationWith) orgsToGrouptreeFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToGrouptreeFindMany) Select(params ...orgsPrismaFields) orgsToGrouptreeFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGrouptreeFindMany) Omit(params ...orgsPrismaFields) orgsToGrouptreeFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGrouptreeFindMany) OrderBy(params ...GrouptreeOrderByParam) orgsToGrouptreeFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToGrouptreeFindMany) Skip(count int) orgsToGrouptreeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToGrouptreeFindMany) Take(count int) orgsToGrouptreeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToGrouptreeFindMany) Cursor(cursor OrgsCursorParam) orgsToGrouptreeFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToGrouptreeFindMany) Exec(ctx context.Context) (
	[]OrgsModel,
	error,
) {
	var v []OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToGrouptreeFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgs,
	error,
) {
	var v []InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToGrouptreeFindMany) Update(params ...OrgsSetParam) orgsToGrouptreeUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgs"

	r.query.Outputs = countOutput

	var v orgsToGrouptreeUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToGrouptreeUpdateMany struct {
	query builder.Query
}

func (r orgsToGrouptreeUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGrouptreeUpdateMany) orgsModel() {}

func (r orgsToGrouptreeUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGrouptreeUpdateMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToGrouptreeFindMany) Delete() orgsToGrouptreeDeleteMany {
	var v orgsToGrouptreeDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgs"

	v.query.Outputs = countOutput

	return v
}

type orgsToGrouptreeDeleteMany struct {
	query builder.Query
}

func (r orgsToGrouptreeDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToGrouptreeDeleteMany) orgsModel() {}

func (r orgsToGrouptreeDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGrouptreeDeleteMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToGroupuserpermsFindUnique struct {
	query builder.Query
}

func (r orgsToGroupuserpermsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgsToGroupuserpermsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupuserpermsFindUnique) with()         {}
func (r orgsToGroupuserpermsFindUnique) orgsModel()    {}
func (r orgsToGroupuserpermsFindUnique) orgsRelation() {}

func (r orgsToGroupuserpermsFindUnique) With(params ...GroupuserpermsRelationWith) orgsToGroupuserpermsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToGroupuserpermsFindUnique) Select(params ...orgsPrismaFields) orgsToGroupuserpermsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupuserpermsFindUnique) Omit(params ...orgsPrismaFields) orgsToGroupuserpermsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupuserpermsFindUnique) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToGroupuserpermsFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToGroupuserpermsFindUnique) Update(params ...OrgsSetParam) orgsToGroupuserpermsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgs"

	var v orgsToGroupuserpermsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToGroupuserpermsUpdateUnique struct {
	query builder.Query
}

func (r orgsToGroupuserpermsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupuserpermsUpdateUnique) orgsModel() {}

func (r orgsToGroupuserpermsUpdateUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGroupuserpermsUpdateUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToGroupuserpermsFindUnique) Delete() orgsToGroupuserpermsDeleteUnique {
	var v orgsToGroupuserpermsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgs"

	return v
}

type orgsToGroupuserpermsDeleteUnique struct {
	query builder.Query
}

func (r orgsToGroupuserpermsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToGroupuserpermsDeleteUnique) orgsModel() {}

func (r orgsToGroupuserpermsDeleteUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGroupuserpermsDeleteUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToGroupuserpermsFindFirst struct {
	query builder.Query
}

func (r orgsToGroupuserpermsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgsToGroupuserpermsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupuserpermsFindFirst) with()         {}
func (r orgsToGroupuserpermsFindFirst) orgsModel()    {}
func (r orgsToGroupuserpermsFindFirst) orgsRelation() {}

func (r orgsToGroupuserpermsFindFirst) With(params ...GroupuserpermsRelationWith) orgsToGroupuserpermsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToGroupuserpermsFindFirst) Select(params ...orgsPrismaFields) orgsToGroupuserpermsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupuserpermsFindFirst) Omit(params ...orgsPrismaFields) orgsToGroupuserpermsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupuserpermsFindFirst) OrderBy(params ...GroupuserpermsOrderByParam) orgsToGroupuserpermsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToGroupuserpermsFindFirst) Skip(count int) orgsToGroupuserpermsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToGroupuserpermsFindFirst) Take(count int) orgsToGroupuserpermsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToGroupuserpermsFindFirst) Cursor(cursor OrgsCursorParam) orgsToGroupuserpermsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToGroupuserpermsFindFirst) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToGroupuserpermsFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgsToGroupuserpermsFindMany struct {
	query builder.Query
}

func (r orgsToGroupuserpermsFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgsToGroupuserpermsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupuserpermsFindMany) with()         {}
func (r orgsToGroupuserpermsFindMany) orgsModel()    {}
func (r orgsToGroupuserpermsFindMany) orgsRelation() {}

func (r orgsToGroupuserpermsFindMany) With(params ...GroupuserpermsRelationWith) orgsToGroupuserpermsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToGroupuserpermsFindMany) Select(params ...orgsPrismaFields) orgsToGroupuserpermsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupuserpermsFindMany) Omit(params ...orgsPrismaFields) orgsToGroupuserpermsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToGroupuserpermsFindMany) OrderBy(params ...GroupuserpermsOrderByParam) orgsToGroupuserpermsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToGroupuserpermsFindMany) Skip(count int) orgsToGroupuserpermsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToGroupuserpermsFindMany) Take(count int) orgsToGroupuserpermsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToGroupuserpermsFindMany) Cursor(cursor OrgsCursorParam) orgsToGroupuserpermsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToGroupuserpermsFindMany) Exec(ctx context.Context) (
	[]OrgsModel,
	error,
) {
	var v []OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToGroupuserpermsFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgs,
	error,
) {
	var v []InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToGroupuserpermsFindMany) Update(params ...OrgsSetParam) orgsToGroupuserpermsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgs"

	r.query.Outputs = countOutput

	var v orgsToGroupuserpermsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToGroupuserpermsUpdateMany struct {
	query builder.Query
}

func (r orgsToGroupuserpermsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToGroupuserpermsUpdateMany) orgsModel() {}

func (r orgsToGroupuserpermsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGroupuserpermsUpdateMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToGroupuserpermsFindMany) Delete() orgsToGroupuserpermsDeleteMany {
	var v orgsToGroupuserpermsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgs"

	v.query.Outputs = countOutput

	return v
}

type orgsToGroupuserpermsDeleteMany struct {
	query builder.Query
}

func (r orgsToGroupuserpermsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToGroupuserpermsDeleteMany) orgsModel() {}

func (r orgsToGroupuserpermsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToGroupuserpermsDeleteMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToOrgdevicesFindUnique struct {
	query builder.Query
}

func (r orgsToOrgdevicesFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgsToOrgdevicesFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToOrgdevicesFindUnique) with()         {}
func (r orgsToOrgdevicesFindUnique) orgsModel()    {}
func (r orgsToOrgdevicesFindUnique) orgsRelation() {}

func (r orgsToOrgdevicesFindUnique) With(params ...OrgdevicesRelationWith) orgsToOrgdevicesFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToOrgdevicesFindUnique) Select(params ...orgsPrismaFields) orgsToOrgdevicesFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToOrgdevicesFindUnique) Omit(params ...orgsPrismaFields) orgsToOrgdevicesFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToOrgdevicesFindUnique) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToOrgdevicesFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToOrgdevicesFindUnique) Update(params ...OrgsSetParam) orgsToOrgdevicesUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgs"

	var v orgsToOrgdevicesUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToOrgdevicesUpdateUnique struct {
	query builder.Query
}

func (r orgsToOrgdevicesUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToOrgdevicesUpdateUnique) orgsModel() {}

func (r orgsToOrgdevicesUpdateUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToOrgdevicesUpdateUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToOrgdevicesFindUnique) Delete() orgsToOrgdevicesDeleteUnique {
	var v orgsToOrgdevicesDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgs"

	return v
}

type orgsToOrgdevicesDeleteUnique struct {
	query builder.Query
}

func (r orgsToOrgdevicesDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToOrgdevicesDeleteUnique) orgsModel() {}

func (r orgsToOrgdevicesDeleteUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToOrgdevicesDeleteUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToOrgdevicesFindFirst struct {
	query builder.Query
}

func (r orgsToOrgdevicesFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgsToOrgdevicesFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToOrgdevicesFindFirst) with()         {}
func (r orgsToOrgdevicesFindFirst) orgsModel()    {}
func (r orgsToOrgdevicesFindFirst) orgsRelation() {}

func (r orgsToOrgdevicesFindFirst) With(params ...OrgdevicesRelationWith) orgsToOrgdevicesFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToOrgdevicesFindFirst) Select(params ...orgsPrismaFields) orgsToOrgdevicesFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToOrgdevicesFindFirst) Omit(params ...orgsPrismaFields) orgsToOrgdevicesFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToOrgdevicesFindFirst) OrderBy(params ...OrgdevicesOrderByParam) orgsToOrgdevicesFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToOrgdevicesFindFirst) Skip(count int) orgsToOrgdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToOrgdevicesFindFirst) Take(count int) orgsToOrgdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToOrgdevicesFindFirst) Cursor(cursor OrgsCursorParam) orgsToOrgdevicesFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToOrgdevicesFindFirst) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToOrgdevicesFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgsToOrgdevicesFindMany struct {
	query builder.Query
}

func (r orgsToOrgdevicesFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgsToOrgdevicesFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToOrgdevicesFindMany) with()         {}
func (r orgsToOrgdevicesFindMany) orgsModel()    {}
func (r orgsToOrgdevicesFindMany) orgsRelation() {}

func (r orgsToOrgdevicesFindMany) With(params ...OrgdevicesRelationWith) orgsToOrgdevicesFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToOrgdevicesFindMany) Select(params ...orgsPrismaFields) orgsToOrgdevicesFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToOrgdevicesFindMany) Omit(params ...orgsPrismaFields) orgsToOrgdevicesFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToOrgdevicesFindMany) OrderBy(params ...OrgdevicesOrderByParam) orgsToOrgdevicesFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToOrgdevicesFindMany) Skip(count int) orgsToOrgdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToOrgdevicesFindMany) Take(count int) orgsToOrgdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToOrgdevicesFindMany) Cursor(cursor OrgsCursorParam) orgsToOrgdevicesFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToOrgdevicesFindMany) Exec(ctx context.Context) (
	[]OrgsModel,
	error,
) {
	var v []OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToOrgdevicesFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgs,
	error,
) {
	var v []InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToOrgdevicesFindMany) Update(params ...OrgsSetParam) orgsToOrgdevicesUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgs"

	r.query.Outputs = countOutput

	var v orgsToOrgdevicesUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToOrgdevicesUpdateMany struct {
	query builder.Query
}

func (r orgsToOrgdevicesUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToOrgdevicesUpdateMany) orgsModel() {}

func (r orgsToOrgdevicesUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToOrgdevicesUpdateMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToOrgdevicesFindMany) Delete() orgsToOrgdevicesDeleteMany {
	var v orgsToOrgdevicesDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgs"

	v.query.Outputs = countOutput

	return v
}

type orgsToOrgdevicesDeleteMany struct {
	query builder.Query
}

func (r orgsToOrgdevicesDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToOrgdevicesDeleteMany) orgsModel() {}

func (r orgsToOrgdevicesDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToOrgdevicesDeleteMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToOrgrgroupFindUnique struct {
	query builder.Query
}

func (r orgsToOrgrgroupFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgsToOrgrgroupFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToOrgrgroupFindUnique) with()         {}
func (r orgsToOrgrgroupFindUnique) orgsModel()    {}
func (r orgsToOrgrgroupFindUnique) orgsRelation() {}

func (r orgsToOrgrgroupFindUnique) With(params ...OrgrgroupRelationWith) orgsToOrgrgroupFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToOrgrgroupFindUnique) Select(params ...orgsPrismaFields) orgsToOrgrgroupFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToOrgrgroupFindUnique) Omit(params ...orgsPrismaFields) orgsToOrgrgroupFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToOrgrgroupFindUnique) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToOrgrgroupFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToOrgrgroupFindUnique) Update(params ...OrgsSetParam) orgsToOrgrgroupUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgs"

	var v orgsToOrgrgroupUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToOrgrgroupUpdateUnique struct {
	query builder.Query
}

func (r orgsToOrgrgroupUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToOrgrgroupUpdateUnique) orgsModel() {}

func (r orgsToOrgrgroupUpdateUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToOrgrgroupUpdateUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToOrgrgroupFindUnique) Delete() orgsToOrgrgroupDeleteUnique {
	var v orgsToOrgrgroupDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgs"

	return v
}

type orgsToOrgrgroupDeleteUnique struct {
	query builder.Query
}

func (r orgsToOrgrgroupDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToOrgrgroupDeleteUnique) orgsModel() {}

func (r orgsToOrgrgroupDeleteUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToOrgrgroupDeleteUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToOrgrgroupFindFirst struct {
	query builder.Query
}

func (r orgsToOrgrgroupFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgsToOrgrgroupFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToOrgrgroupFindFirst) with()         {}
func (r orgsToOrgrgroupFindFirst) orgsModel()    {}
func (r orgsToOrgrgroupFindFirst) orgsRelation() {}

func (r orgsToOrgrgroupFindFirst) With(params ...OrgrgroupRelationWith) orgsToOrgrgroupFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToOrgrgroupFindFirst) Select(params ...orgsPrismaFields) orgsToOrgrgroupFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToOrgrgroupFindFirst) Omit(params ...orgsPrismaFields) orgsToOrgrgroupFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToOrgrgroupFindFirst) OrderBy(params ...OrgrgroupOrderByParam) orgsToOrgrgroupFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToOrgrgroupFindFirst) Skip(count int) orgsToOrgrgroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToOrgrgroupFindFirst) Take(count int) orgsToOrgrgroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToOrgrgroupFindFirst) Cursor(cursor OrgsCursorParam) orgsToOrgrgroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToOrgrgroupFindFirst) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToOrgrgroupFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgsToOrgrgroupFindMany struct {
	query builder.Query
}

func (r orgsToOrgrgroupFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgsToOrgrgroupFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToOrgrgroupFindMany) with()         {}
func (r orgsToOrgrgroupFindMany) orgsModel()    {}
func (r orgsToOrgrgroupFindMany) orgsRelation() {}

func (r orgsToOrgrgroupFindMany) With(params ...OrgrgroupRelationWith) orgsToOrgrgroupFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToOrgrgroupFindMany) Select(params ...orgsPrismaFields) orgsToOrgrgroupFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToOrgrgroupFindMany) Omit(params ...orgsPrismaFields) orgsToOrgrgroupFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToOrgrgroupFindMany) OrderBy(params ...OrgrgroupOrderByParam) orgsToOrgrgroupFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToOrgrgroupFindMany) Skip(count int) orgsToOrgrgroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToOrgrgroupFindMany) Take(count int) orgsToOrgrgroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToOrgrgroupFindMany) Cursor(cursor OrgsCursorParam) orgsToOrgrgroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToOrgrgroupFindMany) Exec(ctx context.Context) (
	[]OrgsModel,
	error,
) {
	var v []OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToOrgrgroupFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgs,
	error,
) {
	var v []InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToOrgrgroupFindMany) Update(params ...OrgsSetParam) orgsToOrgrgroupUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgs"

	r.query.Outputs = countOutput

	var v orgsToOrgrgroupUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToOrgrgroupUpdateMany struct {
	query builder.Query
}

func (r orgsToOrgrgroupUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToOrgrgroupUpdateMany) orgsModel() {}

func (r orgsToOrgrgroupUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToOrgrgroupUpdateMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToOrgrgroupFindMany) Delete() orgsToOrgrgroupDeleteMany {
	var v orgsToOrgrgroupDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgs"

	v.query.Outputs = countOutput

	return v
}

type orgsToOrgrgroupDeleteMany struct {
	query builder.Query
}

func (r orgsToOrgrgroupDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToOrgrgroupDeleteMany) orgsModel() {}

func (r orgsToOrgrgroupDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToOrgrgroupDeleteMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToUsergroupFindUnique struct {
	query builder.Query
}

func (r orgsToUsergroupFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgsToUsergroupFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToUsergroupFindUnique) with()         {}
func (r orgsToUsergroupFindUnique) orgsModel()    {}
func (r orgsToUsergroupFindUnique) orgsRelation() {}

func (r orgsToUsergroupFindUnique) With(params ...UsergroupRelationWith) orgsToUsergroupFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToUsergroupFindUnique) Select(params ...orgsPrismaFields) orgsToUsergroupFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToUsergroupFindUnique) Omit(params ...orgsPrismaFields) orgsToUsergroupFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToUsergroupFindUnique) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToUsergroupFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToUsergroupFindUnique) Update(params ...OrgsSetParam) orgsToUsergroupUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgs"

	var v orgsToUsergroupUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToUsergroupUpdateUnique struct {
	query builder.Query
}

func (r orgsToUsergroupUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToUsergroupUpdateUnique) orgsModel() {}

func (r orgsToUsergroupUpdateUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToUsergroupUpdateUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToUsergroupFindUnique) Delete() orgsToUsergroupDeleteUnique {
	var v orgsToUsergroupDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgs"

	return v
}

type orgsToUsergroupDeleteUnique struct {
	query builder.Query
}

func (r orgsToUsergroupDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToUsergroupDeleteUnique) orgsModel() {}

func (r orgsToUsergroupDeleteUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToUsergroupDeleteUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsToUsergroupFindFirst struct {
	query builder.Query
}

func (r orgsToUsergroupFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgsToUsergroupFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToUsergroupFindFirst) with()         {}
func (r orgsToUsergroupFindFirst) orgsModel()    {}
func (r orgsToUsergroupFindFirst) orgsRelation() {}

func (r orgsToUsergroupFindFirst) With(params ...UsergroupRelationWith) orgsToUsergroupFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToUsergroupFindFirst) Select(params ...orgsPrismaFields) orgsToUsergroupFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToUsergroupFindFirst) Omit(params ...orgsPrismaFields) orgsToUsergroupFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToUsergroupFindFirst) OrderBy(params ...UsergroupOrderByParam) orgsToUsergroupFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToUsergroupFindFirst) Skip(count int) orgsToUsergroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToUsergroupFindFirst) Take(count int) orgsToUsergroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToUsergroupFindFirst) Cursor(cursor OrgsCursorParam) orgsToUsergroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToUsergroupFindFirst) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsToUsergroupFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgsToUsergroupFindMany struct {
	query builder.Query
}

func (r orgsToUsergroupFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgsToUsergroupFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToUsergroupFindMany) with()         {}
func (r orgsToUsergroupFindMany) orgsModel()    {}
func (r orgsToUsergroupFindMany) orgsRelation() {}

func (r orgsToUsergroupFindMany) With(params ...UsergroupRelationWith) orgsToUsergroupFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsToUsergroupFindMany) Select(params ...orgsPrismaFields) orgsToUsergroupFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToUsergroupFindMany) Omit(params ...orgsPrismaFields) orgsToUsergroupFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsToUsergroupFindMany) OrderBy(params ...UsergroupOrderByParam) orgsToUsergroupFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsToUsergroupFindMany) Skip(count int) orgsToUsergroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsToUsergroupFindMany) Take(count int) orgsToUsergroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsToUsergroupFindMany) Cursor(cursor OrgsCursorParam) orgsToUsergroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsToUsergroupFindMany) Exec(ctx context.Context) (
	[]OrgsModel,
	error,
) {
	var v []OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToUsergroupFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgs,
	error,
) {
	var v []InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsToUsergroupFindMany) Update(params ...OrgsSetParam) orgsToUsergroupUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgs"

	r.query.Outputs = countOutput

	var v orgsToUsergroupUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsToUsergroupUpdateMany struct {
	query builder.Query
}

func (r orgsToUsergroupUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsToUsergroupUpdateMany) orgsModel() {}

func (r orgsToUsergroupUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToUsergroupUpdateMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsToUsergroupFindMany) Delete() orgsToUsergroupDeleteMany {
	var v orgsToUsergroupDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgs"

	v.query.Outputs = countOutput

	return v
}

type orgsToUsergroupDeleteMany struct {
	query builder.Query
}

func (r orgsToUsergroupDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsToUsergroupDeleteMany) orgsModel() {}

func (r orgsToUsergroupDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsToUsergroupDeleteMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsFindUnique struct {
	query builder.Query
}

func (r orgsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r orgsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsFindUnique) with()         {}
func (r orgsFindUnique) orgsModel()    {}
func (r orgsFindUnique) orgsRelation() {}

func (r orgsActions) FindUnique(
	params OrgsEqualsUniqueWhereParam,
) orgsFindUnique {
	var v orgsFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "orgs"
	v.query.Outputs = orgsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r orgsFindUnique) With(params ...OrgsRelationWith) orgsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsFindUnique) Select(params ...orgsPrismaFields) orgsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsFindUnique) Omit(params ...orgsPrismaFields) orgsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsFindUnique) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsFindUnique) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsFindUnique) Update(params ...OrgsSetParam) orgsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "orgs"

	var v orgsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsUpdateUnique struct {
	query builder.Query
}

func (r orgsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsUpdateUnique) orgsModel() {}

func (r orgsUpdateUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsUpdateUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsFindUnique) Delete() orgsDeleteUnique {
	var v orgsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "orgs"

	return v
}

type orgsDeleteUnique struct {
	query builder.Query
}

func (r orgsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsDeleteUnique) orgsModel() {}

func (r orgsDeleteUnique) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsDeleteUnique) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsFindFirst struct {
	query builder.Query
}

func (r orgsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r orgsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsFindFirst) with()         {}
func (r orgsFindFirst) orgsModel()    {}
func (r orgsFindFirst) orgsRelation() {}

func (r orgsActions) FindFirst(
	params ...OrgsWhereParam,
) orgsFindFirst {
	var v orgsFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "orgs"
	v.query.Outputs = orgsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orgsFindFirst) With(params ...OrgsRelationWith) orgsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsFindFirst) Select(params ...orgsPrismaFields) orgsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsFindFirst) Omit(params ...orgsPrismaFields) orgsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsFindFirst) OrderBy(params ...OrgsOrderByParam) orgsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsFindFirst) Skip(count int) orgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsFindFirst) Take(count int) orgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsFindFirst) Cursor(cursor OrgsCursorParam) orgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsFindFirst) Exec(ctx context.Context) (
	*OrgsModel,
	error,
) {
	var v *OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r orgsFindFirst) ExecInner(ctx context.Context) (
	*InnerOrgs,
	error,
) {
	var v *InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type orgsFindMany struct {
	query builder.Query
}

func (r orgsFindMany) getQuery() builder.Query {
	return r.query
}

func (r orgsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsFindMany) with()         {}
func (r orgsFindMany) orgsModel()    {}
func (r orgsFindMany) orgsRelation() {}

func (r orgsActions) FindMany(
	params ...OrgsWhereParam,
) orgsFindMany {
	var v orgsFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "orgs"
	v.query.Outputs = orgsOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r orgsFindMany) With(params ...OrgsRelationWith) orgsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r orgsFindMany) Select(params ...orgsPrismaFields) orgsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsFindMany) Omit(params ...orgsPrismaFields) orgsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range orgsOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r orgsFindMany) OrderBy(params ...OrgsOrderByParam) orgsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r orgsFindMany) Skip(count int) orgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r orgsFindMany) Take(count int) orgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r orgsFindMany) Cursor(cursor OrgsCursorParam) orgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r orgsFindMany) Exec(ctx context.Context) (
	[]OrgsModel,
	error,
) {
	var v []OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsFindMany) ExecInner(ctx context.Context) (
	[]InnerOrgs,
	error,
) {
	var v []InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r orgsFindMany) Update(params ...OrgsSetParam) orgsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "orgs"

	r.query.Outputs = countOutput

	var v orgsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type orgsUpdateMany struct {
	query builder.Query
}

func (r orgsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsUpdateMany) orgsModel() {}

func (r orgsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsUpdateMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r orgsFindMany) Delete() orgsDeleteMany {
	var v orgsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "orgs"

	v.query.Outputs = countOutput

	return v
}

type orgsDeleteMany struct {
	query builder.Query
}

func (r orgsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p orgsDeleteMany) orgsModel() {}

func (r orgsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsDeleteMany) Tx() OrgsManyTxResult {
	v := newOrgsManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usergroupToGroupsFindUnique struct {
	query builder.Query
}

func (r usergroupToGroupsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r usergroupToGroupsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToGroupsFindUnique) with()              {}
func (r usergroupToGroupsFindUnique) usergroupModel()    {}
func (r usergroupToGroupsFindUnique) usergroupRelation() {}

func (r usergroupToGroupsFindUnique) With(params ...GroupsRelationWith) usergroupToGroupsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usergroupToGroupsFindUnique) Select(params ...usergroupPrismaFields) usergroupToGroupsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToGroupsFindUnique) Omit(params ...usergroupPrismaFields) usergroupToGroupsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usergroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToGroupsFindUnique) Exec(ctx context.Context) (
	*UsergroupModel,
	error,
) {
	var v *UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usergroupToGroupsFindUnique) ExecInner(ctx context.Context) (
	*InnerUsergroup,
	error,
) {
	var v *InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usergroupToGroupsFindUnique) Update(params ...UsergroupSetParam) usergroupToGroupsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "usergroup"

	var v usergroupToGroupsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usergroupToGroupsUpdateUnique struct {
	query builder.Query
}

func (r usergroupToGroupsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToGroupsUpdateUnique) usergroupModel() {}

func (r usergroupToGroupsUpdateUnique) Exec(ctx context.Context) (*UsergroupModel, error) {
	var v UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupToGroupsUpdateUnique) Tx() UsergroupUniqueTxResult {
	v := newUsergroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usergroupToGroupsFindUnique) Delete() usergroupToGroupsDeleteUnique {
	var v usergroupToGroupsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "usergroup"

	return v
}

type usergroupToGroupsDeleteUnique struct {
	query builder.Query
}

func (r usergroupToGroupsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p usergroupToGroupsDeleteUnique) usergroupModel() {}

func (r usergroupToGroupsDeleteUnique) Exec(ctx context.Context) (*UsergroupModel, error) {
	var v UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupToGroupsDeleteUnique) Tx() UsergroupUniqueTxResult {
	v := newUsergroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usergroupToGroupsFindFirst struct {
	query builder.Query
}

func (r usergroupToGroupsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r usergroupToGroupsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToGroupsFindFirst) with()              {}
func (r usergroupToGroupsFindFirst) usergroupModel()    {}
func (r usergroupToGroupsFindFirst) usergroupRelation() {}

func (r usergroupToGroupsFindFirst) With(params ...GroupsRelationWith) usergroupToGroupsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usergroupToGroupsFindFirst) Select(params ...usergroupPrismaFields) usergroupToGroupsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToGroupsFindFirst) Omit(params ...usergroupPrismaFields) usergroupToGroupsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usergroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToGroupsFindFirst) OrderBy(params ...GroupsOrderByParam) usergroupToGroupsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usergroupToGroupsFindFirst) Skip(count int) usergroupToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usergroupToGroupsFindFirst) Take(count int) usergroupToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usergroupToGroupsFindFirst) Cursor(cursor UsergroupCursorParam) usergroupToGroupsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usergroupToGroupsFindFirst) Exec(ctx context.Context) (
	*UsergroupModel,
	error,
) {
	var v *UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usergroupToGroupsFindFirst) ExecInner(ctx context.Context) (
	*InnerUsergroup,
	error,
) {
	var v *InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type usergroupToGroupsFindMany struct {
	query builder.Query
}

func (r usergroupToGroupsFindMany) getQuery() builder.Query {
	return r.query
}

func (r usergroupToGroupsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToGroupsFindMany) with()              {}
func (r usergroupToGroupsFindMany) usergroupModel()    {}
func (r usergroupToGroupsFindMany) usergroupRelation() {}

func (r usergroupToGroupsFindMany) With(params ...GroupsRelationWith) usergroupToGroupsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usergroupToGroupsFindMany) Select(params ...usergroupPrismaFields) usergroupToGroupsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToGroupsFindMany) Omit(params ...usergroupPrismaFields) usergroupToGroupsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usergroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToGroupsFindMany) OrderBy(params ...GroupsOrderByParam) usergroupToGroupsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usergroupToGroupsFindMany) Skip(count int) usergroupToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usergroupToGroupsFindMany) Take(count int) usergroupToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usergroupToGroupsFindMany) Cursor(cursor UsergroupCursorParam) usergroupToGroupsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usergroupToGroupsFindMany) Exec(ctx context.Context) (
	[]UsergroupModel,
	error,
) {
	var v []UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usergroupToGroupsFindMany) ExecInner(ctx context.Context) (
	[]InnerUsergroup,
	error,
) {
	var v []InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usergroupToGroupsFindMany) Update(params ...UsergroupSetParam) usergroupToGroupsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "usergroup"

	r.query.Outputs = countOutput

	var v usergroupToGroupsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usergroupToGroupsUpdateMany struct {
	query builder.Query
}

func (r usergroupToGroupsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToGroupsUpdateMany) usergroupModel() {}

func (r usergroupToGroupsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupToGroupsUpdateMany) Tx() UsergroupManyTxResult {
	v := newUsergroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usergroupToGroupsFindMany) Delete() usergroupToGroupsDeleteMany {
	var v usergroupToGroupsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "usergroup"

	v.query.Outputs = countOutput

	return v
}

type usergroupToGroupsDeleteMany struct {
	query builder.Query
}

func (r usergroupToGroupsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p usergroupToGroupsDeleteMany) usergroupModel() {}

func (r usergroupToGroupsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupToGroupsDeleteMany) Tx() UsergroupManyTxResult {
	v := newUsergroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usergroupToOrgsFindUnique struct {
	query builder.Query
}

func (r usergroupToOrgsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r usergroupToOrgsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToOrgsFindUnique) with()              {}
func (r usergroupToOrgsFindUnique) usergroupModel()    {}
func (r usergroupToOrgsFindUnique) usergroupRelation() {}

func (r usergroupToOrgsFindUnique) With(params ...OrgsRelationWith) usergroupToOrgsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usergroupToOrgsFindUnique) Select(params ...usergroupPrismaFields) usergroupToOrgsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToOrgsFindUnique) Omit(params ...usergroupPrismaFields) usergroupToOrgsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usergroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToOrgsFindUnique) Exec(ctx context.Context) (
	*UsergroupModel,
	error,
) {
	var v *UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usergroupToOrgsFindUnique) ExecInner(ctx context.Context) (
	*InnerUsergroup,
	error,
) {
	var v *InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usergroupToOrgsFindUnique) Update(params ...UsergroupSetParam) usergroupToOrgsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "usergroup"

	var v usergroupToOrgsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usergroupToOrgsUpdateUnique struct {
	query builder.Query
}

func (r usergroupToOrgsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToOrgsUpdateUnique) usergroupModel() {}

func (r usergroupToOrgsUpdateUnique) Exec(ctx context.Context) (*UsergroupModel, error) {
	var v UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupToOrgsUpdateUnique) Tx() UsergroupUniqueTxResult {
	v := newUsergroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usergroupToOrgsFindUnique) Delete() usergroupToOrgsDeleteUnique {
	var v usergroupToOrgsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "usergroup"

	return v
}

type usergroupToOrgsDeleteUnique struct {
	query builder.Query
}

func (r usergroupToOrgsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p usergroupToOrgsDeleteUnique) usergroupModel() {}

func (r usergroupToOrgsDeleteUnique) Exec(ctx context.Context) (*UsergroupModel, error) {
	var v UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupToOrgsDeleteUnique) Tx() UsergroupUniqueTxResult {
	v := newUsergroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usergroupToOrgsFindFirst struct {
	query builder.Query
}

func (r usergroupToOrgsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r usergroupToOrgsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToOrgsFindFirst) with()              {}
func (r usergroupToOrgsFindFirst) usergroupModel()    {}
func (r usergroupToOrgsFindFirst) usergroupRelation() {}

func (r usergroupToOrgsFindFirst) With(params ...OrgsRelationWith) usergroupToOrgsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usergroupToOrgsFindFirst) Select(params ...usergroupPrismaFields) usergroupToOrgsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToOrgsFindFirst) Omit(params ...usergroupPrismaFields) usergroupToOrgsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usergroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToOrgsFindFirst) OrderBy(params ...OrgsOrderByParam) usergroupToOrgsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usergroupToOrgsFindFirst) Skip(count int) usergroupToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usergroupToOrgsFindFirst) Take(count int) usergroupToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usergroupToOrgsFindFirst) Cursor(cursor UsergroupCursorParam) usergroupToOrgsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usergroupToOrgsFindFirst) Exec(ctx context.Context) (
	*UsergroupModel,
	error,
) {
	var v *UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usergroupToOrgsFindFirst) ExecInner(ctx context.Context) (
	*InnerUsergroup,
	error,
) {
	var v *InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type usergroupToOrgsFindMany struct {
	query builder.Query
}

func (r usergroupToOrgsFindMany) getQuery() builder.Query {
	return r.query
}

func (r usergroupToOrgsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToOrgsFindMany) with()              {}
func (r usergroupToOrgsFindMany) usergroupModel()    {}
func (r usergroupToOrgsFindMany) usergroupRelation() {}

func (r usergroupToOrgsFindMany) With(params ...OrgsRelationWith) usergroupToOrgsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usergroupToOrgsFindMany) Select(params ...usergroupPrismaFields) usergroupToOrgsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToOrgsFindMany) Omit(params ...usergroupPrismaFields) usergroupToOrgsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usergroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToOrgsFindMany) OrderBy(params ...OrgsOrderByParam) usergroupToOrgsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usergroupToOrgsFindMany) Skip(count int) usergroupToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usergroupToOrgsFindMany) Take(count int) usergroupToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usergroupToOrgsFindMany) Cursor(cursor UsergroupCursorParam) usergroupToOrgsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usergroupToOrgsFindMany) Exec(ctx context.Context) (
	[]UsergroupModel,
	error,
) {
	var v []UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usergroupToOrgsFindMany) ExecInner(ctx context.Context) (
	[]InnerUsergroup,
	error,
) {
	var v []InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usergroupToOrgsFindMany) Update(params ...UsergroupSetParam) usergroupToOrgsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "usergroup"

	r.query.Outputs = countOutput

	var v usergroupToOrgsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usergroupToOrgsUpdateMany struct {
	query builder.Query
}

func (r usergroupToOrgsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToOrgsUpdateMany) usergroupModel() {}

func (r usergroupToOrgsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupToOrgsUpdateMany) Tx() UsergroupManyTxResult {
	v := newUsergroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usergroupToOrgsFindMany) Delete() usergroupToOrgsDeleteMany {
	var v usergroupToOrgsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "usergroup"

	v.query.Outputs = countOutput

	return v
}

type usergroupToOrgsDeleteMany struct {
	query builder.Query
}

func (r usergroupToOrgsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p usergroupToOrgsDeleteMany) usergroupModel() {}

func (r usergroupToOrgsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupToOrgsDeleteMany) Tx() UsergroupManyTxResult {
	v := newUsergroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usergroupToUsersFindUnique struct {
	query builder.Query
}

func (r usergroupToUsersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r usergroupToUsersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToUsersFindUnique) with()              {}
func (r usergroupToUsersFindUnique) usergroupModel()    {}
func (r usergroupToUsersFindUnique) usergroupRelation() {}

func (r usergroupToUsersFindUnique) With(params ...UsersRelationWith) usergroupToUsersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usergroupToUsersFindUnique) Select(params ...usergroupPrismaFields) usergroupToUsersFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToUsersFindUnique) Omit(params ...usergroupPrismaFields) usergroupToUsersFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usergroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToUsersFindUnique) Exec(ctx context.Context) (
	*UsergroupModel,
	error,
) {
	var v *UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usergroupToUsersFindUnique) ExecInner(ctx context.Context) (
	*InnerUsergroup,
	error,
) {
	var v *InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usergroupToUsersFindUnique) Update(params ...UsergroupSetParam) usergroupToUsersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "usergroup"

	var v usergroupToUsersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usergroupToUsersUpdateUnique struct {
	query builder.Query
}

func (r usergroupToUsersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToUsersUpdateUnique) usergroupModel() {}

func (r usergroupToUsersUpdateUnique) Exec(ctx context.Context) (*UsergroupModel, error) {
	var v UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupToUsersUpdateUnique) Tx() UsergroupUniqueTxResult {
	v := newUsergroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usergroupToUsersFindUnique) Delete() usergroupToUsersDeleteUnique {
	var v usergroupToUsersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "usergroup"

	return v
}

type usergroupToUsersDeleteUnique struct {
	query builder.Query
}

func (r usergroupToUsersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p usergroupToUsersDeleteUnique) usergroupModel() {}

func (r usergroupToUsersDeleteUnique) Exec(ctx context.Context) (*UsergroupModel, error) {
	var v UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupToUsersDeleteUnique) Tx() UsergroupUniqueTxResult {
	v := newUsergroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usergroupToUsersFindFirst struct {
	query builder.Query
}

func (r usergroupToUsersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r usergroupToUsersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToUsersFindFirst) with()              {}
func (r usergroupToUsersFindFirst) usergroupModel()    {}
func (r usergroupToUsersFindFirst) usergroupRelation() {}

func (r usergroupToUsersFindFirst) With(params ...UsersRelationWith) usergroupToUsersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usergroupToUsersFindFirst) Select(params ...usergroupPrismaFields) usergroupToUsersFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToUsersFindFirst) Omit(params ...usergroupPrismaFields) usergroupToUsersFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usergroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToUsersFindFirst) OrderBy(params ...UsersOrderByParam) usergroupToUsersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usergroupToUsersFindFirst) Skip(count int) usergroupToUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usergroupToUsersFindFirst) Take(count int) usergroupToUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usergroupToUsersFindFirst) Cursor(cursor UsergroupCursorParam) usergroupToUsersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usergroupToUsersFindFirst) Exec(ctx context.Context) (
	*UsergroupModel,
	error,
) {
	var v *UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usergroupToUsersFindFirst) ExecInner(ctx context.Context) (
	*InnerUsergroup,
	error,
) {
	var v *InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type usergroupToUsersFindMany struct {
	query builder.Query
}

func (r usergroupToUsersFindMany) getQuery() builder.Query {
	return r.query
}

func (r usergroupToUsersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToUsersFindMany) with()              {}
func (r usergroupToUsersFindMany) usergroupModel()    {}
func (r usergroupToUsersFindMany) usergroupRelation() {}

func (r usergroupToUsersFindMany) With(params ...UsersRelationWith) usergroupToUsersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usergroupToUsersFindMany) Select(params ...usergroupPrismaFields) usergroupToUsersFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToUsersFindMany) Omit(params ...usergroupPrismaFields) usergroupToUsersFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usergroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupToUsersFindMany) OrderBy(params ...UsersOrderByParam) usergroupToUsersFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usergroupToUsersFindMany) Skip(count int) usergroupToUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usergroupToUsersFindMany) Take(count int) usergroupToUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usergroupToUsersFindMany) Cursor(cursor UsergroupCursorParam) usergroupToUsersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usergroupToUsersFindMany) Exec(ctx context.Context) (
	[]UsergroupModel,
	error,
) {
	var v []UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usergroupToUsersFindMany) ExecInner(ctx context.Context) (
	[]InnerUsergroup,
	error,
) {
	var v []InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usergroupToUsersFindMany) Update(params ...UsergroupSetParam) usergroupToUsersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "usergroup"

	r.query.Outputs = countOutput

	var v usergroupToUsersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usergroupToUsersUpdateMany struct {
	query builder.Query
}

func (r usergroupToUsersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupToUsersUpdateMany) usergroupModel() {}

func (r usergroupToUsersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupToUsersUpdateMany) Tx() UsergroupManyTxResult {
	v := newUsergroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usergroupToUsersFindMany) Delete() usergroupToUsersDeleteMany {
	var v usergroupToUsersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "usergroup"

	v.query.Outputs = countOutput

	return v
}

type usergroupToUsersDeleteMany struct {
	query builder.Query
}

func (r usergroupToUsersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p usergroupToUsersDeleteMany) usergroupModel() {}

func (r usergroupToUsersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupToUsersDeleteMany) Tx() UsergroupManyTxResult {
	v := newUsergroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usergroupFindUnique struct {
	query builder.Query
}

func (r usergroupFindUnique) getQuery() builder.Query {
	return r.query
}

func (r usergroupFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupFindUnique) with()              {}
func (r usergroupFindUnique) usergroupModel()    {}
func (r usergroupFindUnique) usergroupRelation() {}

func (r usergroupActions) FindUnique(
	params UsergroupEqualsUniqueWhereParam,
) usergroupFindUnique {
	var v usergroupFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "usergroup"
	v.query.Outputs = usergroupOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r usergroupFindUnique) With(params ...UsergroupRelationWith) usergroupFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usergroupFindUnique) Select(params ...usergroupPrismaFields) usergroupFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupFindUnique) Omit(params ...usergroupPrismaFields) usergroupFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usergroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupFindUnique) Exec(ctx context.Context) (
	*UsergroupModel,
	error,
) {
	var v *UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usergroupFindUnique) ExecInner(ctx context.Context) (
	*InnerUsergroup,
	error,
) {
	var v *InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usergroupFindUnique) Update(params ...UsergroupSetParam) usergroupUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "usergroup"

	var v usergroupUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usergroupUpdateUnique struct {
	query builder.Query
}

func (r usergroupUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupUpdateUnique) usergroupModel() {}

func (r usergroupUpdateUnique) Exec(ctx context.Context) (*UsergroupModel, error) {
	var v UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupUpdateUnique) Tx() UsergroupUniqueTxResult {
	v := newUsergroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usergroupFindUnique) Delete() usergroupDeleteUnique {
	var v usergroupDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "usergroup"

	return v
}

type usergroupDeleteUnique struct {
	query builder.Query
}

func (r usergroupDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p usergroupDeleteUnique) usergroupModel() {}

func (r usergroupDeleteUnique) Exec(ctx context.Context) (*UsergroupModel, error) {
	var v UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupDeleteUnique) Tx() UsergroupUniqueTxResult {
	v := newUsergroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usergroupFindFirst struct {
	query builder.Query
}

func (r usergroupFindFirst) getQuery() builder.Query {
	return r.query
}

func (r usergroupFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupFindFirst) with()              {}
func (r usergroupFindFirst) usergroupModel()    {}
func (r usergroupFindFirst) usergroupRelation() {}

func (r usergroupActions) FindFirst(
	params ...UsergroupWhereParam,
) usergroupFindFirst {
	var v usergroupFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "usergroup"
	v.query.Outputs = usergroupOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r usergroupFindFirst) With(params ...UsergroupRelationWith) usergroupFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usergroupFindFirst) Select(params ...usergroupPrismaFields) usergroupFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupFindFirst) Omit(params ...usergroupPrismaFields) usergroupFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usergroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupFindFirst) OrderBy(params ...UsergroupOrderByParam) usergroupFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usergroupFindFirst) Skip(count int) usergroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usergroupFindFirst) Take(count int) usergroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usergroupFindFirst) Cursor(cursor UsergroupCursorParam) usergroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usergroupFindFirst) Exec(ctx context.Context) (
	*UsergroupModel,
	error,
) {
	var v *UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usergroupFindFirst) ExecInner(ctx context.Context) (
	*InnerUsergroup,
	error,
) {
	var v *InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type usergroupFindMany struct {
	query builder.Query
}

func (r usergroupFindMany) getQuery() builder.Query {
	return r.query
}

func (r usergroupFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupFindMany) with()              {}
func (r usergroupFindMany) usergroupModel()    {}
func (r usergroupFindMany) usergroupRelation() {}

func (r usergroupActions) FindMany(
	params ...UsergroupWhereParam,
) usergroupFindMany {
	var v usergroupFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "usergroup"
	v.query.Outputs = usergroupOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r usergroupFindMany) With(params ...UsergroupRelationWith) usergroupFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usergroupFindMany) Select(params ...usergroupPrismaFields) usergroupFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupFindMany) Omit(params ...usergroupPrismaFields) usergroupFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usergroupOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usergroupFindMany) OrderBy(params ...UsergroupOrderByParam) usergroupFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usergroupFindMany) Skip(count int) usergroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usergroupFindMany) Take(count int) usergroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usergroupFindMany) Cursor(cursor UsergroupCursorParam) usergroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usergroupFindMany) Exec(ctx context.Context) (
	[]UsergroupModel,
	error,
) {
	var v []UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usergroupFindMany) ExecInner(ctx context.Context) (
	[]InnerUsergroup,
	error,
) {
	var v []InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usergroupFindMany) Update(params ...UsergroupSetParam) usergroupUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "usergroup"

	r.query.Outputs = countOutput

	var v usergroupUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usergroupUpdateMany struct {
	query builder.Query
}

func (r usergroupUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupUpdateMany) usergroupModel() {}

func (r usergroupUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupUpdateMany) Tx() UsergroupManyTxResult {
	v := newUsergroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usergroupFindMany) Delete() usergroupDeleteMany {
	var v usergroupDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "usergroup"

	v.query.Outputs = countOutput

	return v
}

type usergroupDeleteMany struct {
	query builder.Query
}

func (r usergroupDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p usergroupDeleteMany) usergroupModel() {}

func (r usergroupDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupDeleteMany) Tx() UsergroupManyTxResult {
	v := newUsergroupManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersToGroupuserpermsFindUnique struct {
	query builder.Query
}

func (r usersToGroupuserpermsFindUnique) getQuery() builder.Query {
	return r.query
}

func (r usersToGroupuserpermsFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToGroupuserpermsFindUnique) with()          {}
func (r usersToGroupuserpermsFindUnique) usersModel()    {}
func (r usersToGroupuserpermsFindUnique) usersRelation() {}

func (r usersToGroupuserpermsFindUnique) With(params ...GroupuserpermsRelationWith) usersToGroupuserpermsFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersToGroupuserpermsFindUnique) Select(params ...usersPrismaFields) usersToGroupuserpermsFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usersToGroupuserpermsFindUnique) Omit(params ...usersPrismaFields) usersToGroupuserpermsFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usersOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usersToGroupuserpermsFindUnique) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersToGroupuserpermsFindUnique) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersToGroupuserpermsFindUnique) Update(params ...UsersSetParam) usersToGroupuserpermsUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "users"

	var v usersToGroupuserpermsUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersToGroupuserpermsUpdateUnique struct {
	query builder.Query
}

func (r usersToGroupuserpermsUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToGroupuserpermsUpdateUnique) usersModel() {}

func (r usersToGroupuserpermsUpdateUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToGroupuserpermsUpdateUnique) Tx() UsersUniqueTxResult {
	v := newUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersToGroupuserpermsFindUnique) Delete() usersToGroupuserpermsDeleteUnique {
	var v usersToGroupuserpermsDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "users"

	return v
}

type usersToGroupuserpermsDeleteUnique struct {
	query builder.Query
}

func (r usersToGroupuserpermsDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p usersToGroupuserpermsDeleteUnique) usersModel() {}

func (r usersToGroupuserpermsDeleteUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToGroupuserpermsDeleteUnique) Tx() UsersUniqueTxResult {
	v := newUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersToGroupuserpermsFindFirst struct {
	query builder.Query
}

func (r usersToGroupuserpermsFindFirst) getQuery() builder.Query {
	return r.query
}

func (r usersToGroupuserpermsFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToGroupuserpermsFindFirst) with()          {}
func (r usersToGroupuserpermsFindFirst) usersModel()    {}
func (r usersToGroupuserpermsFindFirst) usersRelation() {}

func (r usersToGroupuserpermsFindFirst) With(params ...GroupuserpermsRelationWith) usersToGroupuserpermsFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersToGroupuserpermsFindFirst) Select(params ...usersPrismaFields) usersToGroupuserpermsFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usersToGroupuserpermsFindFirst) Omit(params ...usersPrismaFields) usersToGroupuserpermsFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usersOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usersToGroupuserpermsFindFirst) OrderBy(params ...GroupuserpermsOrderByParam) usersToGroupuserpermsFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersToGroupuserpermsFindFirst) Skip(count int) usersToGroupuserpermsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersToGroupuserpermsFindFirst) Take(count int) usersToGroupuserpermsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersToGroupuserpermsFindFirst) Cursor(cursor UsersCursorParam) usersToGroupuserpermsFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersToGroupuserpermsFindFirst) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersToGroupuserpermsFindFirst) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type usersToGroupuserpermsFindMany struct {
	query builder.Query
}

func (r usersToGroupuserpermsFindMany) getQuery() builder.Query {
	return r.query
}

func (r usersToGroupuserpermsFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToGroupuserpermsFindMany) with()          {}
func (r usersToGroupuserpermsFindMany) usersModel()    {}
func (r usersToGroupuserpermsFindMany) usersRelation() {}

func (r usersToGroupuserpermsFindMany) With(params ...GroupuserpermsRelationWith) usersToGroupuserpermsFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersToGroupuserpermsFindMany) Select(params ...usersPrismaFields) usersToGroupuserpermsFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usersToGroupuserpermsFindMany) Omit(params ...usersPrismaFields) usersToGroupuserpermsFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usersOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usersToGroupuserpermsFindMany) OrderBy(params ...GroupuserpermsOrderByParam) usersToGroupuserpermsFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersToGroupuserpermsFindMany) Skip(count int) usersToGroupuserpermsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersToGroupuserpermsFindMany) Take(count int) usersToGroupuserpermsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersToGroupuserpermsFindMany) Cursor(cursor UsersCursorParam) usersToGroupuserpermsFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersToGroupuserpermsFindMany) Exec(ctx context.Context) (
	[]UsersModel,
	error,
) {
	var v []UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersToGroupuserpermsFindMany) ExecInner(ctx context.Context) (
	[]InnerUsers,
	error,
) {
	var v []InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersToGroupuserpermsFindMany) Update(params ...UsersSetParam) usersToGroupuserpermsUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "users"

	r.query.Outputs = countOutput

	var v usersToGroupuserpermsUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersToGroupuserpermsUpdateMany struct {
	query builder.Query
}

func (r usersToGroupuserpermsUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToGroupuserpermsUpdateMany) usersModel() {}

func (r usersToGroupuserpermsUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToGroupuserpermsUpdateMany) Tx() UsersManyTxResult {
	v := newUsersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersToGroupuserpermsFindMany) Delete() usersToGroupuserpermsDeleteMany {
	var v usersToGroupuserpermsDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "users"

	v.query.Outputs = countOutput

	return v
}

type usersToGroupuserpermsDeleteMany struct {
	query builder.Query
}

func (r usersToGroupuserpermsDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p usersToGroupuserpermsDeleteMany) usersModel() {}

func (r usersToGroupuserpermsDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToGroupuserpermsDeleteMany) Tx() UsersManyTxResult {
	v := newUsersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersToUsergroupFindUnique struct {
	query builder.Query
}

func (r usersToUsergroupFindUnique) getQuery() builder.Query {
	return r.query
}

func (r usersToUsergroupFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToUsergroupFindUnique) with()          {}
func (r usersToUsergroupFindUnique) usersModel()    {}
func (r usersToUsergroupFindUnique) usersRelation() {}

func (r usersToUsergroupFindUnique) With(params ...UsergroupRelationWith) usersToUsergroupFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersToUsergroupFindUnique) Select(params ...usersPrismaFields) usersToUsergroupFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usersToUsergroupFindUnique) Omit(params ...usersPrismaFields) usersToUsergroupFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usersOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usersToUsergroupFindUnique) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersToUsergroupFindUnique) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersToUsergroupFindUnique) Update(params ...UsersSetParam) usersToUsergroupUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "users"

	var v usersToUsergroupUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersToUsergroupUpdateUnique struct {
	query builder.Query
}

func (r usersToUsergroupUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToUsergroupUpdateUnique) usersModel() {}

func (r usersToUsergroupUpdateUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToUsergroupUpdateUnique) Tx() UsersUniqueTxResult {
	v := newUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersToUsergroupFindUnique) Delete() usersToUsergroupDeleteUnique {
	var v usersToUsergroupDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "users"

	return v
}

type usersToUsergroupDeleteUnique struct {
	query builder.Query
}

func (r usersToUsergroupDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p usersToUsergroupDeleteUnique) usersModel() {}

func (r usersToUsergroupDeleteUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToUsergroupDeleteUnique) Tx() UsersUniqueTxResult {
	v := newUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersToUsergroupFindFirst struct {
	query builder.Query
}

func (r usersToUsergroupFindFirst) getQuery() builder.Query {
	return r.query
}

func (r usersToUsergroupFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToUsergroupFindFirst) with()          {}
func (r usersToUsergroupFindFirst) usersModel()    {}
func (r usersToUsergroupFindFirst) usersRelation() {}

func (r usersToUsergroupFindFirst) With(params ...UsergroupRelationWith) usersToUsergroupFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersToUsergroupFindFirst) Select(params ...usersPrismaFields) usersToUsergroupFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usersToUsergroupFindFirst) Omit(params ...usersPrismaFields) usersToUsergroupFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usersOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usersToUsergroupFindFirst) OrderBy(params ...UsergroupOrderByParam) usersToUsergroupFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersToUsergroupFindFirst) Skip(count int) usersToUsergroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersToUsergroupFindFirst) Take(count int) usersToUsergroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersToUsergroupFindFirst) Cursor(cursor UsersCursorParam) usersToUsergroupFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersToUsergroupFindFirst) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersToUsergroupFindFirst) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type usersToUsergroupFindMany struct {
	query builder.Query
}

func (r usersToUsergroupFindMany) getQuery() builder.Query {
	return r.query
}

func (r usersToUsergroupFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToUsergroupFindMany) with()          {}
func (r usersToUsergroupFindMany) usersModel()    {}
func (r usersToUsergroupFindMany) usersRelation() {}

func (r usersToUsergroupFindMany) With(params ...UsergroupRelationWith) usersToUsergroupFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersToUsergroupFindMany) Select(params ...usersPrismaFields) usersToUsergroupFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usersToUsergroupFindMany) Omit(params ...usersPrismaFields) usersToUsergroupFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usersOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usersToUsergroupFindMany) OrderBy(params ...UsergroupOrderByParam) usersToUsergroupFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersToUsergroupFindMany) Skip(count int) usersToUsergroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersToUsergroupFindMany) Take(count int) usersToUsergroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersToUsergroupFindMany) Cursor(cursor UsersCursorParam) usersToUsergroupFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersToUsergroupFindMany) Exec(ctx context.Context) (
	[]UsersModel,
	error,
) {
	var v []UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersToUsergroupFindMany) ExecInner(ctx context.Context) (
	[]InnerUsers,
	error,
) {
	var v []InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersToUsergroupFindMany) Update(params ...UsersSetParam) usersToUsergroupUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "users"

	r.query.Outputs = countOutput

	var v usersToUsergroupUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersToUsergroupUpdateMany struct {
	query builder.Query
}

func (r usersToUsergroupUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersToUsergroupUpdateMany) usersModel() {}

func (r usersToUsergroupUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToUsergroupUpdateMany) Tx() UsersManyTxResult {
	v := newUsersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersToUsergroupFindMany) Delete() usersToUsergroupDeleteMany {
	var v usersToUsergroupDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "users"

	v.query.Outputs = countOutput

	return v
}

type usersToUsergroupDeleteMany struct {
	query builder.Query
}

func (r usersToUsergroupDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p usersToUsergroupDeleteMany) usersModel() {}

func (r usersToUsergroupDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersToUsergroupDeleteMany) Tx() UsersManyTxResult {
	v := newUsersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersFindUnique struct {
	query builder.Query
}

func (r usersFindUnique) getQuery() builder.Query {
	return r.query
}

func (r usersFindUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersFindUnique) with()          {}
func (r usersFindUnique) usersModel()    {}
func (r usersFindUnique) usersRelation() {}

func (r usersActions) FindUnique(
	params UsersEqualsUniqueWhereParam,
) usersFindUnique {
	var v usersFindUnique
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findUnique"

	v.query.Model = "users"
	v.query.Outputs = usersOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r usersFindUnique) With(params ...UsersRelationWith) usersFindUnique {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersFindUnique) Select(params ...usersPrismaFields) usersFindUnique {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usersFindUnique) Omit(params ...usersPrismaFields) usersFindUnique {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usersOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usersFindUnique) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersFindUnique) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersFindUnique) Update(params ...UsersSetParam) usersUpdateUnique {
	r.query.Operation = "mutation"
	r.query.Method = "updateOne"
	r.query.Model = "users"

	var v usersUpdateUnique
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersUpdateUnique struct {
	query builder.Query
}

func (r usersUpdateUnique) ExtractQuery() builder.Query {
	return r.query
}

func (r usersUpdateUnique) usersModel() {}

func (r usersUpdateUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersUpdateUnique) Tx() UsersUniqueTxResult {
	v := newUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersFindUnique) Delete() usersDeleteUnique {
	var v usersDeleteUnique
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteOne"
	v.query.Model = "users"

	return v
}

type usersDeleteUnique struct {
	query builder.Query
}

func (r usersDeleteUnique) ExtractQuery() builder.Query {
	return r.query
}

func (p usersDeleteUnique) usersModel() {}

func (r usersDeleteUnique) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersDeleteUnique) Tx() UsersUniqueTxResult {
	v := newUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersFindFirst struct {
	query builder.Query
}

func (r usersFindFirst) getQuery() builder.Query {
	return r.query
}

func (r usersFindFirst) ExtractQuery() builder.Query {
	return r.query
}

func (r usersFindFirst) with()          {}
func (r usersFindFirst) usersModel()    {}
func (r usersFindFirst) usersRelation() {}

func (r usersActions) FindFirst(
	params ...UsersWhereParam,
) usersFindFirst {
	var v usersFindFirst
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findFirst"

	v.query.Model = "users"
	v.query.Outputs = usersOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r usersFindFirst) With(params ...UsersRelationWith) usersFindFirst {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersFindFirst) Select(params ...usersPrismaFields) usersFindFirst {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usersFindFirst) Omit(params ...usersPrismaFields) usersFindFirst {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usersOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usersFindFirst) OrderBy(params ...UsersOrderByParam) usersFindFirst {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersFindFirst) Skip(count int) usersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersFindFirst) Take(count int) usersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersFindFirst) Cursor(cursor UsersCursorParam) usersFindFirst {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersFindFirst) Exec(ctx context.Context) (
	*UsersModel,
	error,
) {
	var v *UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

func (r usersFindFirst) ExecInner(ctx context.Context) (
	*InnerUsers,
	error,
) {
	var v *InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	if v == nil {
		return nil, ErrNotFound
	}

	return v, nil
}

type usersFindMany struct {
	query builder.Query
}

func (r usersFindMany) getQuery() builder.Query {
	return r.query
}

func (r usersFindMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersFindMany) with()          {}
func (r usersFindMany) usersModel()    {}
func (r usersFindMany) usersRelation() {}

func (r usersActions) FindMany(
	params ...UsersWhereParam,
) usersFindMany {
	var v usersFindMany
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "query"

	v.query.Method = "findMany"

	v.query.Model = "users"
	v.query.Outputs = usersOutput

	var where []builder.Field
	for _, q := range params {
		if query := q.getQuery(); query.Operation != "" {
			v.query.Outputs = append(v.query.Outputs, builder.Output{
				Name:    query.Method,
				Inputs:  query.Inputs,
				Outputs: query.Outputs,
			})
		} else {
			where = append(where, q.field())
		}
	}

	if len(where) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:   "where",
			Fields: where,
		})
	}

	return v
}

func (r usersFindMany) With(params ...UsersRelationWith) usersFindMany {
	for _, q := range params {
		query := q.getQuery()
		r.query.Outputs = append(r.query.Outputs, builder.Output{
			Name:    query.Method,
			Inputs:  query.Inputs,
			Outputs: query.Outputs,
		})
	}

	return r
}

func (r usersFindMany) Select(params ...usersPrismaFields) usersFindMany {
	var outputs []builder.Output

	for _, param := range params {
		outputs = append(outputs, builder.Output{
			Name: string(param),
		})
	}

	r.query.Outputs = outputs

	return r
}

func (r usersFindMany) Omit(params ...usersPrismaFields) usersFindMany {
	var outputs []builder.Output

	var raw []string
	for _, param := range params {
		raw = append(raw, string(param))
	}

	for _, output := range usersOutput {
		if !slices.Contains(raw, output.Name) {
			outputs = append(outputs, output)
		}
	}

	r.query.Outputs = outputs

	return r
}

func (r usersFindMany) OrderBy(params ...UsersOrderByParam) usersFindMany {
	var fields []builder.Field

	for _, param := range params {
		fields = append(fields, builder.Field{
			Name:   param.field().Name,
			Value:  param.field().Value,
			Fields: param.field().Fields,
		})
	}

	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:     "orderBy",
		Fields:   fields,
		WrapList: true,
	})

	return r
}

func (r usersFindMany) Skip(count int) usersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "skip",
		Value: count,
	})
	return r
}

func (r usersFindMany) Take(count int) usersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:  "take",
		Value: count,
	})
	return r
}

func (r usersFindMany) Cursor(cursor UsersCursorParam) usersFindMany {
	r.query.Inputs = append(r.query.Inputs, builder.Input{
		Name:   "cursor",
		Fields: []builder.Field{cursor.field()},
	})
	return r
}

func (r usersFindMany) Exec(ctx context.Context) (
	[]UsersModel,
	error,
) {
	var v []UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersFindMany) ExecInner(ctx context.Context) (
	[]InnerUsers,
	error,
) {
	var v []InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}

	return v, nil
}

func (r usersFindMany) Update(params ...UsersSetParam) usersUpdateMany {
	r.query.Operation = "mutation"
	r.query.Method = "updateMany"
	r.query.Model = "users"

	r.query.Outputs = countOutput

	var v usersUpdateMany
	v.query = r.query
	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}
	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "data",
		Fields: fields,
	})
	return v
}

type usersUpdateMany struct {
	query builder.Query
}

func (r usersUpdateMany) ExtractQuery() builder.Query {
	return r.query
}

func (r usersUpdateMany) usersModel() {}

func (r usersUpdateMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersUpdateMany) Tx() UsersManyTxResult {
	v := newUsersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

func (r usersFindMany) Delete() usersDeleteMany {
	var v usersDeleteMany
	v.query = r.query
	v.query.Operation = "mutation"
	v.query.Method = "deleteMany"
	v.query.Model = "users"

	v.query.Outputs = countOutput

	return v
}

type usersDeleteMany struct {
	query builder.Query
}

func (r usersDeleteMany) ExtractQuery() builder.Query {
	return r.query
}

func (p usersDeleteMany) usersModel() {}

func (r usersDeleteMany) Exec(ctx context.Context) (*BatchResult, error) {
	var v BatchResult
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersDeleteMany) Tx() UsersManyTxResult {
	v := newUsersManyTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template transaction.gotpl ---

func newActivitylogUniqueTxResult() ActivitylogUniqueTxResult {
	return ActivitylogUniqueTxResult{
		result: &transaction.Result{},
	}
}

type ActivitylogUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p ActivitylogUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p ActivitylogUniqueTxResult) IsTx() {}

func (r ActivitylogUniqueTxResult) Result() (v *ActivitylogModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newActivitylogManyTxResult() ActivitylogManyTxResult {
	return ActivitylogManyTxResult{
		result: &transaction.Result{},
	}
}

type ActivitylogManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p ActivitylogManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p ActivitylogManyTxResult) IsTx() {}

func (r ActivitylogManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newDevicesUniqueTxResult() DevicesUniqueTxResult {
	return DevicesUniqueTxResult{
		result: &transaction.Result{},
	}
}

type DevicesUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p DevicesUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p DevicesUniqueTxResult) IsTx() {}

func (r DevicesUniqueTxResult) Result() (v *DevicesModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newDevicesManyTxResult() DevicesManyTxResult {
	return DevicesManyTxResult{
		result: &transaction.Result{},
	}
}

type DevicesManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p DevicesManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p DevicesManyTxResult) IsTx() {}

func (r DevicesManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newGroupdevicesUniqueTxResult() GroupdevicesUniqueTxResult {
	return GroupdevicesUniqueTxResult{
		result: &transaction.Result{},
	}
}

type GroupdevicesUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p GroupdevicesUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p GroupdevicesUniqueTxResult) IsTx() {}

func (r GroupdevicesUniqueTxResult) Result() (v *GroupdevicesModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newGroupdevicesManyTxResult() GroupdevicesManyTxResult {
	return GroupdevicesManyTxResult{
		result: &transaction.Result{},
	}
}

type GroupdevicesManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p GroupdevicesManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p GroupdevicesManyTxResult) IsTx() {}

func (r GroupdevicesManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newGroupsUniqueTxResult() GroupsUniqueTxResult {
	return GroupsUniqueTxResult{
		result: &transaction.Result{},
	}
}

type GroupsUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p GroupsUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p GroupsUniqueTxResult) IsTx() {}

func (r GroupsUniqueTxResult) Result() (v *GroupsModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newGroupsManyTxResult() GroupsManyTxResult {
	return GroupsManyTxResult{
		result: &transaction.Result{},
	}
}

type GroupsManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p GroupsManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p GroupsManyTxResult) IsTx() {}

func (r GroupsManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newGrouptreeUniqueTxResult() GrouptreeUniqueTxResult {
	return GrouptreeUniqueTxResult{
		result: &transaction.Result{},
	}
}

type GrouptreeUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p GrouptreeUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p GrouptreeUniqueTxResult) IsTx() {}

func (r GrouptreeUniqueTxResult) Result() (v *GrouptreeModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newGrouptreeManyTxResult() GrouptreeManyTxResult {
	return GrouptreeManyTxResult{
		result: &transaction.Result{},
	}
}

type GrouptreeManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p GrouptreeManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p GrouptreeManyTxResult) IsTx() {}

func (r GrouptreeManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newGroupuserpermsUniqueTxResult() GroupuserpermsUniqueTxResult {
	return GroupuserpermsUniqueTxResult{
		result: &transaction.Result{},
	}
}

type GroupuserpermsUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p GroupuserpermsUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p GroupuserpermsUniqueTxResult) IsTx() {}

func (r GroupuserpermsUniqueTxResult) Result() (v *GroupuserpermsModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newGroupuserpermsManyTxResult() GroupuserpermsManyTxResult {
	return GroupuserpermsManyTxResult{
		result: &transaction.Result{},
	}
}

type GroupuserpermsManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p GroupuserpermsManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p GroupuserpermsManyTxResult) IsTx() {}

func (r GroupuserpermsManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newOrgdevicesUniqueTxResult() OrgdevicesUniqueTxResult {
	return OrgdevicesUniqueTxResult{
		result: &transaction.Result{},
	}
}

type OrgdevicesUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p OrgdevicesUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p OrgdevicesUniqueTxResult) IsTx() {}

func (r OrgdevicesUniqueTxResult) Result() (v *OrgdevicesModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newOrgdevicesManyTxResult() OrgdevicesManyTxResult {
	return OrgdevicesManyTxResult{
		result: &transaction.Result{},
	}
}

type OrgdevicesManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p OrgdevicesManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p OrgdevicesManyTxResult) IsTx() {}

func (r OrgdevicesManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newOrgrgroupUniqueTxResult() OrgrgroupUniqueTxResult {
	return OrgrgroupUniqueTxResult{
		result: &transaction.Result{},
	}
}

type OrgrgroupUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p OrgrgroupUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p OrgrgroupUniqueTxResult) IsTx() {}

func (r OrgrgroupUniqueTxResult) Result() (v *OrgrgroupModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newOrgrgroupManyTxResult() OrgrgroupManyTxResult {
	return OrgrgroupManyTxResult{
		result: &transaction.Result{},
	}
}

type OrgrgroupManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p OrgrgroupManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p OrgrgroupManyTxResult) IsTx() {}

func (r OrgrgroupManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newOrgsUniqueTxResult() OrgsUniqueTxResult {
	return OrgsUniqueTxResult{
		result: &transaction.Result{},
	}
}

type OrgsUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p OrgsUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p OrgsUniqueTxResult) IsTx() {}

func (r OrgsUniqueTxResult) Result() (v *OrgsModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newOrgsManyTxResult() OrgsManyTxResult {
	return OrgsManyTxResult{
		result: &transaction.Result{},
	}
}

type OrgsManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p OrgsManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p OrgsManyTxResult) IsTx() {}

func (r OrgsManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUsergroupUniqueTxResult() UsergroupUniqueTxResult {
	return UsergroupUniqueTxResult{
		result: &transaction.Result{},
	}
}

type UsergroupUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UsergroupUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UsergroupUniqueTxResult) IsTx() {}

func (r UsergroupUniqueTxResult) Result() (v *UsergroupModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUsergroupManyTxResult() UsergroupManyTxResult {
	return UsergroupManyTxResult{
		result: &transaction.Result{},
	}
}

type UsergroupManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UsergroupManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UsergroupManyTxResult) IsTx() {}

func (r UsergroupManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUsersUniqueTxResult() UsersUniqueTxResult {
	return UsersUniqueTxResult{
		result: &transaction.Result{},
	}
}

type UsersUniqueTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UsersUniqueTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UsersUniqueTxResult) IsTx() {}

func (r UsersUniqueTxResult) Result() (v *UsersModel) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

func newUsersManyTxResult() UsersManyTxResult {
	return UsersManyTxResult{
		result: &transaction.Result{},
	}
}

type UsersManyTxResult struct {
	query  builder.Query
	result *transaction.Result
}

func (p UsersManyTxResult) ExtractQuery() builder.Query {
	return p.query
}

func (p UsersManyTxResult) IsTx() {}

func (r UsersManyTxResult) Result() (v *BatchResult) {
	if err := r.result.Get(r.query.TxResult, &v); err != nil {
		panic(err)
	}
	return v
}

// --- template upsert.gotpl ---

type activitylogUpsertOne struct {
	query builder.Query
}

func (r activitylogUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r activitylogUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r activitylogUpsertOne) with()                {}
func (r activitylogUpsertOne) activitylogModel()    {}
func (r activitylogUpsertOne) activitylogRelation() {}

func (r activitylogActions) UpsertOne(
	params ActivitylogEqualsUniqueWhereParam,
) activitylogUpsertOne {
	var v activitylogUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "activitylog"
	v.query.Outputs = activitylogOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r activitylogUpsertOne) Create(

	_msgtype ActivitylogWithPrismaMsgtypeSetParam,
	_msgpayload ActivitylogWithPrismaMsgpayloadSetParam,

	optional ...ActivitylogSetParam,
) activitylogUpsertOne {
	var v activitylogUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _msgtype.field())
	fields = append(fields, _msgpayload.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r activitylogUpsertOne) Update(
	params ...ActivitylogSetParam,
) activitylogUpsertOne {
	var v activitylogUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r activitylogUpsertOne) Exec(ctx context.Context) (*ActivitylogModel, error) {
	var v ActivitylogModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r activitylogUpsertOne) Tx() ActivitylogUniqueTxResult {
	v := newActivitylogUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type devicesUpsertOne struct {
	query builder.Query
}

func (r devicesUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r devicesUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesUpsertOne) with()            {}
func (r devicesUpsertOne) devicesModel()    {}
func (r devicesUpsertOne) devicesRelation() {}

func (r devicesActions) UpsertOne(
	params DevicesEqualsUniqueWhereParam,
) devicesUpsertOne {
	var v devicesUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "devices"
	v.query.Outputs = devicesOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r devicesUpsertOne) Create(

	_deviceid DevicesWithPrismaDeviceidSetParam,
	_devicemeta DevicesWithPrismaDevicemetaSetParam,
	_createdby DevicesWithPrismaCreatedbySetParam,
	_updatedby DevicesWithPrismaUpdatedbySetParam,

	optional ...DevicesSetParam,
) devicesUpsertOne {
	var v devicesUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _deviceid.field())
	fields = append(fields, _devicemeta.field())
	fields = append(fields, _createdby.field())
	fields = append(fields, _updatedby.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r devicesUpsertOne) Update(
	params ...DevicesSetParam,
) devicesUpsertOne {
	var v devicesUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r devicesUpsertOne) Exec(ctx context.Context) (*DevicesModel, error) {
	var v DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r devicesUpsertOne) Tx() DevicesUniqueTxResult {
	v := newDevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupdevicesUpsertOne struct {
	query builder.Query
}

func (r groupdevicesUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesUpsertOne) with()                 {}
func (r groupdevicesUpsertOne) groupdevicesModel()    {}
func (r groupdevicesUpsertOne) groupdevicesRelation() {}

func (r groupdevicesActions) UpsertOne(
	params GroupdevicesEqualsUniqueWhereParam,
) groupdevicesUpsertOne {
	var v groupdevicesUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "groupdevices"
	v.query.Outputs = groupdevicesOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r groupdevicesUpsertOne) Create(

	_isexist GroupdevicesWithPrismaIsexistSetParam,
	_updatedby GroupdevicesWithPrismaUpdatedbySetParam,
	_devices GroupdevicesWithPrismaDevicesSetParam,
	_groups GroupdevicesWithPrismaGroupsSetParam,
	_orgs GroupdevicesWithPrismaOrgsSetParam,

	optional ...GroupdevicesSetParam,
) groupdevicesUpsertOne {
	var v groupdevicesUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _isexist.field())
	fields = append(fields, _updatedby.field())
	fields = append(fields, _devices.field())
	fields = append(fields, _groups.field())
	fields = append(fields, _orgs.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r groupdevicesUpsertOne) Update(
	params ...GroupdevicesSetParam,
) groupdevicesUpsertOne {
	var v groupdevicesUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r groupdevicesUpsertOne) Exec(ctx context.Context) (*GroupdevicesModel, error) {
	var v GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupdevicesUpsertOne) Tx() GroupdevicesUniqueTxResult {
	v := newGroupdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupsUpsertOne struct {
	query builder.Query
}

func (r groupsUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r groupsUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsUpsertOne) with()           {}
func (r groupsUpsertOne) groupsModel()    {}
func (r groupsUpsertOne) groupsRelation() {}

func (r groupsActions) UpsertOne(
	params GroupsEqualsUniqueWhereParam,
) groupsUpsertOne {
	var v groupsUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "groups"
	v.query.Outputs = groupsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r groupsUpsertOne) Create(

	_groupid GroupsWithPrismaGroupidSetParam,
	_groupname GroupsWithPrismaGroupnameSetParam,
	_isdeleted GroupsWithPrismaIsdeletedSetParam,
	_createdby GroupsWithPrismaCreatedbySetParam,
	_updatedby GroupsWithPrismaUpdatedbySetParam,
	_orgs GroupsWithPrismaOrgsSetParam,

	optional ...GroupsSetParam,
) groupsUpsertOne {
	var v groupsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _groupid.field())
	fields = append(fields, _groupname.field())
	fields = append(fields, _isdeleted.field())
	fields = append(fields, _createdby.field())
	fields = append(fields, _updatedby.field())
	fields = append(fields, _orgs.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r groupsUpsertOne) Update(
	params ...GroupsSetParam,
) groupsUpsertOne {
	var v groupsUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r groupsUpsertOne) Exec(ctx context.Context) (*GroupsModel, error) {
	var v GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupsUpsertOne) Tx() GroupsUniqueTxResult {
	v := newGroupsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type grouptreeUpsertOne struct {
	query builder.Query
}

func (r grouptreeUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r grouptreeUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeUpsertOne) with()              {}
func (r grouptreeUpsertOne) grouptreeModel()    {}
func (r grouptreeUpsertOne) grouptreeRelation() {}

func (r grouptreeActions) UpsertOne(
	params GrouptreeEqualsUniqueWhereParam,
) grouptreeUpsertOne {
	var v grouptreeUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "grouptree"
	v.query.Outputs = grouptreeOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r grouptreeUpsertOne) Create(

	_name GrouptreeWithPrismaNameSetParam,
	_groupsGrouptreeGroupidTogroups GrouptreeWithPrismaGroupsGrouptreeGroupidTogroupsSetParam,
	_orgs GrouptreeWithPrismaOrgsSetParam,
	_groupsGrouptreePgroupidTogroups GrouptreeWithPrismaGroupsGrouptreePgroupidTogroupsSetParam,

	optional ...GrouptreeSetParam,
) grouptreeUpsertOne {
	var v grouptreeUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _name.field())
	fields = append(fields, _groupsGrouptreeGroupidTogroups.field())
	fields = append(fields, _orgs.field())
	fields = append(fields, _groupsGrouptreePgroupidTogroups.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r grouptreeUpsertOne) Update(
	params ...GrouptreeSetParam,
) grouptreeUpsertOne {
	var v grouptreeUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r grouptreeUpsertOne) Exec(ctx context.Context) (*GrouptreeModel, error) {
	var v GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r grouptreeUpsertOne) Tx() GrouptreeUniqueTxResult {
	v := newGrouptreeUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type groupuserpermsUpsertOne struct {
	query builder.Query
}

func (r groupuserpermsUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsUpsertOne) with()                   {}
func (r groupuserpermsUpsertOne) groupuserpermsModel()    {}
func (r groupuserpermsUpsertOne) groupuserpermsRelation() {}

func (r groupuserpermsActions) UpsertOne(
	params GroupuserpermsEqualsUniqueWhereParam,
) groupuserpermsUpsertOne {
	var v groupuserpermsUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "groupuserperms"
	v.query.Outputs = groupuserpermsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r groupuserpermsUpsertOne) Create(

	_permid GroupuserpermsWithPrismaPermidSetParam,
	_groups GroupuserpermsWithPrismaGroupsSetParam,
	_orgs GroupuserpermsWithPrismaOrgsSetParam,
	_users GroupuserpermsWithPrismaUsersSetParam,

	optional ...GroupuserpermsSetParam,
) groupuserpermsUpsertOne {
	var v groupuserpermsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _permid.field())
	fields = append(fields, _groups.field())
	fields = append(fields, _orgs.field())
	fields = append(fields, _users.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r groupuserpermsUpsertOne) Update(
	params ...GroupuserpermsSetParam,
) groupuserpermsUpsertOne {
	var v groupuserpermsUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r groupuserpermsUpsertOne) Exec(ctx context.Context) (*GroupuserpermsModel, error) {
	var v GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r groupuserpermsUpsertOne) Tx() GroupuserpermsUniqueTxResult {
	v := newGroupuserpermsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgdevicesUpsertOne struct {
	query builder.Query
}

func (r orgdevicesUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r orgdevicesUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesUpsertOne) with()               {}
func (r orgdevicesUpsertOne) orgdevicesModel()    {}
func (r orgdevicesUpsertOne) orgdevicesRelation() {}

func (r orgdevicesActions) UpsertOne(
	params OrgdevicesEqualsUniqueWhereParam,
) orgdevicesUpsertOne {
	var v orgdevicesUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "orgdevices"
	v.query.Outputs = orgdevicesOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r orgdevicesUpsertOne) Create(

	_orgdevicemeta OrgdevicesWithPrismaOrgdevicemetaSetParam,
	_updatedby OrgdevicesWithPrismaUpdatedbySetParam,
	_devices OrgdevicesWithPrismaDevicesSetParam,
	_orgs OrgdevicesWithPrismaOrgsSetParam,

	optional ...OrgdevicesSetParam,
) orgdevicesUpsertOne {
	var v orgdevicesUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _orgdevicemeta.field())
	fields = append(fields, _updatedby.field())
	fields = append(fields, _devices.field())
	fields = append(fields, _orgs.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r orgdevicesUpsertOne) Update(
	params ...OrgdevicesSetParam,
) orgdevicesUpsertOne {
	var v orgdevicesUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r orgdevicesUpsertOne) Exec(ctx context.Context) (*OrgdevicesModel, error) {
	var v OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgdevicesUpsertOne) Tx() OrgdevicesUniqueTxResult {
	v := newOrgdevicesUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgrgroupUpsertOne struct {
	query builder.Query
}

func (r orgrgroupUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r orgrgroupUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupUpsertOne) with()              {}
func (r orgrgroupUpsertOne) orgrgroupModel()    {}
func (r orgrgroupUpsertOne) orgrgroupRelation() {}

func (r orgrgroupActions) UpsertOne(
	params OrgrgroupEqualsUniqueWhereParam,
) orgrgroupUpsertOne {
	var v orgrgroupUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "orgrgroup"
	v.query.Outputs = orgrgroupOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r orgrgroupUpsertOne) Create(

	_orgs OrgrgroupWithPrismaOrgsSetParam,
	_groups OrgrgroupWithPrismaGroupsSetParam,

	optional ...OrgrgroupSetParam,
) orgrgroupUpsertOne {
	var v orgrgroupUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _orgs.field())
	fields = append(fields, _groups.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r orgrgroupUpsertOne) Update(
	params ...OrgrgroupSetParam,
) orgrgroupUpsertOne {
	var v orgrgroupUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r orgrgroupUpsertOne) Exec(ctx context.Context) (*OrgrgroupModel, error) {
	var v OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgrgroupUpsertOne) Tx() OrgrgroupUniqueTxResult {
	v := newOrgrgroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type orgsUpsertOne struct {
	query builder.Query
}

func (r orgsUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r orgsUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsUpsertOne) with()         {}
func (r orgsUpsertOne) orgsModel()    {}
func (r orgsUpsertOne) orgsRelation() {}

func (r orgsActions) UpsertOne(
	params OrgsEqualsUniqueWhereParam,
) orgsUpsertOne {
	var v orgsUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "orgs"
	v.query.Outputs = orgsOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r orgsUpsertOne) Create(

	_orgid OrgsWithPrismaOrgidSetParam,
	_orgname OrgsWithPrismaOrgnameSetParam,
	_orgmeta OrgsWithPrismaOrgmetaSetParam,
	_createdby OrgsWithPrismaCreatedbySetParam,
	_updatedby OrgsWithPrismaUpdatedbySetParam,

	optional ...OrgsSetParam,
) orgsUpsertOne {
	var v orgsUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _orgid.field())
	fields = append(fields, _orgname.field())
	fields = append(fields, _orgmeta.field())
	fields = append(fields, _createdby.field())
	fields = append(fields, _updatedby.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r orgsUpsertOne) Update(
	params ...OrgsSetParam,
) orgsUpsertOne {
	var v orgsUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r orgsUpsertOne) Exec(ctx context.Context) (*OrgsModel, error) {
	var v OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r orgsUpsertOne) Tx() OrgsUniqueTxResult {
	v := newOrgsUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usergroupUpsertOne struct {
	query builder.Query
}

func (r usergroupUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r usergroupUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupUpsertOne) with()              {}
func (r usergroupUpsertOne) usergroupModel()    {}
func (r usergroupUpsertOne) usergroupRelation() {}

func (r usergroupActions) UpsertOne(
	params UsergroupEqualsUniqueWhereParam,
) usergroupUpsertOne {
	var v usergroupUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "usergroup"
	v.query.Outputs = usergroupOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r usergroupUpsertOne) Create(

	_groups UsergroupWithPrismaGroupsSetParam,
	_orgs UsergroupWithPrismaOrgsSetParam,
	_users UsergroupWithPrismaUsersSetParam,

	optional ...UsergroupSetParam,
) usergroupUpsertOne {
	var v usergroupUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _groups.field())
	fields = append(fields, _orgs.field())
	fields = append(fields, _users.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r usergroupUpsertOne) Update(
	params ...UsergroupSetParam,
) usergroupUpsertOne {
	var v usergroupUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r usergroupUpsertOne) Exec(ctx context.Context) (*UsergroupModel, error) {
	var v UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usergroupUpsertOne) Tx() UsergroupUniqueTxResult {
	v := newUsergroupUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

type usersUpsertOne struct {
	query builder.Query
}

func (r usersUpsertOne) getQuery() builder.Query {
	return r.query
}

func (r usersUpsertOne) ExtractQuery() builder.Query {
	return r.query
}

func (r usersUpsertOne) with()          {}
func (r usersUpsertOne) usersModel()    {}
func (r usersUpsertOne) usersRelation() {}

func (r usersActions) UpsertOne(
	params UsersEqualsUniqueWhereParam,
) usersUpsertOne {
	var v usersUpsertOne
	v.query = builder.NewQuery()
	v.query.Engine = r.client

	v.query.Operation = "mutation"
	v.query.Method = "upsertOne"
	v.query.Model = "users"
	v.query.Outputs = usersOutput

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "where",
		Fields: builder.TransformEquals([]builder.Field{params.field()}),
	})

	return v
}

func (r usersUpsertOne) Create(

	_userid UsersWithPrismaUseridSetParam,
	_name UsersWithPrismaNameSetParam,
	_email UsersWithPrismaEmailSetParam,
	_isemailverified UsersWithPrismaIsemailverifiedSetParam,
	_isenabled UsersWithPrismaIsenabledSetParam,
	_secretprv UsersWithPrismaSecretprvSetParam,
	_secretpub UsersWithPrismaSecretpubSetParam,
	_createdat UsersWithPrismaCreatedatSetParam,
	_updatedat UsersWithPrismaUpdatedatSetParam,

	optional ...UsersSetParam,
) usersUpsertOne {
	var v usersUpsertOne
	v.query = r.query

	var fields []builder.Field
	fields = append(fields, _userid.field())
	fields = append(fields, _name.field())
	fields = append(fields, _email.field())
	fields = append(fields, _isemailverified.field())
	fields = append(fields, _isenabled.field())
	fields = append(fields, _secretprv.field())
	fields = append(fields, _secretpub.field())
	fields = append(fields, _createdat.field())
	fields = append(fields, _updatedat.field())

	for _, q := range optional {
		fields = append(fields, q.field())
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "create",
		Fields: fields,
	})

	return v
}

func (r usersUpsertOne) Update(
	params ...UsersSetParam,
) usersUpsertOne {
	var v usersUpsertOne
	v.query = r.query

	var fields []builder.Field
	for _, q := range params {

		field := q.field()

		_, isJson := field.Value.(types.JSON)
		if field.Value != nil && !isJson {
			v := field.Value
			field.Fields = []builder.Field{
				{
					Name:  "set",
					Value: v,
				},
			}

			field.Value = nil
		}

		fields = append(fields, field)
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:   "update",
		Fields: fields,
	})

	return v
}

func (r usersUpsertOne) Exec(ctx context.Context) (*UsersModel, error) {
	var v UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return &v, nil
}

func (r usersUpsertOne) Tx() UsersUniqueTxResult {
	v := newUsersUniqueTxResult()
	v.query = r.query
	v.query.TxResult = make(chan []byte, 1)
	return v
}

// --- template raw.gotpl ---

type activitylogAggregateRaw struct {
	query builder.Query
}

func (r activitylogAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r activitylogAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r activitylogAggregateRaw) with()                {}
func (r activitylogAggregateRaw) activitylogModel()    {}
func (r activitylogAggregateRaw) activitylogRelation() {}

func (r activitylogActions) FindRaw(filter interface{}, options ...interface{}) activitylogAggregateRaw {
	var v activitylogAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "activitylog"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r activitylogActions) AggregateRaw(pipeline []interface{}, options ...interface{}) activitylogAggregateRaw {
	var v activitylogAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "activitylog"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r activitylogAggregateRaw) Exec(ctx context.Context) ([]ActivitylogModel, error) {
	var v []ActivitylogModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r activitylogAggregateRaw) ExecInner(ctx context.Context) ([]InnerActivitylog, error) {
	var v []InnerActivitylog
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type devicesAggregateRaw struct {
	query builder.Query
}

func (r devicesAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r devicesAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r devicesAggregateRaw) with()            {}
func (r devicesAggregateRaw) devicesModel()    {}
func (r devicesAggregateRaw) devicesRelation() {}

func (r devicesActions) FindRaw(filter interface{}, options ...interface{}) devicesAggregateRaw {
	var v devicesAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "devices"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r devicesActions) AggregateRaw(pipeline []interface{}, options ...interface{}) devicesAggregateRaw {
	var v devicesAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "devices"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r devicesAggregateRaw) Exec(ctx context.Context) ([]DevicesModel, error) {
	var v []DevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r devicesAggregateRaw) ExecInner(ctx context.Context) ([]InnerDevices, error) {
	var v []InnerDevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type groupdevicesAggregateRaw struct {
	query builder.Query
}

func (r groupdevicesAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r groupdevicesAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r groupdevicesAggregateRaw) with()                 {}
func (r groupdevicesAggregateRaw) groupdevicesModel()    {}
func (r groupdevicesAggregateRaw) groupdevicesRelation() {}

func (r groupdevicesActions) FindRaw(filter interface{}, options ...interface{}) groupdevicesAggregateRaw {
	var v groupdevicesAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "groupdevices"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r groupdevicesActions) AggregateRaw(pipeline []interface{}, options ...interface{}) groupdevicesAggregateRaw {
	var v groupdevicesAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "groupdevices"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r groupdevicesAggregateRaw) Exec(ctx context.Context) ([]GroupdevicesModel, error) {
	var v []GroupdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r groupdevicesAggregateRaw) ExecInner(ctx context.Context) ([]InnerGroupdevices, error) {
	var v []InnerGroupdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type groupsAggregateRaw struct {
	query builder.Query
}

func (r groupsAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r groupsAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r groupsAggregateRaw) with()           {}
func (r groupsAggregateRaw) groupsModel()    {}
func (r groupsAggregateRaw) groupsRelation() {}

func (r groupsActions) FindRaw(filter interface{}, options ...interface{}) groupsAggregateRaw {
	var v groupsAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "groups"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r groupsActions) AggregateRaw(pipeline []interface{}, options ...interface{}) groupsAggregateRaw {
	var v groupsAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "groups"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r groupsAggregateRaw) Exec(ctx context.Context) ([]GroupsModel, error) {
	var v []GroupsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r groupsAggregateRaw) ExecInner(ctx context.Context) ([]InnerGroups, error) {
	var v []InnerGroups
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type grouptreeAggregateRaw struct {
	query builder.Query
}

func (r grouptreeAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r grouptreeAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r grouptreeAggregateRaw) with()              {}
func (r grouptreeAggregateRaw) grouptreeModel()    {}
func (r grouptreeAggregateRaw) grouptreeRelation() {}

func (r grouptreeActions) FindRaw(filter interface{}, options ...interface{}) grouptreeAggregateRaw {
	var v grouptreeAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "grouptree"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r grouptreeActions) AggregateRaw(pipeline []interface{}, options ...interface{}) grouptreeAggregateRaw {
	var v grouptreeAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "grouptree"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r grouptreeAggregateRaw) Exec(ctx context.Context) ([]GrouptreeModel, error) {
	var v []GrouptreeModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r grouptreeAggregateRaw) ExecInner(ctx context.Context) ([]InnerGrouptree, error) {
	var v []InnerGrouptree
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type groupuserpermsAggregateRaw struct {
	query builder.Query
}

func (r groupuserpermsAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r groupuserpermsAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r groupuserpermsAggregateRaw) with()                   {}
func (r groupuserpermsAggregateRaw) groupuserpermsModel()    {}
func (r groupuserpermsAggregateRaw) groupuserpermsRelation() {}

func (r groupuserpermsActions) FindRaw(filter interface{}, options ...interface{}) groupuserpermsAggregateRaw {
	var v groupuserpermsAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "groupuserperms"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r groupuserpermsActions) AggregateRaw(pipeline []interface{}, options ...interface{}) groupuserpermsAggregateRaw {
	var v groupuserpermsAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "groupuserperms"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r groupuserpermsAggregateRaw) Exec(ctx context.Context) ([]GroupuserpermsModel, error) {
	var v []GroupuserpermsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r groupuserpermsAggregateRaw) ExecInner(ctx context.Context) ([]InnerGroupuserperms, error) {
	var v []InnerGroupuserperms
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type orgdevicesAggregateRaw struct {
	query builder.Query
}

func (r orgdevicesAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r orgdevicesAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r orgdevicesAggregateRaw) with()               {}
func (r orgdevicesAggregateRaw) orgdevicesModel()    {}
func (r orgdevicesAggregateRaw) orgdevicesRelation() {}

func (r orgdevicesActions) FindRaw(filter interface{}, options ...interface{}) orgdevicesAggregateRaw {
	var v orgdevicesAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "orgdevices"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r orgdevicesActions) AggregateRaw(pipeline []interface{}, options ...interface{}) orgdevicesAggregateRaw {
	var v orgdevicesAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "orgdevices"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r orgdevicesAggregateRaw) Exec(ctx context.Context) ([]OrgdevicesModel, error) {
	var v []OrgdevicesModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r orgdevicesAggregateRaw) ExecInner(ctx context.Context) ([]InnerOrgdevices, error) {
	var v []InnerOrgdevices
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type orgrgroupAggregateRaw struct {
	query builder.Query
}

func (r orgrgroupAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r orgrgroupAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r orgrgroupAggregateRaw) with()              {}
func (r orgrgroupAggregateRaw) orgrgroupModel()    {}
func (r orgrgroupAggregateRaw) orgrgroupRelation() {}

func (r orgrgroupActions) FindRaw(filter interface{}, options ...interface{}) orgrgroupAggregateRaw {
	var v orgrgroupAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "orgrgroup"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r orgrgroupActions) AggregateRaw(pipeline []interface{}, options ...interface{}) orgrgroupAggregateRaw {
	var v orgrgroupAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "orgrgroup"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r orgrgroupAggregateRaw) Exec(ctx context.Context) ([]OrgrgroupModel, error) {
	var v []OrgrgroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r orgrgroupAggregateRaw) ExecInner(ctx context.Context) ([]InnerOrgrgroup, error) {
	var v []InnerOrgrgroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type orgsAggregateRaw struct {
	query builder.Query
}

func (r orgsAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r orgsAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r orgsAggregateRaw) with()         {}
func (r orgsAggregateRaw) orgsModel()    {}
func (r orgsAggregateRaw) orgsRelation() {}

func (r orgsActions) FindRaw(filter interface{}, options ...interface{}) orgsAggregateRaw {
	var v orgsAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "orgs"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r orgsActions) AggregateRaw(pipeline []interface{}, options ...interface{}) orgsAggregateRaw {
	var v orgsAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "orgs"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r orgsAggregateRaw) Exec(ctx context.Context) ([]OrgsModel, error) {
	var v []OrgsModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r orgsAggregateRaw) ExecInner(ctx context.Context) ([]InnerOrgs, error) {
	var v []InnerOrgs
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type usergroupAggregateRaw struct {
	query builder.Query
}

func (r usergroupAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r usergroupAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r usergroupAggregateRaw) with()              {}
func (r usergroupAggregateRaw) usergroupModel()    {}
func (r usergroupAggregateRaw) usergroupRelation() {}

func (r usergroupActions) FindRaw(filter interface{}, options ...interface{}) usergroupAggregateRaw {
	var v usergroupAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "usergroup"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r usergroupActions) AggregateRaw(pipeline []interface{}, options ...interface{}) usergroupAggregateRaw {
	var v usergroupAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "usergroup"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r usergroupAggregateRaw) Exec(ctx context.Context) ([]UsergroupModel, error) {
	var v []UsergroupModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r usergroupAggregateRaw) ExecInner(ctx context.Context) ([]InnerUsergroup, error) {
	var v []InnerUsergroup
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

type usersAggregateRaw struct {
	query builder.Query
}

func (r usersAggregateRaw) getQuery() builder.Query {
	return r.query
}

func (r usersAggregateRaw) ExtractQuery() builder.Query {
	return r.query
}

func (r usersAggregateRaw) with()          {}
func (r usersAggregateRaw) usersModel()    {}
func (r usersAggregateRaw) usersRelation() {}

func (r usersActions) FindRaw(filter interface{}, options ...interface{}) usersAggregateRaw {
	var v usersAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "findRaw"
	v.query.Operation = "query"
	v.query.Model = "users"

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "filter",
		Value: fmt.Sprintf("%v", filter),
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r usersActions) AggregateRaw(pipeline []interface{}, options ...interface{}) usersAggregateRaw {
	var v usersAggregateRaw
	v.query = builder.NewQuery()
	v.query.Engine = r.client
	v.query.Method = "aggregateRaw"
	v.query.Operation = "query"
	v.query.Model = "users"

	parsedPip := []interface{}{}
	for _, p := range pipeline {
		parsedPip = append(parsedPip, fmt.Sprintf("%v", p))
	}

	v.query.Inputs = append(v.query.Inputs, builder.Input{
		Name:  "pipeline",
		Value: parsedPip,
	})

	if len(options) > 0 {
		v.query.Inputs = append(v.query.Inputs, builder.Input{
			Name:  "options",
			Value: fmt.Sprintf("%v", options[0]),
		})
	}
	return v
}

func (r usersAggregateRaw) Exec(ctx context.Context) ([]UsersModel, error) {
	var v []UsersModel
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}

func (r usersAggregateRaw) ExecInner(ctx context.Context) ([]InnerUsers, error) {
	var v []InnerUsers
	if err := r.query.Exec(ctx, &v); err != nil {
		return nil, err
	}
	return v, nil
}
